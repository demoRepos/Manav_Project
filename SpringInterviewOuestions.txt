1 : What is Framework ?

Frameworks are large bodies (usually many classes) of prewritten code to which you add your own code to solve a problem in a specific domain. You make use of a framework by calling its
methods, inheritance, and supplying "callbacks", listeners, or other implementations of the Observer pattern. The framework, in broader sense, can be defined as a structure where we 
find solution of the various technical problems.

The difference between a framework and an ordinary programming library is that a framework employs an inverted flow of control between itself and its clients. When using a framework, 
one usually just implements a few callback functions or specializes a few classes, and then invokes a single method or procedure. At this point, the framework does the rest of the work
for you, invoking any necessary client callbacks or methods at the appropriate time and place. 

Usefulness of frameworks

A framework will often dictate the structure of your application. Some frameworks even supply so much code that you have to do very little to write your application. This can be good or
bad, depending on how easy it is to use.

Frameworks are the substance of programming. You build on top of a good one, your program is solid and fast and comes together beautifully. You build on top of a bad one, your life is
miserable, brutish, and short.

Examples in Java

A very common example are GUI frameworks, eg Java's Swing and AWT classes. They have a huge amount of code to manage the user interface, and there is inversion of control because you 
start the GUI framework and then wait for it to call your listeners.

The Collections classes are sometimes called a framework, perhaps largely because of the size and complexity. But it is more properly referred to as a library because there is no 
inversion of control -- your programs simply calls methods in these predefined or extended classes.

Popular framework is as follows : play, grails.

2 : Advantage IOC/Dependency injections. (mentioned in SpringFrameworkInfo.txt file)

3 : Spring Modules

Spring Modules
Test
Spring Core Container
AOP, Aspects and Instrumentation
Data Access / Integration
Web

The Spring framework comprises of many modules such as core, beans, context, expression language, AOP, Aspects, Instrumentation, JDBC, ORM, OXM, JMS, Transaction, Web, Servlet, Struts
etc. These modules are grouped into Test, Core Container, AOP, Aspects, Instrumentation, Data Access / Integration, Web (MVC / Remoting) as displayed in the following diagram.


Spring modules 
 
Test
This layer provides support of testing with JUnit and TestNG.

Spring Core Container
The Spring Core container contains core, beans, context and expression language (EL) modules.

Core and Beans
These modules provide IOC and Dependency Injection features.

Context
This module supports internationalization (I18N), EJB, JMS, Basic Remoting.

Expression Language
It is an extension to the EL defined in JSP. It provides support to setting and getting property values, method invocation, accessing collections and indexers, named variables,
logical and arithmetic operators, retrieval of objects by name etc.

AOP, Aspects and Instrumentation
These modules support aspect oriented programming implementation where you can use Advices, Pointcuts etc. to decouple the code.

The aspects module provides support to integration with AspectJ.
The instrumentation module provides support to class instrumentation and classloader implementations.

Data Access / Integration
This group comprises of JDBC, ORM, OXM, JMS and Transaction modules. These modules basically provide support to interact with the database.

Web
This group comprises of Web, Web-Servlet, Web-Struts and Web-Portlet. These modules provide support to create web application.

4 : Spring Example

Steps to create spring application
Here, we are going to learn the simple steps to create the first spring application. To run this application, we are not using any IDE. We are simply using the command prompt. Let's
see the simple steps to create the spring application

create the class
create the xml file to provide the values
create the test class
Load the spring jar files
Run the test class

 
Steps to create spring application


Let's see the 5 steps to create the first spring application.

1) Create Java class

This is the simple java bean class containing the name property only.

package com.javatpoint;  
  
public class Student {  
private String name;  
  
public String getName() {  
    return name;  
}  
  
public void setName(String name) {  
    this.name = name;  
}  
  
public void displayInfo(){  
    System.out.println("Hello: "+name);  
}  
}  

This is simple bean class, containing only one property name with its getters and setters method. This class contains one extra method named displayInfo() that prints the student name
by the hello message.


2) Create the xml file

In case of myeclipse IDE, you don't need to create the xml file as myeclipse does this for yourselves. Open the applicationContext.xml file, and write the following code:

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
               http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="studentbean" class="com.javatpoint.Student">  
<property name="name" value="Vimal Jaiswal"></property>  
</bean>  
  
</beans>  
The bean element is used to define the bean for the given class. The property subelement of bean specifies the property of the Student class named name. The value specified in the 
property element will be set in the Student class object by the IOC container.


3) Create the test class

Create the java class e.g. Test. Here we are getting the object of Student class from the IOC container using the getBean() method of BeanFactory. Let's see the code of test class.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource resource=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(resource);  
      
    Student student=(Student)factory.getBean("studentbean");  
    student.displayInfo();  
}  
}  

The Resource object represents the information of applicationContext.xml file. The Resource is the interface and the ClassPathResource is the implementation class of the Reource 
interface. The BeanFactory is responsible to return the bean. The XmlBeanFactory is the implementation class of the BeanFactory. There are many methods in the BeanFactory interface. 
One method is getBean(), which returns the object of the associated class.


4) Load the jar files required for spring framework

There are mainly three jar files required to run this application.

org.springframework.core-3.0.1.RELEASE-A
com.springsource.org.apache.commons.logging-1.1.1
org.springframework.beans-3.0.1.RELEASE-A
For the future use, You can download the required jar files for spring core application.

download the core jar files for spring

download the all jar files for spring including core, web, aop, mvc, j2ee, remoting, oxm, jdbc, orm etc.

To run this example, you need to load only spring core jar files.


5) Run the test class

Now run the Test class. You will get the output Hello: Vimal Jaiswal.


5 : IoC Container

The IoC container is responsible to instantiate, configure and assemble the objects. The IoC container gets informations from the XML file and works accordingly. The main tasks 
performed by IoC container are:

to instantiate the application class
to configure the object
to assemble the dependencies between the objects


There are two types of IoC containers. They are:
BeanFactory
ApplicationContext


Difference between BeanFactory and the ApplicationContext
The org.springframework.beans.factory.BeanFactory and the org.springframework.context.ApplicationContext interfaces acts as the IoC container. The ApplicationContext interface is 
built on top of the BeanFactory interface. It adds some extra functionality than BeanFactory such as simple integration with Spring's AOP, message resource handling (for I18N), 
event propagation, application layer specific context (e.g. WebApplicationContext) for web application. So it is better to use ApplicationContext than BeanFactory.

 
Using BeanFactory

The XmlBeanFactory is the implementation class for the BeanFactory interface. To use the BeanFactory, we need to create the instance of XmlBeanFactory class as given below:
Resource resource=new ClassPathResource("applicationContext.xml");  
BeanFactory factory=new XmlBeanFactory(resource);  

The constructor of XmlBeanFactory class receives the Resource object so we need to pass the resource object to create the object of BeanFactory.


Using ApplicationContext

The ClassPathXmlApplicationContext class is the implementation class of ApplicationContext interface. We need to instantiate the ClassPathXmlApplicationContext class to use the 
ApplicationContext as given below:
ApplicationContext context =   
    new ClassPathXmlApplicationContext("applicationContext.xml");  

The constructor of ClassPathXmlApplicationContext class receives string, so we can pass the name of the xml file to create the instance of ApplicationContext.

6 : Spring framework implemented by keeping in mind to resolve the dependency injection. Dependency Injection problem is that problem in which we will create the
object of one class in another class. For example below : 

class Tea{

private void dis(){

code....

}

}

class res {

Tea t = new Tea();

private void diss(){

t.dis();

}

}

In above code, Tea class object is created in res class. This means res class is a dependent on Tea class. If we are using this approach then it is difficult
for us if in future i have change/modify the class ' Tea ' property or class name then it will become very difficult for us to change the same in all another
classes where we have used the class ' Tea ' in case of big application. So, in order to resolve this problem spring have discovered the Dependency Injection
feature. Dependency injection allows us to use the object of class ' Tea ' in another class but not by creating the object of class ' Tea ' to that class where
we want to use.


In order to create the Simple spring application you have to follow the below steps :-

1 : Create the java file.
2 : Create the configration file.
3 : Create the second java file where we call the configration file.

1 : class test {

public void getDisplay(){

System.out.println("Test");

}

}


2 : Configration file

xml format line then

<beans more attributes for spring>

<bean id = "beanID" class = "full package path with particular java file location" >

</bean>

</beans>

3 : public class mc{

public static void main(String ...f){

ApplicationContext context = new ClassPathXmlApplicationContext("configration file name.xml file");

test t = (test) context.getBean("beanID");

t.getDisplay();

}

}


I order to add property for a class ' test ' and assign value to that property by using configration file, you have to update the above code which are as
follows : 

In order to create the Simple spring application with one property and assign the value to that property in configration file you have to follow the below 
steps :-

1 : Create the java file with one property.
2 : Create the configration file and also assign value for that property.
3 : Create the second java file where we call the configration file.

1 : class test {

public String welcomeNote;

public void setWelcomeNote(String welcomeNote){

this.welcomeNote = welcomeNote;

}

public void getDisplay(){

System.out.println(welcomeNote);

}

}


2 : Configration file

xml format line then

<beans more attributes for spring>

<bean id = "beanID" class = "full package path with particular java file location" >

<property name = "welcomeNote" value = "test"/>

</bean>

</beans>

3 : public class mc{

public static void main(String ...f){

ApplicationContext context = new ClassPathXmlApplicationContext("configration file name.xml file");

test t = (test) context.getBean("beanID");

t.getDisplay();

}

}

Another example for DI : 

Dependency Injection

The Dependency Injection is a design pattern that removes the dependency of the programs. In such case we provide the information from the external source such as XML file. It makes
our code loosely coupled and easier for testing. In such case we write the code as:

class Employee{  
Address address;  
  
Employee(Address address){  
this.address=address;  
}  
public void setAddress(Address address){  
this.address=address;  
}  
  
}  
In such case, instance of Address class is provided by external souce such as XML file either by constructor or setter method. Two ways to perform Dependency Injection in Spring 
framework

Spring framework provides two ways to inject dependency

By Constructor
By Setter method


Dependency Injection by Constructor Example

Dependency Injection by constructor
Injecting primitive and string-based values

We can inject the dependency by constructor. The <constructor-arg> subelement of <bean> is used for constructor injection. Here we are going to inject

primitive and String-based values
Dependent object (contained object)
Collection values etc.
Injecting primitive and string-based values

Let's see the simple example to inject primitive and string-based values. We have created three files here:

Employee.java
applicationContext.xml
Test.java


Employee.java

It is a simple class containing two fields id and name. There are four constructors and one method in this class.

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
  
public Employee() {System.out.println("def cons");}  
  
public Employee(int id) {this.id = id;}  
  
public Employee(String name) {  this.name = name;}  
  
public Employee(int id, String name) {  
    this.id = id;  
    this.name = name;  
}  
  
void show(){  
    System.out.println(id+" "+name);  
}  
  
}  


applicationContext.xml

We are providing the information into the bean by this file. The constructor-arg element invokes the constructor. In such case, parameterized constructor of int type will be invoked. 
The value attribute of constructor-arg element will assign the specified value. The type attribute specifies that int parameter constructor will be invoked.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
                http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="e" class="com.javatpoint.Employee">  
<constructor-arg value="10" type="int"></constructor-arg>  
</bean>  
  
</beans>  


Test.java

This class gets the bean from the applicationContext.xml file and calls the show method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.*;  
  
public class Test {  
    public static void main(String[] args) {  
          
        Resource r=new ClassPathResource("applicationContext.xml");  
        BeanFactory factory=new XmlBeanFactory(r);  
          
        Employee s=(Employee)factory.getBean("e");  
        s.show();  
          
    }  
}  

Output:10 null


Injecting string-based values

If you don't specify the type attribute in the constructor-arg element, by default string type constructor will be invoked.
<bean id="e" class="com.javatpoint.Employee">  
<constructor-arg value="10"></constructor-arg>  
</bean>  

If you change the bean element as given above, string parameter constructor will be invoked and the output will be 0 10.

Output:0 10


You may also pass the string literal as following:
<bean id="e" class="com.javatpoint.Employee">  
<constructor-arg value="Sonoo"></constructor-arg>  
</bean>  

Output:0 Sonoo


You may pass integer literal and string both as following
<bean id="e" class="com.javatpoint.Employee">  
<constructor-arg value="10" type="int" ></constructor-arg>  
<constructor-arg value="Sonoo"></constructor-arg>  
</bean>  

Output:10 Sonoo


Constructor Injection with Dependent Object

Constructor Injection with Dependent Object
If there is HAS-A relationship between the classes, we create the instance of dependent object (contained object) first then pass it as an argument of the main class constructor. Here, our scenario is Employee HAS-A Address. The Address class object will be termed as the dependent object. Let's see the Address class first:

Address.java
This class contains three properties, one constructor and toString() method to return the values of these object.

package com.javatpoint;  
  
public class Address {  
private String city;  
private String state;  
private String country;  
  
public Address(String city, String state, String country) {  
    super();  
    this.city = city;  
    this.state = state;  
    this.country = country;  
}  
  
public String toString(){  
    return city+" "+state+" "+country;  
}  
}  


Employee.java
It contains three properties id, name and address(dependent object) ,two constructors and show() method to show the records of the current object including the depedent object.

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private Address address;//Aggregation  
  
public Employee() {System.out.println("def cons");}  
  
public Employee(int id, String name, Address address) {  
    super();  
    this.id = id;  
    this.name = name;  
    this.address = address;  
}  
  
void show(){  
    System.out.println(id+" "+name);  
    System.out.println(address.toString());  
}  
  
}  


applicationContext.xml
The ref attribute is used to define the reference of another object, such way we are passing the dependent object as an constructor argument.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
                http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="a1" class="com.javatpoint.Address">  
<constructor-arg value="ghaziabad"></constructor-arg>  
<constructor-arg value="UP"></constructor-arg>  
<constructor-arg value="India"></constructor-arg>  
</bean>  
  
  
<bean id="e" class="com.javatpoint.Employee">  
<constructor-arg value="12" type="int"></constructor-arg>  
<constructor-arg value="Sonoo"></constructor-arg>  
<constructor-arg>  
<ref bean="a1"/>  
</constructor-arg>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the show method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.*;  
  
public class Test {  
    public static void main(String[] args) {  
          
        Resource r=new ClassPathResource("applicationContext.xml");  
        BeanFactory factory=new XmlBeanFactory(r);  
          
        Employee s=(Employee)factory.getBean("e");  
        s.show();  
          
    }  
	

Constructor Injection with Collection Example

We can inject collection values by constructor in spring framework. There can be used three elements inside the constructor-arg element.It can be:
list
set
map

Each collection can have string based and non-string based values. In this example, we are taking the example of Forum where One question can have multiple answers. There are three 
pages:

Question.java
applicationContext.xml
Test.java

In this example, we are using list that can have duplicate elements, you may use set that have only unique elements. But, you need to change list to set in the applicationContext.xml
file and List to Set in the Question.java file.


Question.java
This class contains three properties, two constructors and displayInfo() method that prints the information. Here, we are using List to contain the multiple answers.

package com.javatpoint;  
  
import java.util.Iterator;  
import java.util.List;  
  
public class Question {  
private int id;  
private String name;  
private List<String> answers;  
  
public Question() {}  
public Question(int id, String name, List<String> answers) {  
    super();  
    this.id = id;  
    this.name = name;  
    this.answers = answers;  
}  
  
public void displayInfo(){  
    System.out.println(id+" "+name);  
    System.out.println("answers are:");  
    Iterator<String> itr=answers.iterator();  
    while(itr.hasNext()){  
        System.out.println(itr.next());  
    }  
}  
  
}  


applicationContext.xml
The list element of constructor-arg is used here to define the list.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="q" class="com.javatpoint.Question">  
<constructor-arg value="111"></constructor-arg>  
<constructor-arg value="What is java?"></constructor-arg>  
<constructor-arg>  
<list>  
<value>Java is a programming language</value>  
<value>Java is a Platform</value>  
<value>Java is an Island of Indonasia</value>  
</list>  
</constructor-arg>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Question q=(Question)factory.getBean("q");  
    q.displayInfo();  
      
}  
} 	


Constructor Injection with Non-String Collection (having Dependent Object) Example

If we have dependent object in the collection, we can inject these information by using the ref element inside the list, set or map. In this example, we are taking the example of
Forum where One question can have multiple answers. But Answer has its own information such as answerId, answer and postedBy. There are four pages used in this example:

Question.java
Answer.java
applicationContext.xml
Test.java

In this example, we are using list that can have duplicate elements, you may use set that have only unique elements. But, you need to change list to set in the applicationContext.xml
file and List to Set in the Question.java file.


Question.java
This class contains three properties, two constructors and displayInfo() method that prints the information. Here, we are using List to contain the multiple answers.

package com.javatpoint;  
  
import java.util.Iterator;  
import java.util.List;  
  
public class Question {  
private int id;  
private String name;  
private List<Answer> answers;  
  
public Question() {}  
public Question(int id, String name, List<Answer> answers) {  
    super();  
    this.id = id;  
    this.name = name;  
    this.answers = answers;  
}  
  
public void displayInfo(){  
    System.out.println(id+" "+name);  
    System.out.println("answers are:");  
    Iterator<Answer> itr=answers.iterator();  
    while(itr.hasNext()){  
        System.out.println(itr.next());  
    }  
}  
  
}  


Answer.java
This class has three properties id, name and by with constructor and toString() method.

package com.javatpoint;  
  
public class Answer {  
private int id;  
private String name;  
private String by;  
  
public Answer() {}  
public Answer(int id, String name, String by) {  
    super();  
    this.id = id;  
    this.name = name;  
    this.by = by;  
}  
  
public String toString(){  
    return id+" "+name+" "+by;  
}  
}  


applicationContext.xml
The ref element is used to define the reference of another bean. Here, we are using bean attribute of ref element to specify the reference of another bean.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="ans1" class="com.javatpoint.Answer">  
<constructor-arg value="1"></constructor-arg>  
<constructor-arg value="Java is a programming language"></constructor-arg>  
<constructor-arg value="John"></constructor-arg>  
</bean>  
  
<bean id="ans2" class="com.javatpoint.Answer">  
<constructor-arg value="2"></constructor-arg>  
<constructor-arg value="Java is a Platform"></constructor-arg>  
<constructor-arg value="Ravi"></constructor-arg>  
</bean>  
  
<bean id="q" class="com.javatpoint.Question">  
<constructor-arg value="111"></constructor-arg>  
<constructor-arg value="What is java?"></constructor-arg>  
<constructor-arg>  
<list>  
<ref bean="ans1"/>  
<ref bean="ans2"/>  
</list>  
</constructor-arg>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Question q=(Question)factory.getBean("q");  
    q.displayInfo();  
      
}  
}


Constructor Injection with Map Example

In this example, we are using map as the answer that have answer with posted username. Here, we are using key and value pair both as a string. Like previous examples, it is the example
of forum where one question can have multiple answers.


Question.java
This class contains three properties, two constructors and displayInfo() method to display the information.

package com.javatpoint;  
import java.util.Iterator;  
import java.util.Map;  
import java.util.Set;  
import java.util.Map.Entry;  
  
public class Question {  
private int id;  
private String name;  
private Map<String,String> answers;  
  
public Question() {}  
public Question(int id, String name, Map<String, String> answers) {  
    super();  
    this.id = id;  
    this.name = name;  
    this.answers = answers;  
}  
  
public void displayInfo(){  
    System.out.println("question id:"+id);  
    System.out.println("question name:"+name);  
    System.out.println("Answers....");  
    Set<Entry<String, String>> set=answers.entrySet();  
    Iterator<Entry<String, String>> itr=set.iterator();  
    while(itr.hasNext()){  
        Entry<String,String> entry=itr.next();  
        System.out.println("Answer:"+entry.getKey()+" Posted By:"+entry.getValue());  
    }  
}  
}  


applicationContext.xml
The entry attribute of map is used to define the key and value information.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="q" class="com.javatpoint.Question">  
<constructor-arg value="11"></constructor-arg>  
<constructor-arg value="What is Java?"></constructor-arg>  
<constructor-arg>  
<map>  
<entry key="Java is a Programming Language"  value="Ajay Kumar"></entry>  
<entry key="Java is a Platform" value="John Smith"></entry>  
<entry key="Java is an Island" value="Raj Kumar"></entry>  
</map>  
</constructor-arg>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo() method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Question q=(Question)factory.getBean("q");  
    q.displayInfo();  
      
}  
}  	


Constructor Injection with Non-String Map (having dependent Object) Example

In this example, we are using map as the answer that have Answer and User. Here, we are using key and value pair both as an object. Answer has its own information such as answerId, 
answer and postedDate, User has its own information such as userId, username, emailId.

Like previous examples, it is the example of forum where one question can have multiple answers.


Question.java
This class contains three properties, two constructors and displayInfo() method to display the information.

package com.javatpoint;  
import java.util.Iterator;  
import java.util.Map;  
import java.util.Set;  
import java.util.Map.Entry;  
  
public class Question {  
private int id;  
private String name;  
private Map<Answer,User> answers;  
  
public Question() {}  
public Question(int id, String name, Map<Answer, User> answers) {  
    super();  
    this.id = id;  
    this.name = name;  
    this.answers = answers;  
}  
  
  
public void displayInfo(){  
    System.out.println("question id:"+id);  
    System.out.println("question name:"+name);  
    System.out.println("Answers....");  
    Set<Entry<Answer, User>> set=answers.entrySet();  
    Iterator<Entry<Answer, User>> itr=set.iterator();  
    while(itr.hasNext()){  
        Entry<Answer, User> entry=itr.next();  
        Answer ans=entry.getKey();  
        User user=entry.getValue();  
        System.out.println("Answer Information:");  
        System.out.println(ans);  
        System.out.println("Posted By:");  
        System.out.println(user);  
    }  
}  
}  


Answer.java
package com.javatpoint;  
  
import java.util.Date;  
  
public class Answer {  
private int id;  
private String answer;  
private Date postedDate;  
public Answer() {}  
public Answer(int id, String answer, Date postedDate) {  
    super();  
    this.id = id;  
    this.answer = answer;  
    this.postedDate = postedDate;  
}  
  
public String toString(){  
    return "Id:"+id+" Answer:"+answer+" Posted Date:"+postedDate;  
}  
}  


User.java
package com.javatpoint;  
  
public class User {  
private int id;  
private String name,email;  
public User() {}  
public User(int id, String name, String email) {  
    super();  
    this.id = id;  
    this.name = name;  
    this.email = email;  
}  
  
public String toString(){  
    return "Id:"+id+" Name:"+name+" Email Id:"+email;  
}  
}  


applicationContext.xml
The key-ref and value-ref attributes of entry element is used to define the reference of bean in the map.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="answer1" class="com.javatpoint.Answer">  
<constructor-arg value="1"></constructor-arg>  
<constructor-arg value="Java is a Programming Language"></constructor-arg>  
<constructor-arg value="12/12/2001"></constructor-arg>  
</bean>  
<bean id="answer2" class="com.javatpoint.Answer">  
<constructor-arg value="2"></constructor-arg>  
<constructor-arg value="Java is a Platform"></constructor-arg>  
<constructor-arg value="12/12/2003"></constructor-arg>  
</bean>  
  
<bean id="user1" class="com.javatpoint.User">  
<constructor-arg value="1"></constructor-arg>  
<constructor-arg value="Arun Kumar"></constructor-arg>  
<constructor-arg value="arun@gmail.com"></constructor-arg>  
</bean>  
<bean id="user2" class="com.javatpoint.User">  
<constructor-arg value="2"></constructor-arg>  
<constructor-arg value="Varun Kumar"></constructor-arg>  
<constructor-arg value="Varun@gmail.com"></constructor-arg>  
</bean>  
  
<bean id="q" class="com.javatpoint.Question">  
<constructor-arg value="1"></constructor-arg>  
<constructor-arg value="What is Java?"></constructor-arg>  
<constructor-arg>  
<map>  
<entry key-ref="answer1" value-ref="user1"></entry>  
<entry key-ref="answer2" value-ref="user2"></entry>  
</map>  
</constructor-arg>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo() method to display the information.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Question q=(Question)factory.getBean("q");  
    q.displayInfo();  
      
}  
}  


Dependency Injection by setter method

We can inject the dependency by setter method also. The <property> subelement of <bean> is used for setter injection. Here we are going to inject

Let's see the simple example to inject primitive and string-based values by setter method. We have created three files here:

Employee.java
applicationContext.xml
Test.java


Employee.java
It is a simple class containing three fields id, name and city with its setters and getters and a method to display these informations.

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private String city;  
  
public int getId() {  
    return id;  
}  
public void setId(int id) {  
    this.id = id;  
}  
public String getName() {  
    return name;  
}  
public void setName(String name) {  
    this.name = name;  
}  
  
public String getCity() {  
    return city;  
}  
public void setCity(String city) {  
    this.city = city;  
}  
void display(){  
    System.out.println(id+" "+name+" "+city);  
}  
  
}  


applicationContext.xml
We are providing the information into the bean by this file. The property element invokes the setter method. The value subelement of property will assign the specified value.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
                http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="obj" class="com.javatpoint.Employee">  
<property name="id">  
<value>20</value>  
</property>  
<property name="name">  
<value>Arun</value>  
</property>  
<property name="city">  
<value>ghaziabad</value>  
</property>  
  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the display method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.*;  
  
public class Test {  
    public static void main(String[] args) {  
          
        Resource r=new ClassPathResource("applicationContext.xml");  
        BeanFactory factory=new XmlBeanFactory(r);  
          
        Employee e=(Employee)factory.getBean("obj");  
        s.display();  
          
    }  
}  


Setter Injection with Dependent Object Example

Like Constructor Injection, we can inject the dependency of another bean using setters. In such case, we use property element. Here, our scenario is Employee HAS-A Address. The 
Address class object will be termed as the dependent object. Let's see the Address class first:


Address.java
This class contains four properties, setters and getters and toString() method.

package com.javatpoint;  
  
public class Address {  
private String addressLine1,city,state,country;  
  
//getters and setters  
  
public String toString(){  
    return addressLine1+" "+city+" "+state+" "+country;  
}  


Employee.java
It contains three properties id, name and address(dependent object) , setters and getters with displayInfo() method.

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private Address address;  
  
//setters and getters  
  
void displayInfo(){  
    System.out.println(id+" "+name);  
    System.out.println(address);  
}  
}  


applicationContext.xml
The ref attribute of property elements is used to define the reference of another bean.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="address1" class="com.javatpoint.Address">  
<property name="addressLine1" value="51,Lohianagar"></property>  
<property name="city" value="Ghaziabad"></property>  
<property name="state" value="UP"></property>  
<property name="country" value="India"></property>  
</bean>  
  
<bean id="obj" class="com.javatpoint.Employee">  
<property name="id" value="1"></property>  
<property name="name" value="Sachin Yadav"></property>  
<property name="address" ref="address1"></property>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo() method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Employee e=(Employee)factory.getBean("obj");  
    e.displayInfo();  
      
}  
} 


Setter Injection with Collection Example

Setter Injection with Collection
We can inject collection values by setter method in spring framework. There can be used three elements inside the property element.

It can be:
list
set
map

Each collection can have string based and non-string based values. In this example, we are taking the example of Forum where One question can have multiple answers. There are three
pages:

Question.java
applicationContext.xml
Test.java

In this example, we are using list that can have duplicate elements, you may use set that have only unique elements. But, you need to change list to set in the applicationContext.xml 
file and List to Set in the Question.java file.


Question.java
This class contains three properties with setters and getters and displayInfo() method that prints the information. Here, we are using List to contain the multiple answers.

package com.javatpoint;  
import java.util.Iterator;  
import java.util.List;  
  
public class Question {  
private int id;  
private String name;  
private List<String> answers;  
  
//setters and getters  
  
public void displayInfo(){  
    System.out.println(id+" "+name);  
    System.out.println("answers are:");  
    Iterator<String> itr=answers.iterator();  
    while(itr.hasNext()){  
        System.out.println(itr.next());  
    }  
}  
  
}  


applicationContext.xml
The list element of constructor-arg is used here to define the list.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="q" class="com.javatpoint.Question">  
<property name="id" value="1"></property>  
<property name="name" value="What is Java?"></property>  
<property name="answers">  
<list>  
<value>Java is a programming language</value>  
<value>Java is a platform</value>  
<value>Java is an Island</value>  
</list>  
</property>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Question q=(Question)factory.getBean("q");  
    q.displayInfo();  
      
}  
} 


Setter Injection with Non-String Collection (having Dependent Object) Example

If we have dependent object in the collection, we can inject these information by using the ref element inside the list, set or map. Here, we will use list, set or map element inside
the property element.

In this example, we are taking the example of Forum where One question can have multiple answers. But Answer has its own information such as answerId, answer and postedBy. There are four pages used in this example:

Question.java
Answer.java
applicationContext.xml
Test.java

In this example, we are using list that can have duplicate elements, you may use set that have only unique elements. But, you need to change list to set in the applicationContext.xml 
file and List to Set in the Question.java file.


Question.java
This class contains three properties, two constructors and displayInfo() method that prints the information. Here, we are using List to contain the multiple answers.

package com.javatpoint;  
  
import java.util.Iterator;  
import java.util.List;  
  
public class Question {  
private int id;  
private String name;  
private List<Answer> answers;  
  
//setters and getters  
  
public void displayInfo(){  
    System.out.println(id+" "+name);  
    System.out.println("answers are:");  
    Iterator<Answer> itr=answers.iterator();  
    while(itr.hasNext()){  
        System.out.println(itr.next());  
    }  
}  
  
}  


Answer.java
This class has three properties id, name and by with constructor and toString() method.

package com.javatpoint;  
  
public class Answer {  
private int id;  
private String name;  
private String by;  
  
//setters and getters  
  
public String toString(){  
    return id+" "+name+" "+by;  
}  
}  


applicationContext.xml
The ref element is used to define the reference of another bean. Here, we are using bean attribute of ref element to specify the reference of another bean.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="answer1" class="com.javatpoint.Answer">  
<property name="id" value="1"></property>  
<property name="name" value="Java is a programming language"></property>  
<property name="by" value="Ravi Malik"></property>  
</bean>  
<bean id="answer2" class="com.javatpoint.Answer">  
<property name="id" value="2"></property>  
<property name="name" value="Java is a platform"></property>  
<property name="by" value="Sachin"></property>  
</bean>  
  
<bean id="q" class="com.javatpoint.Question">  
<property name="id" value="1"></property>  
<property name="name" value="What is Java?"></property>  
<property name="answers">  
<list>  
<ref bean="answer1"/>  
<ref bean="answer2"/>  
</list>  
</property>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Question q=(Question)factory.getBean("q");  
    q.displayInfo();  
      
}  
}  


Setter Injection with Map Example

In this example, we are using map as the answer for a question that have answer as the key and username as the value. Here, we are using key and value pair both as a string.

Like previous examples, it is the example of forum where one question can have multiple answers.


Question.java
This class contains three properties, getters & setters and displayInfo() method to display the information.

package com.javatpoint;  
import java.util.Iterator;  
import java.util.Map;  
import java.util.Set;  
import java.util.Map.Entry;  
  
public class Question {  
private int id;  
private String name;  
private Map<String,String> answers;  
  
//getters and setters  
  
public void displayInfo(){  
    System.out.println("question id:"+id);  
    System.out.println("question name:"+name);  
    System.out.println("Answers....");  
    Set<Entry<String, String>> set=answers.entrySet();  
    Iterator<Entry<String, String>> itr=set.iterator();  
    while(itr.hasNext()){  
        Entry<String,String> entry=itr.next();  
        System.out.println("Answer:"+entry.getKey()+" Posted By:"+entry.getValue());  
    }  
}  
}  


applicationContext.xml
The entry attribute of map is used to define the key and value information.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="q" class="com.javatpoint.Question">  
<property name="id" value="1"></property>  
<property name="name" value="What is Java?"></property>  
<property name="answers">  
<map>  
<entry key="Java is a programming language"  value="Sonoo Jaiswal"></entry>  
<entry key="Java is a Platform" value="Sachin Yadav"></entry>  
</map>  
</property>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo() method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Question q=(Question)factory.getBean("q");  
    q.displayInfo();  
      
}  
}  

Setter Injection with Non-String Map (having dependent Object) Example

In this example, we are using map as the answer that have Answer and User. Here, we are using key and value pair both as an object. Answer has its own information such as answerId, 
answer and postedDate, User has its own information such as userId, username, emailId.

Like previous examples, it is the example of forum where one question can have multiple answers.

Question.java
This class contains three properties, getters & setters and displayInfo() method to display the information.

package com.javatpoint;  
import java.util.Iterator;  
import java.util.Map;  
import java.util.Set;  
import java.util.Map.Entry;  
  
public class Question {  
private int id;  
private String name;  
private Map<Answer,User> answers;  
  
//getters and setters  
  
  
public void displayInfo(){  
    System.out.println("question id:"+id);  
    System.out.println("question name:"+name);  
    System.out.println("Answers....");  
    Set<Entry<Answer, User>> set=answers.entrySet();  
    Iterator<Entry<Answer, User>> itr=set.iterator();  
    while(itr.hasNext()){  
        Entry<Answer, User> entry=itr.next();  
        Answer ans=entry.getKey();  
        User user=entry.getValue();  
        System.out.println("Answer Information:");  
        System.out.println(ans);  
        System.out.println("Posted By:");  
        System.out.println(user);  
    }  
}  
}  


Answer.java
package com.javatpoint;  
  
import java.util.Date;  
  
public class Answer {  
private int id;  
private String answer;  
private Date postedDate;  
public Answer() {}  
public Answer(int id, String answer, Date postedDate) {  
    super();  
    this.id = id;  
    this.answer = answer;  
    this.postedDate = postedDate;  
}  
  
public String toString(){  
    return "Id:"+id+" Answer:"+answer+" Posted Date:"+postedDate;  
}  
}  


User.java
package com.javatpoint;  
  
public class User {  
private int id;  
private String name,email;  
public User() {}  
public User(int id, String name, String email) {  
    super();  
    this.id = id;  
    this.name = name;  
    this.email = email;  
}  
  
public String toString(){  
    return "Id:"+id+" Name:"+name+" Email Id:"+email;  
}  
}  


applicationContext.xml
The key-ref and value-ref attributes of entry element is used to define the reference of bean in the map.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="answer1" class="com.javatpoint.Answer">  
<property name="id" value="1"></property>  
<property name="answer" value="Java is a Programming Language"></property>  
<property name="postedDate" value="12/12/2001"></property>  
</bean>  
<bean id="answer2" class="com.javatpoint.Answer">  
<property name="id" value="2"></property>  
<property name="answer" value="Java is a Platform"></property>  
<property name="postedDate" value="12/12/2003"></property>  
</bean>  
  
<bean id="user1" class="com.javatpoint.User">  
<property name="id" value="1"></property>  
<property name="name" value="Arun Kumar"></property>  
<property name="email" value="arun@gmail.com"></property>  
</bean>  
<bean id="user2" class="com.javatpoint.User">  
<property name="id" value="2"></property>  
<property name="name" value="Varun Kumar"></property>  
<property name="email" value="Varun@gmail.com"></property>  
</bean>  
  
<bean id="q" class="com.javatpoint.Question">  
<property name="id" value="1"></property>  
<property name="name" value="What is Java?"></property>  
<property name="answers">  
<map>  
<entry key-ref="answer1" value-ref="user1"></entry>  
<entry key-ref="answer2" value-ref="user2"></entry>  
</map>  
</property>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo() method to display the information.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Question q=(Question)factory.getBean("q");  
    q.displayInfo();  
      
}  
}  


7) What is the difference between constructor injection and setter injection?

No.	Constructor Injection	Setter Injection
1)	No Partial Injection	Partial Injection
2)	Desn't override the setter property	Overrides the constructor property if both are defined.
3)	Creates new instance if any modification occurs	Doesn't create new instance if you change the property value
4)	Better for too many properties	Better for few properties.

8 : What are the transaction management supports provided by spring?

Spring framework provides two type of transaction management supports:

Programmatic Transaction Management: should be used for few transaction operations.
Declarative Transaction Management: should be used for many transaction operations.

9 : Autowiring from SpringFrameworkInfo text file.

10 : Spring JdbcTemplate

Spring JdbcTemplate is a powerful mechanism to connect to the database and execute SQL queries. It internally uses JDBC api, but eliminates a lot of problems of JDBC API.

The problems of JDBC API are as follows:
We need to write a lot of code before and after executing the query, such as creating connection, statement, closing resultset, connection etc.
We need to perform exception handling code on the database logic.
We need to handle transaction.
Repetition of all these codes from one to another database logic is a time consuming task.

Advantage of Spring JdbcTemplate
Spring JdbcTemplate eliminates all the above mentioned problems of JDBC API. It provides you methods to write the queries directly, so it saves a lot of work and time.

 
Spring Jdbc Approaches
Spring framework provides following approaches for JDBC database access:
JdbcTemplate
NamedParameterJdbcTemplate
SimpleJdbcTemplate
SimpleJdbcInsert and SimpleJdbcCall
JdbcTemplate class

It is the central class in the Spring JDBC support classes. It takes care of creation and release of resources such as creating and closing of connection object etc. So it will not 
lead to any problem if you forget to close the connection. It handles the exception and provides the informative exception messages by the help of excepion classes defined in the 
org.springframework.dao package. We can perform all the database operations by the help of JdbcTemplate class such as insertion, updation, deletion and retrieval of the data from the 
database.

Let's see the methods of spring JdbcTemplate class.
No.	Method	Description
1)	public int update(String query)	is used to insert, update and delete records.
2)	public int update(String query,Object... args)	is used to insert, update and delete records using PreparedStatement using given arguments.
3)	public void execute(String query)	is used to execute DDL query.
4)	public T execute(String sql, PreparedStatementCallback action)	executes the query by using PreparedStatement callback.
5)	public T query(String sql, ResultSetExtractor rse)	is used to fetch records using ResultSetExtractor.
6)	public List query(String sql, RowMapper rse)	is used to fetch records using RowMapper.


Example of Spring JdbcTemplate

We are assuming that you have created the following table inside the Oracle10g database.

create table employee(  
id number(10),  
name varchar2(100),  
salary number(10)  
);  


Employee.java
This class contains 3 properties with constructors and setter and getters.

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private float salary;  
//no-arg and parameterized constructors  
//getters and setters  
}  


EmployeeDao.java
It contains one property jdbcTemplate and three methods saveEmployee(), updateEmployee and deleteEmployee().

package com.javatpoint;  
import org.springframework.jdbc.core.JdbcTemplate;  
  
public class EmployeeDao {  
private JdbcTemplate jdbcTemplate;  
  
public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {  
    this.jdbcTemplate = jdbcTemplate;  
}  
  
public int saveEmployee(Employee e){  
    String query="insert into employee values(  
    '"+e.getId()+"','"+e.getName()+"','"+e.getSalary()+"')";  
    return jdbcTemplate.update(query);  
}  
public int updateEmployee(Employee e){  
    String query="update employee set   
    name='"+e.getName()+"',salary='"+e.getSalary()+"' where id='"+e.getId()+"' ";  
    return jdbcTemplate.update(query);  
}  
public int deleteEmployee(Employee e){  
    String query="delete from employee where id='"+e.getId()+"' ";  
    return jdbcTemplate.update(query);  
}  
  
}  


applicationContext.xml
The DriverManagerDataSource is used to contain the information about the database such as driver class name, connnection URL, username and password. There are a property named 
datasource in the JdbcTemplate class of DriverManagerDataSource type. So, we need to provide the reference of DriverManagerDataSource object in the JdbcTemplate class for the
datasource property. Here, we are using the JdbcTemplate object in the EmployeeDao class, so we are passing it by the setter method but you can use constructor also.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">  
<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />  
<property name="url" value="jdbc:oracle:thin:@localhost:1521:xe" />  
<property name="username" value="system" />  
<property name="password" value="oracle" />  
</bean>  
  
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">  
<property name="dataSource" ref="ds"></property>  
</bean>  
  
<bean id="edao" class="com.javatpoint.EmployeeDao">  
<property name="jdbcTemplate" ref="jdbcTemplate"></property>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the saveEmployee() method. You can also call updateEmployee() and deleteEmployee() method by uncommenting the 
code as well.

package com.javatpoint;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test {  
  
public static void main(String[] args) {  
    ApplicationContext ctx=new ClassPathXmlApplicationContext("applicationContext.xml");  
      
    EmployeeDao dao=(EmployeeDao)ctx.getBean("edao");  
    int status=dao.saveEmployee(new Employee(102,"Amit",35000));  
    System.out.println(status);  
          
    /*int status=dao.updateEmployee(new Employee(102,"Sonoo",15000)); 
    System.out.println(status); 
    */  
          
    /*Employee e=new Employee(); 
    e.setId(102); 
    int status=dao.deleteEmployee(e); 
    System.out.println(status);*/  
      
}  
  
}  

11 : Example of PreparedStatement in Spring JdbcTemplate

We can execute parameterized query using Spring JdbcTemplate by the help of execute() method of JdbcTemplate class. To use parameterized query, we pass the instance of 
PreparedStatementCallback in the execute method.

Syntax of execute method to use parameterized query
public T execute(String sql,PreparedStatementCallback<T>);  
PreparedStatementCallback interface

It processes the input parameters and output results. In such case, you don't need to care about single and double quotes.Method of PreparedStatementCallback interface. It has only 
one method doInPreparedStatement. Syntax of the method is given below:
public T doInPreparedStatement(PreparedStatement ps)throws SQLException, DataAccessException  
Example of using PreparedStatement in Spring

We are assuming that you have created the following table inside the Oracle10g database.

create table employee(  
id number(10),  
name varchar2(100),  
salary number(10)  
);  


Employee.java
This class contains 3 properties with constructors and setter and getters.

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private float salary;  
//no-arg and parameterized constructors  
//getters and setters  
}  


EmployeeDao.java
It contains one property jdbcTemplate and one method saveEmployeeByPreparedStatement. You must understand the concept of annonymous class to understand the code of the method.

package com.javatpoint;  
import java.sql.PreparedStatement;  
import java.sql.SQLException;  
  
import org.springframework.dao.DataAccessException;  
import org.springframework.jdbc.core.JdbcTemplate;  
import org.springframework.jdbc.core.PreparedStatementCallback;  
  
public class EmployeeDao {  
private JdbcTemplate jdbcTemplate;  
  
public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {  
    this.jdbcTemplate = jdbcTemplate;  
}  
  
public Boolean saveEmployeeByPreparedStatement(final Employee e){  
    String query="insert into employee values(?,?,?)";  
    return jdbcTemplate.execute(query,new PreparedStatementCallback<Boolean>(){  
    @Override  
    public Boolean doInPreparedStatement(PreparedStatement ps)  
            throws SQLException, DataAccessException {  
              
        ps.setInt(1,e.getId());  
        ps.setString(2,e.getName());  
        ps.setFloat(3,e.getSalary());  
              
        return ps.execute();  
              
    }  
    });  
}  
  
  
}  


applicationContext.xml
The DriverManagerDataSource is used to contain the information about the database such as driver class name, connnection URL, username and password. There are a property named 
datasource in the JdbcTemplate class of DriverManagerDataSource type. So, we need to provide the reference of DriverManagerDataSource object in the JdbcTemplate class for the 
datasource property. Here, we are using the JdbcTemplate object in the EmployeeDao class, so we are passing it by the setter method but you can use constructor also.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">  
<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />  
<property name="url" value="jdbc:oracle:thin:@localhost:1521:xe" />  
<property name="username" value="system" />  
<property name="password" value="oracle" />  
</bean>  
  
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">  
<property name="dataSource" ref="ds"></property>  
</bean>  
  
<bean id="edao" class="com.javatpoint.EmployeeDao">  
<property name="jdbcTemplate" ref="jdbcTemplate"></property>  
</bean>  
  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the saveEmployeeByPreparedStatement() method.

package com.javatpoint;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test {  
  
public static void main(String[] args) {  
    ApplicationContext ctx=new ClassPathXmlApplicationContext("applicationContext.xml");  
          
    EmployeeDao dao=(EmployeeDao)ctx.getBean("edao");  
    dao.saveEmployeeByPreparedStatement(new Employee(108,"Amit",35000));  
}  
}  


12 : ResultSetExtractor Example | Fetching Records by Spring JdbcTemplate

We can easily fetch the records from the database using query() method of JdbcTemplate class where we need to pass the instance of ResultSetExtractor. ResultSetExtractor interface can
be used to fetch records from the database. It accepts a ResultSet and returns the list.


Syntax of query method using ResultSetExtractor
public T query(String sql,ResultSetExtractor<T> rse)  
ResultSetExtractor Interface


Method of ResultSetExtractor interface
It defines only one method extractData that accepts ResultSet instance as a parameter. Syntax of the method is given below:
public T extractData(ResultSet rs)throws SQLException,DataAccessException  
Example of ResultSetExtractor Interface to show all the records of the table


We are assuming that you have created the following table inside the Oracle10g database.
create table employee(  
id number(10),  
name varchar2(100),  
salary number(10)  
);  


Employee.java
This class contains 3 properties with constructors and setter and getters. It defines one extra method toString().

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private float salary;  
//no-arg and parameterized constructors  
//getters and setters  
  
public String toString(){  
    return id+" "+name+" "+salary;  
}  
}  


EmployeeDao.java
It contains on property jdbcTemplate and one method getAllEmployees.

package com.javatpoint;  
import java.sql.ResultSet;  
import java.sql.SQLException;  
import java.util.ArrayList;  
import java.util.List;  
import org.springframework.dao.DataAccessException;  
import org.springframework.jdbc.core.JdbcTemplate;  
import org.springframework.jdbc.core.ResultSetExtractor;  
  
public class EmployeeDao {  
private JdbcTemplate template;  
  
public void setTemplate(JdbcTemplate template) {  
    this.template = template;  
}  
  
public List<Employee> getAllEmployees(){  
 return template.query("select * from employee",new ResultSetExtractor<List<Employee>>(){  
    @Override  
     public List<Employee> extractData(ResultSet rs) throws SQLException,  
            DataAccessException {  
      
        List<Employee> list=new ArrayList<Employee>();  
        while(rs.next()){  
        Employee e=new Employee();  
        e.setId(rs.getInt(1));  
        e.setName(rs.getString(2));  
        e.setSalary(rs.getInt(3));  
        list.add(e);  
        }  
        return list;  
        }  
    });  
  }  
}  


applicationContext.xml
The DriverManagerDataSource is used to contain the information about the database such as driver class name, connnection URL, username and password. There are a property named 
datasource in the JdbcTemplate class of DriverManagerDataSource type. So, we need to provide the reference of DriverManagerDataSource object in the JdbcTemplate class for the 
datasource property. Here, we are using the JdbcTemplate object in the EmployeeDao class, so we are passing it by the setter method but you can use constructor also.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">  
<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />  
<property name="url" value="jdbc:oracle:thin:@localhost:1521:xe" />  
<property name="username" value="system" />  
<property name="password" value="oracle" />  
</bean>  
  
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">  
<property name="dataSource" ref="ds"></property>  
</bean>  
  
<bean id="edao" class="com.javatpoint.EmployeeDao">  
<property name="jdbcTemplate" ref="jdbcTemplate"></property>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the getAllEmployees() method of EmployeeDao class.

package com.javatpoint;  
  
import java.util.List;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test {  
  
public static void main(String[] args) {  
    ApplicationContext ctx=new ClassPathXmlApplicationContext("applicationContext.xml");  
    EmployeeDao dao=(EmployeeDao)ctx.getBean("edao");  
    List<Employee> list=dao.getAllEmployees();  
          
    for(Employee e:list)  
        System.out.println(e);  
          
    }  
  
}  

13 : RowMapper Example | Fetching records by Spring JdbcTemplate

Like ResultSetExtractor, we can use RowMapper interface to fetch the records from the database using query() method of JdbcTemplate class. In the execute of we need to pass the 
instance of RowMapper now.


Syntax of query method using RowMapper
public T query(String sql,RowMapper<T> rm)  
RowMapper Interface


RowMapper interface allows to map a row of the relations with the instance of user-defined class. It iterates the ResultSet internally and adds it into the collection. So we don't 
need to write a lot of code to fetch the records as ResultSetExtractor.


Advantage of RowMapper over ResultSetExtractor
RowMapper saves a lot of code becuase it internally adds the data of ResultSet into the collection.


Method of RowMapper interface
It defines only one method mapRow that accepts ResultSet instance and int as the parameter list. Syntax of the method is given below:
public T mapRow(ResultSet rs, int rowNumber)throws SQLException  


Example of RowMapper Interface to show all the records of the table

We are assuming that you have created the following table inside the Oracle10g database.

create table employee(  
id number(10),  
name varchar2(100),  
salary number(10)  
);  


Employee.java
This class contains 3 properties with constructors and setter and getters and one extra method toString().

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private float salary;  
//no-arg and parameterized constructors  
//getters and setters  
public String toString(){  
    return id+" "+name+" "+salary;  
}  
}  


EmployeeDao.java
It contains on property jdbcTemplate and one method getAllEmployeesRowMapper.

package com.javatpoint;  
import java.sql.ResultSet;  
import java.sql.SQLException;  
import java.util.ArrayList;  
import java.util.List;  
import org.springframework.dao.DataAccessException;  
import org.springframework.jdbc.core.JdbcTemplate;  
import org.springframework.jdbc.core.ResultSetExtractor;  
import org.springframework.jdbc.core.RowMapper;  
  
public class EmployeeDao {  
private JdbcTemplate template;  
  
public void setTemplate(JdbcTemplate template) {  
    this.template = template;  
}  
  
public List<Employee> getAllEmployeesRowMapper(){  
 return template.query("select * from employee",new RowMapper<Employee>(){  
    @Override  
    public Employee mapRow(ResultSet rs, int rownumber) throws SQLException {  
        Employee e=new Employee();  
        e.setId(rs.getInt(1));  
        e.setName(rs.getString(2));  
        e.setSalary(rs.getInt(3));  
        return e;  
    }  
    });  
}  
}  


applicationContext.xml
The DriverManagerDataSource is used to contain the information about the database such as driver class name, connnection URL, username and password. There are a property named 
datasource in the JdbcTemplate class of DriverManagerDataSource type. So, we need to provide the reference of DriverManagerDataSource object in the JdbcTemplate class for the
datasource property. Here, we are using the JdbcTemplate object in the EmployeeDao class, so we are passing it by the setter method but you can use constructor also.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">  
<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />  
<property name="url" value="jdbc:oracle:thin:@localhost:1521:xe" />  
<property name="username" value="system" />  
<property name="password" value="oracle" />  
</bean>  
  
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">  
<property name="dataSource" ref="ds"></property>  
</bean>  
  
<bean id="edao" class="com.javatpoint.EmployeeDao">  
<property name="jdbcTemplate" ref="jdbcTemplate"></property>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the getAllEmployeesRowMapper() method of EmployeeDao class.

package com.javatpoint;  
  
import java.util.List;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test {  
public static void main(String[] args) {  
    ApplicationContext ctx=new ClassPathXmlApplicationContext("applicationContext.xml");  
    EmployeeDao dao=(EmployeeDao)ctx.getBean("edao");  
    List<Employee> list=dao.getAllEmployeesRowMapper();  
          
    for(Employee e:list)  
        System.out.println(e);  
}  
}


14 : Spring NamedParameterJdbcTemplate Example

Spring provides another way to insert data by named parameter. In such way, we use names instead of ?(question mark). So it is better to remember the data for the column.


Simple example of named parameter query
insert into employee values (:id,:name,:salary)  


Method of NamedParameterJdbcTemplate class
In this example,we are going to call only the execute method of NamedParameterJdbcTemplate class. Syntax of the method is as follows:
pubic T execute(String sql,Map map,PreparedStatementCallback psc)  


Example of NamedParameterJdbcTemplate class

We are assuming that you have created the following table inside the Oracle10g database.

create table employee(  
id number(10),  
name varchar2(100),  
salary number(10)  
);  


Employee.java
This class contains 3 properties with constructors and setter and getters.

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private float salary;  
//no-arg and parameterized constructors  
//getters and setters  
}  


EmployeeDao.java
It contains on property jdbcTemplate and one method save.

package com.javatpoint;  
  
import java.sql.PreparedStatement;  
import java.sql.SQLException;  
import org.springframework.dao.DataAccessException;  
import org.springframework.jdbc.core.PreparedStatementCallback;  
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;  
import java.util.*;  
  
public class EmpDao {  
NamedParameterJdbcTemplate template;  
  
public EmpDao(NamedParameterJdbcTemplate template) {  
        this.template = template;  
}  
public  void save (Emp e){  
String query="insert into employee values (:id,:name,:salary)";  
  
Map<String,Object> map=new HashMap<String,Object>();  
map.put("id",e.getId());  
map.put("name",e.getName());  
map.put("salary",e.getSalary());  
  
template.execute(query,map,new PreparedStatementCallback() {  
    @Override  
    public Object doInPreparedStatement(PreparedStatement ps)  
            throws SQLException, DataAccessException {  
        return ps.executeUpdate();  
    }  
});  
}  
}  


applicationContext.xml
The DriverManagerDataSource is used to contain the information about the database such as driver class name, connnection URL, username and password. There are a property named 
datasource in the NamedParameterJdbcTemplate class of DriverManagerDataSource type. So, we need to provide the reference of DriverManagerDataSource object in the
NamedParameterJdbcTemplate class for the datasource property. Here, we are using the NamedParameterJdbcTemplate object in the EmployeeDao class, so we are passing it by the 
constructor but you can use setter method also.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">  
<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />  
<property name="url" value="jdbc:oracle:thin:@localhost:1521:xe" />  
<property name="username" value="system" />  
<property name="password" value="oracle" />  
</bean>  
  
<bean id="jtemplate"   
 class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate">  
<constructor-arg ref="ds"></constructor-arg>  
</bean>  
  
<bean id="edao" class="com.javatpoint.EmpDao">  
<constructor-arg>  
<ref bean="jtemplate"/>  
</constructor-arg>  
</bean>  
  
</beans>  


SimpleTest.java
This class gets the bean from the applicationContext.xml file and calls the save method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class SimpleTest {  
  public static void main(String[] args) {  
      
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    EmpDao dao=(EmpDao)factory.getBean("edao");  
    dao.save(new Emp(23,"sonoo",50000));  
      
  }  
}  


15 : Spring SimpleJdbcTemplate Example

Spring 3 JDBC supports the java 5 feature var-args (variable argument) and autoboxing by the help of SimpleJdbcTemplate class. SimpleJdbcTemplate class wraps the JdbcTemplate class
and provides the update method where we can pass arbitrary number of arguments.


Syntax of update method of SimpleJdbcTemplate class
int update(String sql,Object... parameters)  

We should pass the parameter values in the update method in the order they are defined in the parameterized query.


Example of SimpleJdbcTemplate class

We are assuming that you have created the following table inside the Oracle10g database.

create table employee(  
id number(10),  
name varchar2(100),  
salary number(10)  
);  


Employee.java
This class contains 3 properties with constructors and setter and getters.

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private float salary;  
//no-arg and parameterized constructors  
//getters and setters  
}  


EmployeeDao.java
It contains one property SimpleJdbcTemplate and one method update. In such case, update method will update only name for the corresponding id. If you want to update the name and 
salary both, comment the above two lines of code of the update method and uncomment the 2 lines of code given below.

package com.javatpoint;  
  
import org.springframework.jdbc.core.simple.SimpleJdbcTemplate;  
public class EmpDao {  
SimpleJdbcTemplate template;  
  
public EmpDao(SimpleJdbcTemplate template) {  
        this.template = template;  
}  
public int update (Emp e){  
String query="update employee set name=? where id=?";  
return template.update(query,e.getName(),e.getId());  
  
//String query="update employee set name=?,salary=? where id=?";  
//return template.update(query,e.getName(),e.getSalary(),e.getId());  
}  
  
}  


applicationContext.xml
The DriverManagerDataSource is used to contain the information about the database such as driver class name, connnection URL, username and password. There are a property named 
datasource in the SimpleJdbcTemplate class of DriverManagerDataSource type. So, we need to provide the reference of DriverManagerDataSource object in the SimpleJdbcTemplate class for 
the datasource property. Here, we are using the SimpleJdbcTemplate object in the EmployeeDao class, so we are passing it by the constructor but you can use setter method also.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">  
<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />  
<property name="url" value="jdbc:oracle:thin:@localhost:1521:xe" />  
<property name="username" value="system" />  
<property name="password" value="oracle" />  
</bean>  
  
<bean id="jtemplate" class="org.springframework.jdbc.core.simple.SimpleJdbcTemplate">  
<constructor-arg ref="ds"></constructor-arg>  
</bean>  
  
<bean id="edao" class="com.javatpoint.EmpDao">  
<constructor-arg>  
<ref bean="jtemplate"/>  
</constructor-arg>  
</bean>  
  
</beans>  


SimpleTest.java
This class gets the bean from the applicationContext.xml file and calls the update method of EmpDao class.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class SimpleTest {  
public static void main(String[] args) {  
      
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    EmpDao dao=(EmpDao)factory.getBean("edao");  
    int status=dao.update(new Emp(23,"Tarun",35000));  
    System.out.println(status);  
}  
}  

16 : How can you fetch records by spring JdbcTemplate?

You can fetch records from the database by the query method of JdbcTemplate. There are two interfaces to do this:
ResultSetExtractor
RowMapper

17 : What is the advantage of NamedParameterJdbcTemplate?

NamedParameterJdbcTemplate class is used to pass value to the named parameter. A named parameter is better than ? (question mark of PreparedStatement). It is better to remember.

18 : Aspect Oriented Programming (AOP) compliments OOPs in the sense that it also provides modularity. But the key unit of modularity is aspect than class. AOP breaks the program 
logic into distinct parts (called concerns). It is used to increase modularity by cross-cutting concerns. A cross-cutting concern is a concern that can affect the whole application 
and should be centralized in one location in code as possible, such as transaction management, authentication, logging, security etc.

Why use AOP?

It provides the pluggable way to dynamically add the additional concern before, after or around the actual logic. Suppose there are 10 methods in a class as given below:

class A{  
public void m1(){...}  
public void m2(){...}  
public void m3(){...}  
public void m4(){...}  
public void m5(){...}  
public void n1(){...}  
public void n2(){...}  
public void p1(){...}  
public void p2(){...}  
public void p3(){...}  
}  

There are 5 methods that starts from m, 2 methods that starts from n and 3 methods that starts from p. Understanding Scenario I have to maintain log and send notification after 
calling methods that starts from m. Problem without AOP We can call methods (that maintains log and sends notification) from the methods starting with m. In such scenario, we need to 
write the code in all the 5 methods. But, if client says in future, I don't have to send notification, you need to change all the methods. It leads to the maintenance problem. 
Solution with AOP We don't have to call methods from the method. Now we can define the additional concern like maintaining log, sending notification etc. in the method of a class. 
Its entry is given in the xml file.In future, if client says to remove the notifier functionality, we need to change only in the xml file. So, maintenance is easy in AOP.

 
Where use AOP?

AOP is mostly used in following cases:
to provide declarative enterprise services such as declarative transaction management.
It allows users to implement custom aspects.


AOP concepts and terminologies are as follows:

Join point
Advice
Pointcut
Introduction
Target Object
Aspect
Interceptor
AOP Proxy
Weaving

Join point
Join point is any point in your program such as method execution, exception handling, field access etc. Spring supports only method execution join point.

																	or

The join point represents a point in an application where we can plug-in an AOP aspect. It is the actual place in the application where an action will be taken
using Spring AOP framework.

Advice

The advice is the actual action that will be taken either before or after the method execution. This is actual piece of code that is invoked during the 
program execution by the Spring AOP framework.

Advice represents an action taken by an aspect at a particular join point. There are different types of advices:
Before Advice: it executes before a join point.
After Returning Advice: it executes after a joint point completes normally.
After Throwing Advice: it executes if method exits by throwing an exception.
After (finally) Advice: it executes after a join point regardless of join point exit whether normally or exceptional return.
Around Advice: It executes before and after a join point.

Pointcut
It is an expression language of AOP that matches join points.

Introduction
It means introduction of additional method and fields for a type. It allows you to introduce new interface to any advised object.

Target Object
It is the object i.e. being advised by one or more aspects. It is also known as proxied object in spring because Spring AOP is implemented using runtime proxies.

Aspect
It is a class that contains advices, joinpoints etc.

Interceptor
It is an aspect that contains only one advice.

AOP Proxy
It is used to implement aspect contracts, created by AOP framework. It will be a JDK dynamic proxy or CGLIB proxy in spring framework.

Weaving
It is the process of linking aspect with other application types or objects to create an advised object. Weaving can be done at compile time, load time or runtime. Spring AOP performs weaving at runtime.


Pointcut description : 

Spring AOP Example – Pointcut , Advisor

In last Spring AOP advice examples, the entire methods of a class are intercepted automatically. But for most cases, you may just need a way to intercept only one or two methods, 
this is what ‘Pointcut’ come for. It allow you to intercept a method by it’s method name. In addition, a ‘Pointcut’ must be associated with an ‘Advisor’. In Spring AOP, comes with 
three very technical terms – Advices, Pointcut , Advisor, put it in unofficial way…
Advice – Indicate the action to take either before or after the method execution.
Pointcut – Indicate which method should be intercept, by method name or regular expression pattern.
Advisor – Group ‘Advice’ and ‘Pointcut’ into a single unit, and pass it to a proxy factory object.

Review last Spring AOP advice examples again.


File : CustomerService.java
package com.mkyong.customer.services;
public class CustomerService
{
	private String name;
	private String url;

	public void setName(String name) {
		this.name = name;
	}

	public void setUrl(String url) {
		this.url = url;
	}

	public void printName(){
		System.out.println("Customer name : " + this.name);
	}

	public void printURL(){
		System.out.println("Customer website : " + this.url);
	}

	public void printThrowException(){
		throw new IllegalArgumentException();
	}

}


File : Spring-Customer.xml

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="customerService" class="com.mkyong.customer.services.CustomerService">
		<property name="name" value="Yong Mook Kim" />
		<property name="url" value="http://www.mkyong.com" />
	</bean>

	<bean id="hijackAroundMethodBeanAdvice" class="com.mkyong.aop.HijackAroundMethod" />

	<bean id="customerServiceProxy"
                class="org.springframework.aop.framework.ProxyFactoryBean">

		<property name="target" ref="customerService" />

		<property name="interceptorNames">
			<list>
				<value>hijackAroundMethodBeanAdvice</value>
			</list>
		</property>
	</bean>
</beans>


File : HijackAroundMethod.java

package com.mkyong.aop;

import java.util.Arrays;
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class HijackAroundMethod implements MethodInterceptor {
	@Override
	public Object invoke(MethodInvocation methodInvocation) throws Throwable {

		System.out.println("Method name : "
				+ methodInvocation.getMethod().getName());
		System.out.println("Method arguments : "
				+ Arrays.toString(methodInvocation.getArguments()));

		System.out.println("HijackAroundMethod : Before method hijacked!");

		try {
			Object result = methodInvocation.proceed();
			System.out.println("HijackAroundMethod : Before after hijacked!");

			return result;

		} catch (IllegalArgumentException e) {

			System.out.println("HijackAroundMethod : Throw exception hijacked!");
			throw e;
		}
	}
}


Run it
package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.mkyong.customer.services.CustomerService;

public class App {
	public static void main(String[] args) {
		ApplicationContext appContext = new ClassPathXmlApplicationContext(
				new String[] { "Spring-Customer.xml" });

		CustomerService cust = (CustomerService) appContext
				.getBean("customerServiceProxy");

		System.out.println("*************************");
		cust.printName();
		System.out.println("*************************");
		cust.printURL();
		System.out.println("*************************");
		try {
			cust.printThrowException();
		} catch (Exception e) {
		}
	}
}

Output

*************************
Method name : printName
Method arguments : []
HijackAroundMethod : Before method hijacked!
Customer name : Yong Mook Kim
HijackAroundMethod : Before after hijacked!
*************************
Method name : printURL
Method arguments : []
HijackAroundMethod : Before method hijacked!
Customer website : http://www.mkyong.com
HijackAroundMethod : Before after hijacked!
*************************
Method name : printThrowException
Method arguments : []
HijackAroundMethod : Before method hijacked!
HijackAroundMethod : Throw exception hijacked!
The entire methods of customer service class are intercepted. Later, we show you how to use “pointcuts” to intercept only printName() method.


Pointcuts example
You can match the method via following two ways :
Name match
Regular repression match

 
1. Pointcuts – Name match example
Intercept a printName() method via ‘pointcut’ and ‘advisor’. Create a NameMatchMethodPointcut pointcut bean, and put the method name you want to intercept in the ‘mappedName‘ property value.

<bean id="customerPointcut"
        class="org.springframework.aop.support.NameMatchMethodPointcut">
	<property name="mappedName" value="printName" />
</bean>
Create a DefaultPointcutAdvisor advisor bean, and associate both advice and pointcut.

<bean id="customerAdvisor"
	class="org.springframework.aop.support.DefaultPointcutAdvisor">
	<property name="pointcut" ref="customerPointcut" />
	<property name="advice" ref="hijackAroundMethodBeanAdvice" />
</bean>
Replace the proxy’s ‘interceptorNames’ to ‘customerAdvisor’ (it was ‘hijackAroundMethodBeanAdvice’).

<bean id="customerServiceProxy"
	class="org.springframework.aop.framework.ProxyFactoryBean">

	<property name="target" ref="customerService" />

	<property name="interceptorNames">
		<list>
			<value>customerAdvisor</value>
		</list>
	</property>
</bean>
Full bean configuration file

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="customerService" class="com.mkyong.customer.services.CustomerService">
		<property name="name" value="Yong Mook Kim" />
		<property name="url" value="http://www.mkyong.com" />
	</bean>

	<bean id="hijackAroundMethodBeanAdvice" class="com.mkyong.aop.HijackAroundMethod" />

	<bean id="customerServiceProxy"
                class="org.springframework.aop.framework.ProxyFactoryBean">

		<property name="target" ref="customerService" />

		<property name="interceptorNames">
			<list>
				<value>customerAdvisor</value>
			</list>
		</property>
	</bean>

	<bean id="customerPointcut"
                class="org.springframework.aop.support.NameMatchMethodPointcut">
		<property name="mappedName" value="printName" />
	</bean>

	<bean id="customerAdvisor"
                 class="org.springframework.aop.support.DefaultPointcutAdvisor">
		<property name="pointcut" ref="customerPointcut" />
		<property name="advice" ref="hijackAroundMethodBeanAdvice" />
	</bean>

</beans>
Run it again, output

*************************
Method name : printName
Method arguments : []
HijackAroundMethod : Before method hijacked!
Customer name : Yong Mook Kim
HijackAroundMethod : Before after hijacked!
*************************
Customer website : http://www.mkyong.com
*************************

Now, you only intercept the printName() method.


PointcutAdvisor

Spring comes with PointcutAdvisor class to save your work to declare advisor and pointcut into different beans, you can use NameMatchMethodPointcutAdvisor to combine both into a single bean.
<bean id="customerAdvisor"
	class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">

	<property name="mappedName" value="printName" />
	<property name="advice" ref="hijackAroundMethodBeanAdvice" />

</bean>

 
2. Pointcut – Regular expression example
You can also match the method’s name by using regular expression pointcut – RegexpMethodPointcutAdvisor.

<bean id="customerAdvisor"
	class="org.springframework.aop.support.RegexpMethodPointcutAdvisor">
	<property name="patterns">
		<list>
			<value>.*URL.*</value>
		</list>
	</property>

	<property name="advice" ref="hijackAroundMethodBeanAdvice" />
</bean>

Now, it intercepts the method which has words ‘URL’ within the method name. In practice, you can use it to manage DAO layer, where you can declare “.*DAO.*” to intercept all your 
DAO classes to support transaction.

AOP implementations are provided by:

AspectJ
Spring AOP
JBoss AOP


Spring AOP

Spring AOP can be used by 3 ways given below. But the widely used approach is Spring AspectJ Annotation Style. The 3 ways to use spring AOP are given below:

By Spring1.2 Old style (dtd based) (also supported in Spring3)
By AspectJ annotation-style
By Spring XML configuration-style(schema based)


Spring AOP with first approach in order to use Spring AOP : 

(a)

There are given examples of Spring1.2 old style AOP (dtd based) implementation. Though it is supported in spring 3, but it is recommended to use spring aop with aspectJ that we are 
going to learn in next page. There are 4 types of advices supported in spring1.2 old style aop implementation.

Before Advice it is executed before the actual method call.
After Advice it is executed after the actual method call. If method returns a value, it is executed after returning value.
Around Advice it is executed before and after the actual method call.
Throws Advice it is executed if actual method throws exception.


Let's understand the advice hierarchy by the diagram given below:

All are interfaces in aop.

MethodBeforeAdvice interface extends the BeforeAdvice interface.
AfterReturningAdvice interface extends the AfterAdvice interface.
ThrowsAdvice interface extends the AfterAdvice interface.
MethodInterceptor interface extends the Interceptor interface. It is used in around advice.


 
1) MethodBeforeAdvice Example


Create a class that contains actual business logic.

File: A.java
package com.javatpoint;  
public class A {  
public void m(){System.out.println("actual business logic");}  
}  


Now, create the advisor class that implements MethodBeforeAdvice interface.

File: BeforeAdvisor.java
package com.javatpoint;  
import java.lang.reflect.Method;  
import org.springframework.aop.MethodBeforeAdvice;  
public class BeforeAdvisor implements MethodBeforeAdvice{  
    @Override  
    public void before(Method method, Object[] args, Object target)throws Throwable {  
        System.out.println("additional concern before actual logic");  
    }  
}  


In xml file, create 3 beans, one for A class, second for Advisor class and third for ProxyFactoryBean class.

File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="obj" class="com.javatpoint.A"></bean>  
<bean id="ba" class="com.javatpoint.BeforeAdvisor"></bean>  
  
<bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean">  
<property name="target" ref="obj"></property>  
<property name="interceptorNames">  
<list>  
<value>ba</value>  
</list>  
</property>  
</bean>  
  
</beans>  


Understanding ProxyFactoryBean class:

The ProxyFactoryBean class is provided by Spring Famework. It contains 2 properties target and interceptorNames. The instance of A class will be considered as target object and the
instance of advisor class as interceptor. You need to pass the advisor object as the list object as in the xml file given above.

The ProxyFactoryBean class is written something like this:
public class ProxyFactoryBean{  
private Object target;  
private List interceptorNames;  
//getters and setters  
}  
Now, let's call the actual method.


File: Test.java
package com.javatpoint;  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    A a=factory.getBean("proxy",A.class);  
    a.m();  
}  
}  

Output
additional concern before actual logic  
actual business logic  
Printing additional information in MethodBeforeAdvice


We can print additional information like method name, method argument, target object, target object class name, proxy class etc. You need to change only two classes 
BeforeAdvisor.java and Test.java.


File: BeforeAdvisor.java
package com.javatpoint;  
import java.lang.reflect.Method;  
import org.springframework.aop.MethodBeforeAdvice;  
  
public class BeforeAdvisor implements MethodBeforeAdvice{  
    @Override  
    public void before(Method method, Object[] args, Object target)throws Throwable {  
        System.out.println("additional concern before actual logic");  
        System.out.println("method info:"+method.getName()+" "+method.getModifiers());  
        System.out.println("argument info:");  
        for(Object arg:args)  
            System.out.println(arg);  
        System.out.println("target Object:"+target);  
        System.out.println("target object class name: "+target.getClass().getName());  
    }  
}  


File: Test.java
package com.javatpoint;  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    A a=factory.getBean("proxy",A.class);  
        System.out.println("proxy class name: "+a.getClass().getName());  
    a.m();  
}  
}  

Output
proxy class name: com.javatpoint.A$$EnhancerByCGLIB$$409872b1  
additional concern before actual logic  
method info:m 1  
argument info:  
target Object:com.javatpoint.A@11dba45  
target object class name: com.javatpoint.A  
actual business logic  


2) AfterReturningAdvice Example

Create a class that contains actual business logic.
File: A.java
Same as in the previous example.


Now, create the advisor class that implements AfterReturningAdvice interface.
File: AfterAdvisor.java
package com.javatpoint;  
import java.lang.reflect.Method;  
import org.springframework.aop.AfterReturningAdvice;  
public class AfterAdvisor implements AfterReturningAdvice{  
    @Override  
    public void afterReturning(Object returnValue, Method method,  
         Object[] args, Object target) throws Throwable {  
          
        System.out.println("additional concern after returning advice");  
    }  
  
}  


Create the xml file as in the previous example, you need to change only the advisor class here.
File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="obj" class="com.javatpoint.A"></bean>  
<bean id="ba" class="com.javatpoint.AfterAdvisor"></bean>  
  
<bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean">  
<property name="target" ref="obj"></property>  
<property name="interceptorNames">  
<list>  
<value>ba</value>  
</list>  
</property>  
</bean>  
  
</beans>  


File: Test.java
Same as in the previous example.

Output
actual business logic  
additional concern after returning advice  


3) MethodInterceptor (AroundAdvice) Example


Create a class that contains actual business logic.
File: A.java
Same as in the previous example.


Now, create the advisor class that implements MethodInterceptor interface.
File: AroundAdvisor.java
package com.javatpoint;  
import org.aopalliance.intercept.MethodInterceptor;  
import org.aopalliance.intercept.MethodInvocation;  
public class AroundAdvisor implements MethodInterceptor{  
  
    @Override  
    public Object invoke(MethodInvocation mi) throws Throwable {  
        Object obj;  
        System.out.println("additional concern before actual logic");  
        obj=mi.proceed();  
        System.out.println("additional concern after actual logic");  
        return obj;  
    }  
  
}  


Create the xml file as in the previous example, you need to change only the advisor class here.
File: applicationContext.xml

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="obj" class="com.javatpoint.A"></bean>  
<bean id="ba" class="com.javatpoint.AroundAdvisor"></bean>  
  
<bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean">  
<property name="target" ref="obj"></property>  
<property name="interceptorNames">  
<list>  
<value>ba</value>  
</list>  
</property>  
</bean>  
  
</beans>  


File: Test.java
Same as in the previous example.

Output
additional concern before actual logic  
actual business logic  
additional concern after actual logic  


4) ThrowsAdvice Example

Create a class that contains actual business logic.

File: Validator.java
package com.javatpoint;  
public class Validator {  
    public void validate(int age)throws Exception{  
        if(age<18){  
            throw new ArithmeticException("Not Valid Age");  
        }  
        else{  
            System.out.println("vote confirmed");  
        }  
    }  
}  


Now, create the advisor class that implements ThrowsAdvice interface.

File: ThrowsAdvisor.java
package com.javatpoint;  
import org.springframework.aop.ThrowsAdvice;  
public class ThrowsAdvisor implements ThrowsAdvice{  
    public void afterThrowing(Exception ex){  
        System.out.println("additional concern if exception occurs");  
    }  
}  


Create the xml file as in the previous example, you need to change only the Validator class and advisor class.

File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="obj" class="com.javatpoint.Validator"></bean>  
<bean id="ba" class="com.javatpoint.ThrowsAdvisor"></bean>  
  
<bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean">  
<property name="target" ref="obj"></property>  
<property name="interceptorNames">  
<list>  
<value>ba</value>  
</list>  
</property>  
</bean>  
  
</beans>  


File: Test.java
package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Validator v=factory.getBean("proxy",Validator.class);  
    try{  
    v.validate(12);  
    }catch(Exception e){e.printStackTrace();}  
}  
}  

Output
java.lang.ArithmeticException: Not Valid Age  
  
additional concern if exception occurs  
  
    at com.javatpoint.Validator.validate(Validator.java:7)  
    at com.javatpoint.Validator$$FastClassByCGLIB$$562915cf.invoke(<generated>)  
    at net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:191)  
    at org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invoke  
Joinpoint(Cglib2AopProxy.java:692)  
    at org.springframework.aop.framework.ReflectiveMethodInvocation.  
proceed(ReflectiveMethodInvocation.java:150)  
    at org.springframework.aop.framework.adapter.ThrowsAdviceInterceptor.  
invoke(ThrowsAdviceInterceptor.java:124)  
    at org.springframework.aop.framework.ReflectiveMethodInvocation.  
proceed(ReflectiveMethodInvocation.java:172)  
    at org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.  
intercept(Cglib2AopProxy.java:625)  
    at com.javatpoint.Validator$$EnhancerByCGLIB$$4230ed28.validate(<generated>)  
    at com.javatpoint.Test.main(Test.java:15)  
	
(b)

Spring AOP AspectJ Annotation Example

The Spring Framework recommends you to use Spring AspectJ AOP implementation over the Spring 1.2 old style dtd based AOP implementation because it provides you more control and it is
easy to use.


There are two ways to use Spring AOP AspectJ implementation:
By annotation: We are going to learn it here.
By xml configuration (schema based): We will learn it in next page.
To understand the aop concepts, its advantage etc. visit here AOP Concepts Tutorial

Spring AspectJ AOP implementation provides many annotations:
@Aspect declares the class as aspect.
@Pointcut declares the pointcut expression.

The annotations used to create advices are given below:
@Before declares the before advice. It is applied before calling the actual method.
@After declares the after advice. It is applied after calling the actual method and before returning result.
@AfterReturning declares the after returning advice. It is applied after calling the actual method and before returning result. But you can get the result value in the advice.
@Around declares the around advice. It is applied before and after calling the actual method.
@AfterThrowing declares the throws advice. It is applied if actual method throws exception.

 
(a) : Understanding Pointcut

Pointcut is an expression language of Spring AOP. The @Pointcut annotation is used to define the pointcut. We can refer the pointcut expression by name also. Let's see the simple 
example of pointcut expression.

@Pointcut("execution(* Operation.*(..))")  
private void doSomething() {}  
The name of the pointcut expression is doSomething(). It will be applied on all the methods of Operation class regardless of return type.

(b) : Understanding Pointcut Expressions

Let's try the understand the pointcut expressions by the examples given below:

@Pointcut("execution(public * *(..))")  
It will be applied on all the public methods.

@Pointcut("execution(public Operation.*(..))")  
It will be applied on all the public methods of Operation class.

@Pointcut("execution(* Operation.*(..))")  
It will be applied on all the methods of Operation class.

@Pointcut("execution(public Employee.set*(..))")  
It will be applied on all the public setter methods of Employee class.

@Pointcut("execution(int Operation.*(..))")  
It will be applied on all the methods of Operation class that returns int value.


1) @Before Example

The AspectJ Before Advice is applied before the actual business logic method. You can perform any operation here such as conversion, authentication etc. Create a class that contains 
actual business logic.

File: Operation.java
package com.javatpoint;  
public  class Operation{  
    public void msg(){System.out.println("msg method invoked");}  
    public int m(){System.out.println("m method invoked");return 2;}  
    public int k(){System.out.println("k method invoked");return 3;}  
}  


Now, create the aspect class that contains before advice.

File: TrackOperation.java
package com.javatpoint;  
  
import org.aspectj.lang.JoinPoint;  
import org.aspectj.lang.annotation.Aspect;  
import org.aspectj.lang.annotation.Before;  
import org.aspectj.lang.annotation.Pointcut;  
  
@Aspect  
public class TrackOperation{  
    @Pointcut("execution(* Operation.*(..))")  
    public void k(){}//pointcut name  
      
    @Before("k()")//applying pointcut on before advice  
    public void myadvice(JoinPoint jp)//it is advice (before advice)  
    {  
        System.out.println("additional concern");  
        //System.out.println("Method Signature: "  + jp.getSignature());  
    }  
}  


Now create the applicationContext.xml file that defines beans.

File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:aop="http://www.springframework.org/schema/aop"   
       xsi:schemaLocation="http://www.springframework.org/schema/beans   
       http://www.springframework.org/schema/beans/spring-beans.xsd   
       http://www.springframework.org/schema/aop   
       http://www.springframework.org/schema/aop/spring-aop.xsd">  
  
  
    <bean id="opBean" class="com.javatpoint.Operation">   </bean>  
    <bean id="trackMyBean" class="com.javatpoint.TrackOperation"></bean>  
      
    <bean class="org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"></bean>  
          
</beans>  


Now, let's call the actual method.

File: Test.java
package com.javatpoint;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test{  
    public static void main(String[] args){  
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");  
        Operation e = (Operation) context.getBean("opBean");  
        System.out.println("calling msg...");  
        e.msg();  
        System.out.println("calling m...");  
        e.m();  
        System.out.println("calling k...");  
        e.k();  
    }  
}  

Output
calling msg...  
additional concern  
msg() method invoked  
calling m...  
additional concern  
m() method invoked  
calling k...  
additional concern  
k() method invoked  

As you can see, additional concern is printed before msg(), m() and k() method is invoked.


Now if you change the pointcut expression as given below:

@Pointcut("execution(* Operation.m*(..))")  
Now additional concern will be applied for the methods starting with m in Operation class. Output will be as this:

calling msg...  
additional concern  
msg() method invoked  
calling m...  
additional concern  
m() method invoked  
calling k...  
k() method invoked  

Now you can see additional concern is not printed before k() method invoked.


2) @After Example

The AspectJ after advice is applied after calling the actual business logic methods. It can be used to maintain log, security, notification etc. Here, We are assuming that 
Operation.java, applicationContext.xml and Test.java files are same as given in @Before example.

Create the aspect class that contains after advice.
File: TrackOperation.java
package com.javatpoint;  
  
import org.aspectj.lang.JoinPoint;  
import org.aspectj.lang.annotation.Aspect;  
import org.aspectj.lang.annotation.After;  
import org.aspectj.lang.annotation.Pointcut;  
  
@Aspect  
public class TrackOperation{  
    @Pointcut("execution(* Operation.*(..))")  
    public void k(){}//pointcut name  
      
    @After("k()")//applying pointcut on after advice  
    public void myadvice(JoinPoint jp)//it is advice (after advice)  
    {  
        System.out.println("additional concern");  
        //System.out.println("Method Signature: "  + jp.getSignature());  
    }  
}  

Output
calling msg...  
msg() method invoked  
additional concern  
calling m...  
m() method invoked  
additional concern  
calling k...  
k() method invoked  
additional concern  

You can see that additional concern is printed after calling msg(), m() and k() methods.


3) @AfterReturning Example

By using after returning advice, we can get the result in the advice.Create the class that contains business logic.

File: Operation.java
package com.javatpoint;  
public  class Operation{  
    public int m(){System.out.println("m() method invoked");return 2;}  
    public int k(){System.out.println("k() method invoked");return 3;}  
}  


Create the aspect class that contains after returning advice.

File: TrackOperation.java
package com.javatpoint;  
  
import org.aspectj.lang.JoinPoint;  
import org.aspectj.lang.annotation.AfterReturning;  
import org.aspectj.lang.annotation.Aspect;  
  
@Aspect  
public class TrackOperation{  
    @AfterReturning(  
              pointcut = "execution(* Operation.*(..))",  
              returning= "result")  
                
    public void myadvice(JoinPoint jp,Object result)//it is advice (after returning advice)  
    {  
        System.out.println("additional concern");  
        System.out.println("Method Signature: "  + jp.getSignature());  
        System.out.println("Result in advice: "+result);  
        System.out.println("end of after returning advice...");  
    }  
}  


File: applicationContext.xml
It is same as given in @Before advice example


File: Test.java
Now create the Test class that calls the actual methods.

package com.javatpoint;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test{  
    public static void main(String[] args){  
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");  
        Operation e = (Operation) context.getBean("opBean");  
        System.out.println("calling m...");  
        System.out.println(e.m());  
        System.out.println("calling k...");  
        System.out.println(e.k());  
    }  
}  

Output
calling m...  
m() method invoked  
additional concern  
Method Signature: int com.javatpoint.Operation.m()  
Result in advice: 2  
end of after returning advice...  
2  
calling k...  
k() method invoked  
additional concern  
Method Signature: int com.javatpoint.Operation.k()  
Result in advice: 3  
end of after returning advice...  
3  

You can see that return value is printed two times, one is printed by TrackOperation class and second by Test class.


4) @Around Example

The AspectJ around advice is applied before and after calling the actual business logic methods. Here, we are assuming that applicationContext.xml file is same as given in @Before 
example.

Create a class that contains actual business logic.

File: Operation.java
package com.javatpoint;  
public  class Operation{  
    public void msg(){System.out.println("msg() is invoked");}  
    public void display(){System.out.println("display() is invoked");}  

	}  

	
Create the aspect class that contains around advice. You need to pass the PreceedingJoinPoint reference in the advice method, so that we can proceed the request by calling the
proceed() method.

File: TrackOperation.java
package com.javatpoint;  
import org.aspectj.lang.ProceedingJoinPoint;  
import org.aspectj.lang.annotation.Around;  
import org.aspectj.lang.annotation.Aspect;  
import org.aspectj.lang.annotation.Pointcut;  
  
@Aspect  
public class TrackOperation  
{  
    @Pointcut("execution(* Operation.*(..))")  
    public void abcPointcut(){}  
      
    @Around("abcPointcut()")  
    public Object myadvice(ProceedingJoinPoint pjp) throws Throwable   
    {  
        System.out.println("Additional Concern Before calling actual method");  
        Object obj=pjp.proceed();  
        System.out.println("Additional Concern After calling actual method");  
        return obj;  
    }  
}  


File: Test.java
Now create the Test class that calls the actual methods.

package com.javatpoint;  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test{  
    public static void main(String[] args){  
        ApplicationContext context = new classPathXmlApplicationContext("applicationContext.xml");  
          
        Operation op = (Operation) context.getBean("opBean");  
        op.msg();  
        op.display();  
    }  
}  

Output
Additional Concern Before calling actual method  
msg() is invoked  
Additional Concern After calling actual method  
Additional Concern Before calling actual method  
display() is invoked  
Additional Concern After calling actual method  

You can see that additional concern is printed before and after calling msg() and display methods.


5) @AfterThrowing Example

By using after throwing advice, we can print the exception in the TrackOperation class. Let's see the example of AspectJ AfterThrowing advice. Create the class that contains business
logic.

File: Operation.java
package com.javatpoint;  
public  class Operation{  
    public void validate(int age)throws Exception{  
    if(age<18){  
        throw new ArithmeticException("Not valid age");  
    }  
    else{  
        System.out.println("Thanks for vote");  
    }  
    }  
      
}  


Create the aspect class that contains after throwing advice. Here, we need to pass the Throwable reference also, so that we can intercept the exception here.

File: TrackOperation.java
package com.javatpoint;  
import org.aspectj.lang.JoinPoint;  
import org.aspectj.lang.annotation.AfterThrowing;  
import org.aspectj.lang.annotation.Aspect;  
@Aspect  
public class TrackOperation{  
    @AfterThrowing(  
              pointcut = "execution(* Operation.*(..))",  
              throwing= "error")  
                
    public void myadvice(JoinPoint jp,Throwable error)//it is advice  
    {  
        System.out.println("additional concern");  
        System.out.println("Method Signature: "  + jp.getSignature());  
        System.out.println("Exception is: "+error);  
        System.out.println("end of after throwing advice...");  
    }  
}  


File: applicationContext.xml
It is same as given in @Before advice example


File: Test.java
Now create the Test class that calls the actual methods.

package com.javatpoint;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test{  
    public static void main(String[] args){  
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");  
        Operation op = (Operation) context.getBean("opBean");  
        System.out.println("calling validate...");  
        try{  
            op.validate(19);  
        }catch(Exception e){System.out.println(e);}  
        System.out.println("calling validate again...");  
          
        try{  
            op.validate(11);  
        }catch(Exception e){System.out.println(e);}  
    }  
}  

Output

calling validate...  
Thanks for vote  
calling validate again...  
additional concern  
Method Signature: void com.javatpoint.Operation.validate(int)  
Exception is: java.lang.ArithmeticException: Not valid age  
end of after throwing advice...  
java.lang.ArithmeticException: Not valid age  	


(c)

Spring AOP AspectJ Xml Configuration Example

Spring enables you to define the aspects, advices and pointcuts in xml file. In the previous page, we have seen the aop examples using annotations. Now we are going to see same 
examples by the xml configuration file.

Let's see the xml elements that are used to define advice.

aop:before It is applied before calling the actual business logic method.
aop:after It is applied after calling the actual business logic method.
aop:after-returning it is applied after calling the actual business logic method. It can be used to intercept the return value in advice.
aop:around It is applied before and after calling the actual business logic method.
aop:after-throwing It is applied if actual business logic method throws exception.

 
1) aop:before Example

The AspectJ Before Advice is applied before the actual business logic method. You can perform any operation here such as conversion, authentication etc. Create a class that contains
actual business logic.

File: Operation.java
package com.javatpoint;  
public  class Operation{  
    public void msg(){System.out.println("msg method invoked");}  
    public int m(){System.out.println("m method invoked");return 2;}  
    public int k(){System.out.println("k method invoked");return 3;}  
}  


Now, create the aspect class that contains before advice.

File: TrackOperation.java
package com.javatpoint;  
import org.aspectj.lang.JoinPoint;  
public class TrackOperation{  
    public void myadvice(JoinPoint jp)//it is advice  
    {  
        System.out.println("additional concern");  
        //System.out.println("Method Signature: "  + jp.getSignature());  
    }  
}  


Now create the applicationContext.xml file that defines beans.

File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
    xmlns:aop="http://www.springframework.org/schema/aop"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd   
    http://www.springframework.org/schema/aop   
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd ">  
  
<aop:aspectj-autoproxy />  
  
<bean id="opBean" class="com.javatpoint.Operation">   </bean>  
<bean id="trackAspect" class="com.javatpoint.TrackOperation"></bean>  
          
<aop:config>  
  <aop:aspect id="myaspect" ref="trackAspect" >  
     <!-- @Before -->  
     <aop:pointcut id="pointCutBefore"   expression="execution(* com.javatpoint.Operation.*(..))" />  
     <aop:before method="myadvice" pointcut-ref="pointCutBefore" />  
  </aop:aspect>  
</aop:config>  
      
</beans>  


Now, let's call the actual method.
File: Test.java

package com.javatpoint;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test{  
    public static void main(String[] args){  
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");  
        Operation e = (Operation) context.getBean("opBean");  
        System.out.println("calling msg...");  
        e.msg();  
        System.out.println("calling m...");  
        e.m();  
        System.out.println("calling k...");  
        e.k();  
    }  
}  

Output
calling msg...  
additional concern  
msg() method invoked  
calling m...  
additional concern  
m() method invoked  
calling k...  
additional concern  
k() method invoked  

As you can see, additional concern is printed before msg(), m() and k() method is invoked.


2) aop:after example

The AspectJ after advice is applied after calling the actual business logic methods. It can be used to maintain log, security, notification etc. Here, We are assuming that 
Operation.java, TrackOperation.java and Test.java files are same as given in aop:before example. Now create the applicationContext.xml file that defines beans.

File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
    xmlns:aop="http://www.springframework.org/schema/aop"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd   
    http://www.springframework.org/schema/aop   
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd ">  
  
<aop:aspectj-autoproxy />  
  
<bean id="opBean" class="com.javatpoint.Operation">   </bean>  
<bean id="trackAspect" class="com.javatpoint.TrackOperation"></bean>  
          
<aop:config>  
  <aop:aspect id="myaspect" ref="trackAspect" >  
     <!-- @After -->  
     <aop:pointcut id="pointCutAfter"    expression="execution(* com.javatpoint.Operation.*(..))" />  
     <aop:after method="myadvice" pointcut-ref="pointCutAfter" />  
  </aop:aspect>  
</aop:config>  
      
</beans>  

Output
calling msg...  
msg() method invoked  
additional concern  
calling m...  
m() method invoked  
additional concern  
calling k...  
k() method invoked  
additional concern  

You can see that additional concern is printed after calling msg(), m() and k() methods.


3) aop:after-returning example

By using after returning advice, we can get the result in the advice. Create the class that contains business logic.

File: Operation.java
package com.javatpoint;  
public  class Operation{  
    public int m(){System.out.println("m() method invoked");return 2;}  
    public int k(){System.out.println("k() method invoked");return 3;}  
}  
Create the aspect class that contains after returning advice.

File: TrackOperation.java
package com.javatpoint;  
  
import org.aspectj.lang.JoinPoint;  
  
public class TrackOperation{  
    public void myadvice(JoinPoint jp,Object result)//it is advice (after advice)  
    {  
        System.out.println("additional concern");  
        System.out.println("Method Signature: "  + jp.getSignature());  
        System.out.println("Result in advice: "+result);  
        System.out.println("end of after returning advice...");  
    }  
}  


File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
    xmlns:aop="http://www.springframework.org/schema/aop"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd   
    http://www.springframework.org/schema/aop   
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd ">  
  
<aop:aspectj-autoproxy />  
  
<bean id="opBean" class="com.javatpoint.Operation">   </bean>  
      
<bean id="trackAspect" class="com.javatpoint.TrackOperation"></bean>  
          
<aop:config>  
  <aop:aspect id="myaspect" ref="trackAspect" >  
     <!-- @AfterReturning -->  
     <aop:pointcut id="pointCutAfterReturning"   expression="execution(* com.javatpoint.Operation.*(..))" />  
     <aop:after-returning method="myadvice" returning="result" pointcut-ref="pointCutAfterReturning" />  
  </aop:aspect>  
</aop:config>  
      
</beans>  


File: Test.java
Now create the Test class that calls the actual methods.

package com.javatpoint;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test{  
    public static void main(String[] args){  
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");  
        Operation e = (Operation) context.getBean("opBean");  
        System.out.println("calling m...");  
        System.out.println(e.m());  
        System.out.println("calling k...");  
        System.out.println(e.k());  
    }  
}  

Output
calling m...  
m() method invoked  
additional concern  
Method Signature: int com.javatpoint.Operation.m()  
Result in advice: 2  
end of after returning advice...  
2  
calling k...  
k() method invoked  
additional concern  
Method Signature: int com.javatpoint.Operation.k()  
Result in advice: 3  
end of after returning advice...  
3  

You can see that return value is printed two times, one is printed by TrackOperation class and second by Test class.


4) aop:around example

The AspectJ around advice is applied before and after calling the actual business logic methods. Create a class that contains actual business logic.

File: Operation.java
package com.javatpoint;  
public  class Operation{  
    public void msg(){System.out.println("msg() is invoked");}  
    public void display(){System.out.println("display() is invoked");}  
}  


Create the aspect class that contains around advice. You need to pass the PreceedingJoinPoint reference in the advice method, so that we can proceed the request by calling the 
proceed() method.

File: TrackOperation.java
package com.javatpoint;  
import org.aspectj.lang.ProceedingJoinPoint;  
public class TrackOperation  
{  
    public Object myadvice(ProceedingJoinPoint pjp) throws Throwable   
    {  
        System.out.println("Additional Concern Before calling actual method");  
        Object obj=pjp.proceed();  
        System.out.println("Additional Concern After calling actual method");  
        return obj;  
    }  
}  


File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
    xmlns:aop="http://www.springframework.org/schema/aop"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd   
    http://www.springframework.org/schema/aop   
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd ">  
  
<aop:aspectj-autoproxy />  
  
<bean id="opBean" class="com.javatpoint.Operation">   </bean>  
      
<bean id="trackAspect" class="com.javatpoint.TrackOperation"></bean>  
          
<aop:config>  
  <aop:aspect id="myaspect" ref="trackAspect" >  
     <!-- @Around -->  
     <aop:pointcut id="pointCutAround"   expression="execution(* com.javatpoint.Operation.*(..))" />  
     <aop:around method="myadvice" pointcut-ref="pointCutAround" />  
  </aop:aspect>  
</aop:config>  
      
</beans>  


File: Test.java
Now create the Test class that calls the actual methods.

package com.javatpoint;  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test{  
    public static void main(String[] args){  
        ApplicationContext context = new classPathXmlApplicationContext("applicationContext.xml");  
          
        Operation op = (Operation) context.getBean("opBean");  
        op.msg();  
        op.display();  
    }  
}  

Output
Additional Concern Before calling actual method  
msg() is invoked  
Additional Concern After calling actual method  
Additional Concern Before calling actual method  
display() is invoked  
Additional Concern After calling actual method  

You can see that additional concern is printed before and after calling msg() and display methods.


5) aop:after-throwing example

By using after throwing advice, we can print the exception in the TrackOperation class. Let's see the example of AspectJ AfterThrowing advice. Create the class that contains business 
logic.

File: Operation.java
package com.javatpoint;  
public  class Operation{  
    public void validate(int age)throws Exception{  
    if(age<18){  
        throw new ArithmeticException("Not valid age");  
    }  
    else{  
        System.out.println("Thanks for vote");  
    }  
    }  
      
}  


Create the aspect class that contains after throwing advice.Here, we need to pass the Throwable reference also, so that we can intercept the exception here.

File: TrackOperation.java
package com.javatpoint;  
import org.aspectj.lang.JoinPoint;  
public class TrackOperation{  
                    
    public void myadvice(JoinPoint jp,Throwable error)//it is advice  
    {  
        System.out.println("additional concern");  
        System.out.println("Method Signature: "  + jp.getSignature());  
        System.out.println("Exception is: "+error);  
        System.out.println("end of after throwing advice...");  
    }  
}  
File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
    xmlns:aop="http://www.springframework.org/schema/aop"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd   
    http://www.springframework.org/schema/aop   
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd ">  
<aop:aspectj-autoproxy />  
<bean id="opBean" class="com.javatpoint.Operation">   </bean>  
<bean id="trackAspect" class="com.javatpoint.TrackOperation"></bean>  
          
<aop:config>  
  <aop:aspect id="myaspect" ref="trackAspect" >  
     <!-- @AfterThrowing -->  
     <aop:pointcut id="pointCutAfterThrowing"    expression="execution(* com.javatpoint.Operation.*(..))" />  
     <aop:after-throwing method="myadvice" throwing="error" pointcut-ref="pointCutAfterThrowing" />  
  </aop:aspect>  
</aop:config>  
      
</beans>  


File: Test.java
Now create the Test class that calls the actual methods.

package com.javatpoint;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test{  
    public static void main(String[] args){  
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");  
        Operation op = (Operation) context.getBean("opBean");  
        System.out.println("calling validate...");  
        try{  
            op.validate(19);  
        }catch(Exception e){System.out.println(e);}  
        System.out.println("calling validate again...");  
          
        try{  
            op.validate(11);  
        }catch(Exception e){System.out.println(e);}  
    }  
}  

Output

calling validate...  
Thanks for vote  
calling validate again...  
additional concern  
Method Signature: void com.javatpoint.Operation.validate(int)  
Exception is: java.lang.ArithmeticException: Not valid age  
end of after throwing advice...  
java.lang.ArithmeticException: Not valid age 

19 : What is Advice?

Advice represents action taken by aspect.



Below code is all made from another system.



1 : What are the types of advice in AOP?

There are 5 types of advices in spring AOP.

(a) : Before Advice
(b) : After Advice
(c) : After Returning Advice
(d) : Throws Advice
(e) : Around Advice


2 : What is Aspect?

Aspect is a class in spring AOP that contains advices and joinpoints.


3 : AOP Concepts and Terminology

AOP concepts and terminologies are as follows:

    Join point
    Advice
    Pointcut
    Introduction
    Target Object
    Aspect
    Interceptor
    AOP Proxy
    Weaving


Join point
Join point is any point in your program such as method execution, exception handling, field access etc. Spring supports only method
execution join point.

Advice
Advice represents an action taken by an aspect at a particular join point. There are different types of advices:

    Before Advice: it executes before a join point.
    After Returning Advice: it executes after a joint point completes normally.
    After Throwing Advice: it executes if method exits by throwing an exception.
    After (finally) Advice: it executes after a join point regardless of join point exit whether normally or exceptional return.
    Around Advice: It executes before and after a join point.

Pointcut
It is an expression language of AOP that matches join points.

Introduction
It means introduction of additional method and fields for a type. It allows you to introduce new interface to any advised object.

Target Object
It is the object i.e. being advised by one or more aspects. It is also known as proxied object in spring because Spring AOP is 
implemented using runtime proxies.

Aspect
It is a class that contains advices, joinpoints etc.

Interceptor
It is an aspect that contains only one advice.

AOP Proxy
It is used to implement aspect contracts, created by AOP framework. It will be a JDK dynamic proxy or CGLIB proxy in spring framework.

Weaving
It is the process of linking aspect with other application types or objects to create an advised object. Weaving can be done at 
compile time, load time or runtime. Spring AOP performs weaving at runtime. 


4 : Does spring perform weaving at compile time?

No, spring framework performs weaving at runtime.


5 : Spring MVC Tutorial

(1)

Spring MVC tutorial provides an elegant solution to use MVC in spring framework by the help of DispatcherServlet. In Spring Web MVC,
DispatcherServlet class works as the front controller. It is responsible to manage the flow of the spring mvc application. The 
@Controller annotation is used to mark the class as the controller in Spring 3. The @RequestMapping annotation is used to map the 
request url. It is applied on the method.

Understanding the flow of Spring Web MVC
As displayed in the figure, all the incoming request is intercepted by the DispatcherServlet that works as the front controller. The
DispatcherServlet gets entry of handler mapping from the xml file and forwards the request to the controller. The controller returns 
an object of ModelAndView. The DispatcherServlet checks the entry of view resolver in the xml file and invokes the specified view
component.

Spring Web MVC Framework Example
Let's see the simple example of spring web MVC framework. There are given 7 steps for creating the spring MVC application. The steps
are as follows:

(a) : Create the request page (optional)
(b) : Create the controller class
(c) : Provide the entry of controller in the web.xml file
(d) : Define the bean in the xml file
(e) : Display the message in the JSP page
(f) : Load the spring core and mvc jar files
(g) : Start server and deploy the project

To run this example, you need to load:

(a) : Spring Core jar files
(b) : Spring Web jar files

Download Link: Download all the jar files for spring including core, web, aop, mvc, j2ee, remoting, oxm, jdbc, orm etc.

If you are using Maven, you don't need to add jar files. Now, you need to add maven dependency in pom.xml file.

pom.xml

    <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
      xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">  
      <modelVersion>4.0.0</modelVersion>  
      <groupId>com.javatpoint</groupId>  
      <artifactId>SpringMVC</artifactId>  
      <packaging>war</packaging>  
      <version>0.0.1-SNAPSHOT</version>  
      <name>SpringMVC Maven Webapp</name>  
      <url>http://maven.apache.org</url>  
      <dependencies>  
          
    <dependency>  
          <groupId>junit</groupId>  
          <artifactId>junit</artifactId>  
          <version>3.8.1</version>  
          <scope>test</scope>  
    </dependency>  
    <dependency>  
        <groupId>javax.servlet</groupId>  
        <artifactId>servlet-api</artifactId>  
        <version>3.0-alpha-1</version>  
    </dependency>  
    <dependency>  
        <groupId>org.springframework</groupId>  
        <artifactId>spring-core</artifactId>  
        <version>3.1.2.RELEASE</version>  
    </dependency>  
    <dependency>  
        <groupId>org.springframework</groupId>  
        <artifactId>spring-context</artifactId>  
        <version>3.1.2.RELEASE</version>  
    </dependency>  
    <dependency>  
        <groupId>org.springframework</groupId>  
        <artifactId>spring-beans</artifactId>  
        <version>3.1.2.RELEASE</version>  
    </dependency>  
    <dependency>  
        <groupId>org.springframework</groupId>  
        <artifactId>spring-webmvc</artifactId>  
        <version>3.1.2.RELEASE</version>  
    </dependency>  
      
    </dependencies>  
      <build>  
        <finalName>SpringMVC</finalName>  
      </build>  
    </project>  


1) Create the request page (optional)
This is the simple jsp page containing a link. It is optional page. You may direct invoke the action class instead.

index.jsp
    <a href="hello.html">click</a>  

2) Create the controller class
To create the controller class, we are using two annotations @Controller and @RequestMapping. The @Controller annotation marks this
class as Controller. The @Requestmapping annotation is used to map the class with the specified name. This class returns the instance
of ModelAndView controller with the mapped name, message name and message value. The message value will be displayed in the jsp page.

HelloWorldController.java
    package com.javatpoint;  
    import org.springframework.stereotype.Controller;  
    import org.springframework.web.bind.annotation.RequestMapping;  
    import org.springframework.web.servlet.ModelAndView;  
    @Controller  
    public class HelloWorldController {  
        @RequestMapping("/hello")  
        public ModelAndView helloWorld() {  
            String message = "HELLO SPRING MVC HOW R U";  
            return new ModelAndView("hellopage", "message", message);  
        }  
    }  

3) Provide the entry of controller in the web.xml file
In this xml file, we are specifying the servlet class DispatcherServlet that acts as the front controller in Spring Web MVC. All the 
incoming request for the html file will be forwarded to the DispatcherServlet.

web.xml
    <?xml version="1.0" encoding="UTF-8"?>  
    <web-app version="2.5"   
        xmlns="http://java.sun.com/xml/ns/javaee"   
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
        xsi:schemaLocation="http://java.sun.com/xml/ns/javaee   
        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">  
     <servlet>  
        <servlet-name>spring</servlet-name>  
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>  
        <load-on-startup>1</load-on-startup>  
    </servlet>  
    <servlet-mapping>  
        <servlet-name>spring</servlet-name>  
        <url-pattern>*.html</url-pattern>  
    </servlet-mapping>  
    </web-app>  

4) Define the bean in the xml file

This is the important configuration file where we need to specify the ViewResolver and View components. The context:component-scan
element defines the base-package where DispatcherServlet will search the controller class. Here, the InternalResourceViewResolver
class is used for the ViewResolver. The prefix+string returned by controller+suffix page will be invoked for the view component.
This xml file should be located inside the WEB-INF directory.

spring-servlet.xml
    <?xml version="1.0" encoding="UTF-8"?>  
    <beans xmlns="http://www.springframework.org/schema/beans"  
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
        xmlns:p="http://www.springframework.org/schema/p"  
        xmlns:context="http://www.springframework.org/schema/context"  
        xsi:schemaLocation="http://www.springframework.org/schema/beans  
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  
    http://www.springframework.org/schema/context  
    http://www.springframework.org/schema/context/spring-context-3.0.xsd">  
        <context:component-scan  base-package="com.javatpoint" />  
        <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">  
            <property name="prefix" value="/WEB-INF/jsp/" />  
            <property name="suffix" value=".jsp" />  
        </bean>  
    </beans>  

5) Display the message in the JSP page

This is the simple JSP page, displaying the message returned by the Controller. It must be located inside the WEB-INF/jsp directory
for this example only.

hellopage.jsp
    Message is: ${message}  

Output

(2)

Spring 3 MVC Multiple Controller Example
We can have a lot of controller classes in Spring Framework. In this example, we are creating two Controller classes 
HelloWorldController and WelcomeWorldController.

1) Controller Classes

HelloWorldController.java

    package com.javatpoint;  
    import org.springframework.stereotype.Controller;  
    import org.springframework.web.bind.annotation.RequestMapping;  
    import org.springframework.web.servlet.ModelAndView;  
      
    @Controller  
    public class HelloWorldController {  
      
        @RequestMapping("/hello")  
        public ModelAndView helloWorld() {  
      
            String message = "HELLO SPRING MVC";  
            return new ModelAndView("hellopage", "message", message);  
        }  
          
    }  

WelcomeWorldController.java

    package com.javatpoint;  
    import org.springframework.stereotype.Controller;  
    import org.springframework.web.bind.annotation.RequestMapping;  
    import org.springframework.web.servlet.ModelAndView;  
      
    @Controller  
    public class WelcomeWorldController {  
      
        @RequestMapping("/welcome")  
        public ModelAndView helloWorld() {  
      
            String message = "WELCOME SPRING MVC";  
            return new ModelAndView("welcomepage", "message", message);  
        }  
          
    }  

2) View components

To run this example, It must be located inside the WEB-INF/jsp directory.
hellopage.jsp
    Message is: ${message}  

welcomepage.jsp
    Message is: ${message}  

3) Index page

It is the optional welcome page, that provide the links to invoke both controller.
index.jsp
    <a href="hello.html">click</a>|  
    <a href="welcome.html">click</a>  

Other pages are same e.g. spring-servlet.xml and web.xml.

(3)

Spring MVC Request Response Example

We can simply create login application by following the Spring MVC. We need to pass HttpServletRequest and HttpServletResponse 
objects in the request processing method of the Controller class. Let's see the example:

1) Controller Class
HelloWorldController.java

    package com.javatpoint;  
    import javax.servlet.http.HttpServletRequest;  
    import javax.servlet.http.HttpServletResponse;  
    import org.springframework.stereotype.Controller;  
    import org.springframework.web.bind.annotation.RequestMapping;  
    import org.springframework.web.servlet.ModelAndView;  
      
    @Controller  
    public class HelloWorldController {  
          
        @RequestMapping("/hello")  
        public ModelAndView helloWorld(HttpServletRequest request,HttpServletResponse res) {  
            String name=request.getParameter("name");  
            String password=request.getParameter("password");  
              
            if(password.equals("admin")){  
            String message = "HELLO "+name;  
            return new ModelAndView("hellopage", "message", message);  
            }  
            else{  
                return new ModelAndView("errorpage", "message","Sorry, username or password error");  
            }  
        }  
          
    }  

2) View components
To run this example, It must be located inside the WEB-INF/jsp directory.
hellopage.jsp
    Message is: ${message}  

errorpage.jsp
    ${message}  
    <jsp:include page="/index.jsp"></jsp:include>  

3) Index page

It is the login page, that recieve name and password from the user.
index.jsp
    <form action="hello.html" method="post">  
    Name:<input type="text" name="name"/><br/>  
    Password:<input type="password" name="password"/><br/>  
    <input type="submit" value="login"/>  
    </form>  

Other pages are same e.g. spring-servlet.xml and web.xml.

(4)

Spring MVC Form Example

Here, we will learn how to handle a form data in spring MVC without using database. Here, we will use @Controler, @RequestMapping and
@ModelAttribute annotations. To display the input form, we are going to use <form:form> tag of spring framework. Let's see a simple
example to store form data in a model object and display data of a list.

Required Jar files
To run this example, you need to load:

    Spring Core jar files
    Spring Web jar files

download all the jar files for spring including core, web, aop, mvc, j2ee, remoting, oxm, jdbc, orm etc.

index.jsp
    <a href="empform">Add Employee</a>  
    <a href="viewemp">View Employees</a>  

Emp.java
    package com.javatpoint.beans;  
    public class Emp {  
    private int id;  
    private String name;  
    private float salary;  
    private String designation;  
      
    public Emp() {}  
      
    public Emp(int id, String name, float salary, String designation) {  
        super();  
        this.id = id;  
        this.name = name;  
        this.salary = salary;  
        this.designation = designation;  
    }  
      
    public int getId() {  
        return id;  
    }  
    public void setId(int id) {  
        this.id = id;  
    }  
    public String getName() {  
        return name;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
    public float getSalary() {  
        return salary;  
    }  
    public void setSalary(float salary) {  
        this.salary = salary;  
    }  
    public String getDesignation() {  
        return designation;  
    }  
    public void setDesignation(String designation) {  
        this.designation = designation;  
    }  
      
    }  

EmpController.java
    package com.javatpoint.controllers;  
      
    import java.util.ArrayList;  
    import java.util.List;  
    import org.springframework.stereotype.Controller;  
    import org.springframework.web.bind.annotation.ModelAttribute;  
    import org.springframework.web.bind.annotation.RequestMapping;  
    import org.springframework.web.bind.annotation.RequestMethod;  
    import org.springframework.web.servlet.ModelAndView;  
    import com.javatpoint.beans.Emp;  
    @Controller  
    public class EmpController {  
      
        @RequestMapping("/empform")  
        public ModelAndView showform(){  
             //command is a reserved request attribute name, now use <form> tag to show object data  
            return new ModelAndView("empform","command",new Emp());  
        }  
        @RequestMapping(value="/save",method = RequestMethod.POST)  
        public ModelAndView save(@ModelAttribute("emp") Emp emp){  
            //write code to save emp object  
            //here, we are displaying emp object to prove emp has data  
            System.out.println(emp.getName()+" "+emp.getSalary()+" "+emp.getDesignation());  
              
            //return new ModelAndView("empform","command",emp);//will display object data  
            return new ModelAndView("redirect:/viewemp");//will redirect to viewemp request mapping  
        }  
          
        @RequestMapping("/viewemp")  
        public ModelAndView viewemp(){  
            //write the code to get all employees from DAO  
            //here, we are writing manual code of list for easy understanding  
            List<Emp> list=new ArrayList<Emp>();  
            list.add(new Emp(1,"rahul",35000f,"S.Engineer"));  
            list.add(new Emp(2,"aditya",25000f,"IT Manager"));  
            list.add(new Emp(3,"sachin",55000f,"Care Taker"));  
              
            return new ModelAndView("viewemp","list",list);  
        }  
    }  

web.xml
    <?xml version="1.0" encoding="UTF-8"?>  
    <web-app version="2.5"   
        xmlns="http://java.sun.com/xml/ns/javaee"   
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
        xsi:schemaLocation="http://java.sun.com/xml/ns/javaee   
        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">  
     <servlet>  
        <servlet-name>spring</servlet-name>  
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>  
        <load-on-startup>1</load-on-startup>  
    </servlet>  
    <servlet-mapping>  
        <servlet-name>spring</servlet-name>  
        <url-pattern>/</url-pattern>  
    </servlet-mapping>  
    </web-app>  

spring-servlet.xml
    <?xml version="1.0" encoding="UTF-8"?>  
    <beans xmlns="http://www.springframework.org/schema/beans"    
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    
        xmlns:p="http://www.springframework.org/schema/p"    
        xmlns:context="http://www.springframework.org/schema/context"    
        xsi:schemaLocation="http://www.springframework.org/schema/beans    
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd    
    http://www.springframework.org/schema/context    
    http://www.springframework.org/schema/context/spring-context-3.0.xsd">    
      
    <context:component-scan base-package="com.javatpoint.controllers"></context:component-scan>  
      
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">  
    <property name="prefix" value="/WEB-INF/jsp/"></property>  
    <property name="suffix" value=".jsp"></property>  
    </bean>  
      
    </beans>  

empform.jsp
    <%@ taglib uri="http://www.springframework.org/tags/form" prefix="form"%>    
    <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>    
      
           <form:form method="post" action="save">    
            <table >    
             <tr>    
              <td>Name : </td>   
              <td><form:input path="name"  /></td>  
             </tr>    
             <tr>    
              <td>Salary :</td>    
              <td><form:input path="salary" /></td>  
             </tr>   
             <tr>    
              <td>Designation :</td>    
              <td><form:input path="designation" /></td>  
             </tr>   
             <tr>    
              <td colspan="2"><input type="submit" value="Save" /></td>    
             </tr>    
            </table>    
           </form:form>    

viewemp.jsp
       <%@ taglib uri="http://www.springframework.org/tags/form" prefix="form"%>    
       <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>    
      
      
    <table border="2" width="70%" cellpadding="2">  
    <tr><th>Id</th><th>Name</th><th>Salary</th><th>Designation</th></tr>  
       <c:forEach var="emp" items="${list}">   
       <tr>  
       <td>${emp.id}</td>  
       <td>${emp.name}</td>  
       <td>${emp.salary}</td>  
       <td>${emp.designation}</td>  
       </tr>  
       </c:forEach>  
       </table>


(5)

Spring MVC CRUD Example

CRUD (Create, Read, Update and Delete) application is the most important application for creating any project. It provides an idea to
develop a large project. In spring MVC, we can develop a simple CRUD application. Here, we are using JdbcTemplate for database 
interaction.

Required Jar files
To run this example, you need to load:

    Spring Core jar files
    Spring Web jar files
    ojdbc14.jar file for oracle

download all the jar files for spring including core, web, aop, mvc, j2ee, remoting, oxm, jdbc, orm etc.

Create table
Here, we are using emp99 table of oracle 10g database which has 4 fields: id, name, salary and designation. Here, id is auto
incremented which is generated by sequence.

index.jsp
    <a href="empform">Add Employee</a>  
    <a href="viewemp">View Employees</a>  

Emp.java
    package com.javatpoint.beans;  
      
    public class Emp {  
    private int id;  
    private String name;  
    private float salary;  
    private String designation;  
      
    public int getId() {  
        return id;  
    }  
    public void setId(int id) {  
        this.id = id;  
    }  
    public String getName() {  
        return name;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
    public float getSalary() {  
        return salary;  
    }  
    public void setSalary(float salary) {  
        this.salary = salary;  
    }  
    public String getDesignation() {  
        return designation;  
    }  
    public void setDesignation(String designation) {  
        this.designation = designation;  
    }  
      
    }  

EmpDao.java
    package com.javatpoint.dao;  
    import java.sql.ResultSet;  
    import java.sql.SQLException;  
    import java.util.List;  
    import org.springframework.jdbc.core.BeanPropertyRowMapper;  
    import org.springframework.jdbc.core.JdbcTemplate;  
    import org.springframework.jdbc.core.RowMapper;  
    import com.javatpoint.beans.Emp;  
      
    public class EmpDao {  
    JdbcTemplate template;  
      
    public void setTemplate(JdbcTemplate template) {  
        this.template = template;  
    }  
    public int save(Emp p){  
        String sql="insert into Emp99(name,salary,designation)   
              values('"+p.getName()+"',"+p.getSalary()+",'"+p.getDesignation()+"')";  
        return template.update(sql);  
    }  
    public int update(Emp p){  
        String sql="update Emp99 set name='"+p.getName()+"', salary="+p.getSalary()+",   
              designation='"+p.getDesignation()+"' where id="+p.getId()+"";  
        return template.update(sql);  
    }  
    public int delete(int id){  
        String sql="delete from Emp99 where id="+id+"";  
        return template.update(sql);  
    }  
    public Emp getEmpById(int id){  
        String sql="select * from Emp99 where id=?";  
        return template.queryForObject(sql, new Object[]{id},new BeanPropertyRowMapper<Emp>(Emp.class));  
    }  
    public List<Emp> getEmployees(){  
        return template.query("select * from Emp99",new RowMapper<Emp>(){  
            public Emp mapRow(ResultSet rs, int row) throws SQLException {  
                Emp e=new Emp();  
                e.setId(rs.getInt(1));  
                e.setName(rs.getString(2));  
                e.setSalary(rs.getFloat(3));  
                e.setDesignation(rs.getString(4));  
                return e;  
            }  
        });  
    }  
    }  

EmpController.java
    package com.javatpoint.controllers;  
    import java.util.ArrayList;  
    import java.util.List;  
    import org.springframework.beans.factory.annotation.Autowired;  
    import org.springframework.stereotype.Controller;  
    import org.springframework.web.bind.annotation.ModelAttribute;  
    import org.springframework.web.bind.annotation.PathVariable;  
    import org.springframework.web.bind.annotation.RequestMapping;  
    import org.springframework.web.bind.annotation.RequestMethod;  
    import org.springframework.web.servlet.ModelAndView;  
    import com.javatpoint.beans.Emp;  
    import com.javatpoint.dao.EmpDao;  
    @Controller  
    public class EmpController {  
        @Autowired  
        EmpDao dao;//will inject dao from xml file  
          
        /*It displays a form to input data, here "command" is a reserved request attribute 
         *which is used to display object data into form 
         */  
        @RequestMapping("/empform")  
        public ModelAndView showform(){  
            return new ModelAndView("empform","command",new Emp());  
        }  
        /*It saves object into database. The @ModelAttribute puts request data 
         *  into model object. You need to mention RequestMethod.POST method  
         *  because default request is GET*/  
        @RequestMapping(value="/save",method = RequestMethod.POST)  
        public ModelAndView save(@ModelAttribute("emp") Emp emp){  
            dao.save(emp);  
            return new ModelAndView("redirect:/viewemp");//will redirect to viewemp request mapping  
        }  
        /* It provides list of employees in model object */  
        @RequestMapping("/viewemp")  
        public ModelAndView viewemp(){  
            List<Emp> list=dao.getEmployees();  
            return new ModelAndView("viewemp","list",list);  
        }  
        /* It displays object data into form for the given id.  
         * The @PathVariable puts URL data into variable.*/  
        @RequestMapping(value="/editemp/{id}")  
        public ModelAndView edit(@PathVariable int id){  
            Emp emp=dao.getEmpById(id);  
            return new ModelAndView("empeditform","command",emp);  
        }  
        /* It updates model object. */  
        @RequestMapping(value="/editsave",method = RequestMethod.POST)  
        public ModelAndView editsave(@ModelAttribute("emp") Emp emp){  
            dao.update(emp);  
            return new ModelAndView("redirect:/viewemp");  
        }  
        /* It deletes record for the given id in URL and redirects to /viewemp */  
        @RequestMapping(value="/deleteemp/{id}",method = RequestMethod.GET)  
        public ModelAndView delete(@PathVariable int id){  
            dao.delete(id);  
            return new ModelAndView("redirect:/viewemp");  
        }  
      
    }  

web.xml
    <?xml version="1.0" encoding="UTF-8"?>  
    <web-app version="2.5"   
        xmlns="http://java.sun.com/xml/ns/javaee"   
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
        xsi:schemaLocation="http://java.sun.com/xml/ns/javaee   
        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">  
     <servlet>  
        <servlet-name>spring</servlet-name>  
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>  
        <load-on-startup>1</load-on-startup>  
    </servlet>  
    <servlet-mapping>  
        <servlet-name>spring</servlet-name>  
        <url-pattern>/</url-pattern>  
    </servlet-mapping>  
    </web-app>  

spring-servlet.xml
    <?xml version="1.0" encoding="UTF-8"?>  
    <beans xmlns="http://www.springframework.org/schema/beans"    
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    
        xmlns:p="http://www.springframework.org/schema/p"    
        xmlns:context="http://www.springframework.org/schema/context"    
        xsi:schemaLocation="http://www.springframework.org/schema/beans    
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd    
    http://www.springframework.org/schema/context    
    http://www.springframework.org/schema/context/spring-context-3.0.xsd">    
      
    <context:component-scan base-package="com.javatpoint.controllers"></context:component-scan>  
      
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">  
    <property name="prefix" value="/WEB-INF/jsp/"></property>  
    <property name="suffix" value=".jsp"></property>  
    </bean>  
      
    <bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">  
    <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"></property>  
    <property name="url" value="jdbc:oracle:thin:@localhost:1521:xe"></property>  
    <property name="username" value="system"></property>  
    <property name="password" value="oracle"></property>  
    </bean>  
      
    <bean id="jt" class="org.springframework.jdbc.core.JdbcTemplate">  
    <property name="dataSource" ref="ds"></property>  
    </bean>  
      
    <bean id="dao" class="com.javatpoint.dao.EmpDao">  
    <property name="template" ref="jt"></property>  
    </bean>  
    </beans>  

empform.jsp
    <%@ taglib uri="http://www.springframework.org/tags/form" prefix="form"%>    
    <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>    
      
            <h1>Add New Employee</h1>  
           <form:form method="post" action="save">    
            <table >    
             <tr>    
              <td>Name : </td>   
              <td><form:input path="name"  /></td>  
             </tr>    
             <tr>    
              <td>Salary :</td>    
              <td><form:input path="salary" /></td>  
             </tr>   
             <tr>    
              <td>Designation :</td>    
              <td><form:input path="designation" /></td>  
             </tr>   
             <tr>    
              <td> </td>    
              <td><input type="submit" value="Save" /></td>    
             </tr>    
            </table>    
           </form:form>    

empeditform.jsp
Here "/SpringMVCCRUDSimple" is the project name, change this if you have different project name. For live application, you can provide full URL.

    <%@ taglib uri="http://www.springframework.org/tags/form" prefix="form"%>    
    <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>    
      
            <h1>Edit Employee</h1>  
           <form:form method="POST" action="/SpringMVCCRUDSimple/editsave">    
            <table >    
            <tr>  
            <td></td>    
             <td><form:hidden  path="id" /></td>  
             </tr>   
             <tr>    
              <td>Name : </td>   
              <td><form:input path="name"  /></td>  
             </tr>    
             <tr>    
              <td>Salary :</td>    
              <td><form:input path="salary" /></td>  
             </tr>   
             <tr>    
              <td>Designation :</td>    
              <td><form:input path="designation" /></td>  
             </tr>   
               
             <tr>    
              <td> </td>    
              <td><input type="submit" value="Edit Save" /></td>    
             </tr>    
            </table>    
           </form:form>    

viewemp.jsp
       <%@ taglib uri="http://www.springframework.org/tags/form" prefix="form"%>    
       <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>    
      
    <h1>Employees List</h1>  
    <table border="2" width="70%" cellpadding="2">  
    <tr><th>Id</th><th>Name</th><th>Salary</th><th>Designation</th><th>Edit</th><th>Delete</th></tr>  
       <c:forEach var="emp" items="${list}">   
       <tr>  
       <td>${emp.id}</td>  
       <td>${emp.name}</td>  
       <td>${emp.salary}</td>  
       <td>${emp.designation}</td>  
       <td><a href="editemp/${emp.id}">Edit</a></td>  
       <td><a href="deleteemp/${emp.id}">Delete</a></td>  
       </tr>  
       </c:forEach>  
       </table>  
       <br/>  
       <a href="empform">Add New Employee</a>  


(6)

Spring MVC File Upload Example

Spring MVC provides easy way to upload files, it may be image or other files. Let's see a simple example to upload file using 
Spring MVC.

Required Jar files
To run this example, you need to load:

    Spring Core jar files
    Spring Web jar files
    commons-fileupload.jar and commons-io.jar file

1) Download all the jar files for spring including core, web, aop, mvc, j2ee, remoting, oxm, jdbc, orm etc.

2) Download commons-io.jar

3) Download commons-fileupload.jar


Spring MVC File Upload Steps (Extra than MVC)
1) Add commons-io and fileupload.jar files
2) Add entry of CommonsMultipartResolver in spring-servlet.xml
    <bean id="multipartResolver"   
    class="org.springframework.web.multipart.commons.CommonsMultipartResolver"/>  

3) Create form to submit file. Method name must be "post" and enctype "multiple/form-data".

    <form action="savefile" method="post" enctype="multipart/form-data">  
    Select File: <input type="file" name="file"/>  
    <input type="submit" value="Upload File"/>  
    </form>  

4) Use CommonsMultipartFile class in Controller.

    @RequestMapping(value="/savefile",method=RequestMethod.POST)  
    public ModelAndView upload(@RequestParam CommonsMultipartFile file,HttpSession session){  
            String path=session.getServletContext().getRealPath("/");  
            String filename=file.getOriginalFilename();  
              
            System.out.println(path+" "+filename);  
            try{  
            byte barr[]=file.getBytes();  
              
            BufferedOutputStream bout=new BufferedOutputStream(  
                     new FileOutputStream(path+"/"+filename));  
            bout.write(barr);  
            bout.flush();  
            bout.close();  
              
            }catch(Exception e){System.out.println(e);}  
            return new ModelAndView("upload-success","filename",path+"/"+filename);  
        }  

5) Display image in JSP.

    <h1>Upload Success</h1>  
    <img src="${filename}"/>  

Spring MVC File Upload Example

Create "images" directory in your project because we are writing the code to save all the files inside "/images" directory.

index.jsp
    <a href="uploadform">Upload Image</a>  

Emp.java
    package com.javatpoint;  
    import java.io.BufferedOutputStream;  
    import java.io.File;  
    import java.io.FileOutputStream;  
    import javax.servlet.ServletContext;  
    import javax.servlet.http.HttpServletRequest;  
    import javax.servlet.http.HttpServletResponse;  
    import javax.servlet.http.HttpSession;  
    import org.apache.commons.fileupload.disk.DiskFileItemFactory;  
    import org.apache.commons.fileupload.servlet.ServletFileUpload;  
    import org.springframework.stereotype.Controller;  
    import org.springframework.web.bind.annotation.ModelAttribute;  
    import org.springframework.web.bind.annotation.RequestMapping;  
    import org.springframework.web.bind.annotation.RequestMethod;  
    import org.springframework.web.bind.annotation.RequestParam;  
    import org.springframework.web.multipart.commons.CommonsMultipartFile;  
    import org.springframework.web.servlet.ModelAndView;  
      
    @Controller  
    public class HelloController {  
        private static final String UPLOAD_DIRECTORY ="/images";  
          
        @RequestMapping("uploadform")  
        public ModelAndView uploadForm(){  
            return new ModelAndView("uploadform");    
        }  
          
        @RequestMapping(value="savefile",method=RequestMethod.POST)  
        public ModelAndView saveimage( @RequestParam CommonsMultipartFile file,  
               HttpSession session) throws Exception{  
      
        ServletContext context = session.getServletContext();  
        String path = context.getRealPath(UPLOAD_DIRECTORY);  
        String filename = file.getOriginalFilename();  
      
        System.out.println(path+" "+filename);        
      
        byte[] bytes = file.getBytes();  
        BufferedOutputStream stream =new BufferedOutputStream(new FileOutputStream(  
             new File(path + File.separator + filename)));  
        stream.write(bytes);  
        stream.flush();  
        stream.close();  
               
        return new ModelAndView("uploadform","filesuccess","File successfully saved!");  
        }  
    }  

web.xml
    <?xml version="1.0" encoding="UTF-8"?>  
    <web-app version="2.5"   
        xmlns="http://java.sun.com/xml/ns/javaee"   
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
        xsi:schemaLocation="http://java.sun.com/xml/ns/javaee   
        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">  
     <servlet>  
        <servlet-name>spring</servlet-name>  
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>  
        <load-on-startup>1</load-on-startup>  
    </servlet>  
    <servlet-mapping>  
        <servlet-name>spring</servlet-name>  
        <url-pattern>/</url-pattern>  
    </servlet-mapping>  
    </web-app>  

spring-servlet.xml
Here, you need to create a bean for CommonsMultipartResolver.

    <?xml version="1.0" encoding="UTF-8"?>  
    <beans xmlns="http://www.springframework.org/schema/beans"    
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    
        xmlns:p="http://www.springframework.org/schema/p"    
        xmlns:context="http://www.springframework.org/schema/context"    
        xsi:schemaLocation="http://www.springframework.org/schema/beans    
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd    
    http://www.springframework.org/schema/context    
    http://www.springframework.org/schema/context/spring-context-3.0.xsd">    
      
    <context:component-scan base-package="com.javatpoint"></context:component-scan>  
      
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">  
    <property name="prefix" value="/WEB-INF/jsp/"></property>  
    <property name="suffix" value=".jsp"></property>  
    </bean>  
      
    <bean id="multipartResolver"   
    class="org.springframework.web.multipart.commons.CommonsMultipartResolver"/>  
      
    </beans>  

uploadform.jsp
Here form must be method="post" and enctype="multipart/form-data".

    <%@taglib uri="http://www.springframework.org/tags/form" prefix="form"%>  
       
    <!DOCTYPE html>  
    <html>  
     <head>  
     <title>Image File Upload</title>  
     </head>  
     <body>  
    <h1>File Upload Example - JavaTpoint</h1>  
      
    <h3 style="color:red">${filesuccess}</h3>  
    <form:form method="post" action="savefile" enctype="multipart/form-data">  
    <p><label for="image">Choose Image</label></p>  
    <p><input name="file" id="fileToUpload" type="file" /></p>  
    <p><input type="submit" value="Upload"></p>  
    </form:form>  
    </body>  
    </html>  


(7) : Spring MVC Pagination Example

Pagination is used to display large number of records in different parts. In such case, we display 10, 20 or 50 records in one page.
For remaining records, we provide links. We can simply create pagination example in Spring MVC. In this pagination example, we are
using MySQL database to fetch records.

Required Jar files
To run this example, you need to load:

    Spring Core jar files
    Spring Web jar files
    mysql-connector.jar file

download all the jar files for spring including core, web, aop, mvc, j2ee, remoting, oxm, jdbc, orm etc.

Create table or import sql file

Here, we have created "emp" table in "test" database. The emp table has three fields: id, name and salary. Either create table and 
insert records manually or import our sql file.

Spring MVC Pagination Example

index.jsp
    <a href="viewemp/1">View Employees</a>  

Emp.java
    package com.javatpoint.beans;  
      
    public class Emp {  
    private int id;  
    private String name;  
    private float salary;  
      
    public int getId() {  
        return id;  
    }  
    public void setId(int id) {  
        this.id = id;  
    }  
    public String getName() {  
        return name;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
    public float getSalary() {  
        return salary;  
    }  
    public void setSalary(float salary) {  
        this.salary = salary;  
    }  
      
    }  

EmpDao.java
    package com.javatpoint.dao;  
      
    import java.sql.ResultSet;  
    import java.sql.SQLException;  
    import java.util.List;  
    import org.springframework.jdbc.core.JdbcTemplate;  
    import org.springframework.jdbc.core.RowMapper;  
    import com.javatpoint.beans.Emp;  
      
    public class EmpDao {  
    JdbcTemplate template;  
      
    public void setTemplate(JdbcTemplate template) {  
        this.template = template;  
    }  
      
    public List<Emp> getEmployeesByPage(int pageid,int total){  
        String sql="select * from Emp limit "+(pageid-1)+","+total;  
        return template.query(sql,new RowMapper<Emp>(){  
            public Emp mapRow(ResultSet rs, int row) throws SQLException {  
                Emp e=new Emp();  
                e.setId(rs.getInt(1));  
                e.setName(rs.getString(2));  
                e.setSalary(rs.getFloat(3));  
                return e;  
            }  
        });  
    }  
    }  

EmpController.java
    package com.javatpoint.controllers;  
      
    import java.util.ArrayList;  
    import java.util.List;  
      
    import org.springframework.beans.factory.annotation.Autowired;  
    import org.springframework.stereotype.Controller;  
    import org.springframework.web.bind.annotation.ModelAttribute;  
    import org.springframework.web.bind.annotation.PathVariable;  
    import org.springframework.web.bind.annotation.RequestMapping;  
    import org.springframework.web.bind.annotation.RequestMethod;  
    import org.springframework.web.servlet.ModelAndView;  
    import com.javatpoint.beans.Emp;  
    import com.javatpoint.dao.EmpDao;  
    @Controller  
    public class EmpController {  
        @Autowired  
        EmpDao dao;  
          
        @RequestMapping(value="/viewemp/{pageid}")  
        public ModelAndView edit(@PathVariable int pageid){  
            int total=5;  
            if(pageid==1){}  
            else{  
                pageid=(pageid-1)*total+1;  
            }  
            List<Emp> list=dao.getEmployeesByPage(pageid,total);  
              
            return new ModelAndView("viewemp","list",list);  
        }  
      
    }  

web.xml
    <?xml version="1.0" encoding="UTF-8"?>  
    <web-app version="2.5"   
        xmlns="http://java.sun.com/xml/ns/javaee"   
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
        xsi:schemaLocation="http://java.sun.com/xml/ns/javaee   
        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">  
     <servlet>  
        <servlet-name>spring</servlet-name>  
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>  
        <load-on-startup>1</load-on-startup>  
    </servlet>  
    <servlet-mapping>  
        <servlet-name>spring</servlet-name>  
        <url-pattern>/</url-pattern>  
    </servlet-mapping>  
    </web-app>  

spring-servlet.xml
    <?xml version="1.0" encoding="UTF-8"?>  
    <beans xmlns="http://www.springframework.org/schema/beans"    
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    
        xmlns:p="http://www.springframework.org/schema/p"    
        xmlns:context="http://www.springframework.org/schema/context"    
        xsi:schemaLocation="http://www.springframework.org/schema/beans    
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd    
    http://www.springframework.org/schema/context    
    http://www.springframework.org/schema/context/spring-context-3.0.xsd">    
      
    <context:component-scan base-package="com.javatpoint.controllers"></context:component-scan>  
      
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">  
    <property name="prefix" value="/WEB-INF/jsp/"></property>  
    <property name="suffix" value=".jsp"></property>  
    </bean>  
      
    <bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">  
    <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>  
    <property name="url" value="jdbc:mysql://localhost:3306/test"></property>  
    <property name="username" value=""></property>  
    <property name="password" value=""></property>  
    </bean>  
      
    <bean id="jt" class="org.springframework.jdbc.core.JdbcTemplate">  
    <property name="dataSource" ref="ds"></property>  
    </bean>  
      
    <bean id="dao" class="com.javatpoint.dao.EmpDao">  
    <property name="template" ref="jt"></property>  
    </bean>  
    </beans>  

viewemp.jsp
        <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>    
      
    <h1>Employees List</h1>  
    <table border="2" width="70%" cellpadding="2">  
    <tr><th>Id</th><th>Name</th><th>Salary</th></tr>  
       <c:forEach var="emp" items="${list}">   
       <tr>  
       <td>${emp.id}</td>  
       <td>${emp.name}</td>  
       <td>${emp.salary}</td>  
       </tr>  
       </c:forEach>  
       </table>  
       <br/>  
       <a href="/SpringMVC/viewemp/1">1</a>   
       <a href="/SpringMVC/viewemp/2">2</a>   
       <a href="/SpringMVC/viewemp/3">3</a>

(8) 

Spring MVC Tiles Example

Spring provides integration support with apache tiles framework. So we can simply manage the layout of the spring mvc application by
the help of spring tiles support.

Advantage of Tiles support in Spring MVC

    Reusability: We can reuse a single component in multiple pages like header and footer components.
    Centralized control: We can control the layout of the page by a single template page only.
    Easy to change the layout: By the help of single template page, we can change the layout of the page anytime. So your website can easily adapt new technologies such as bootstrap, jquery etc.

Spring MVC Tiles Example

Let's see a simple spring mvc tiles example.

Required Jar files
To run this example, you need to load:

    Spring Core jar files
    Spring Web jar files
    Tiles jar files

download required jar file

You need to put these jar files inside the WEB-INF/lib directory.

index.jsp
    <a href="hello.html">Hello Spring</a> |   
    <a href="contact.html">Contact</a>  

Controller classes
HelloWorldController.java
    package com.javatpoint.controller;  
    import org.springframework.stereotype.Controller;  
    import org.springframework.web.bind.annotation.RequestMapping;  
    import org.springframework.web.servlet.ModelAndView;  
    @Controller  
    public class HelloWorldController {  
        @RequestMapping("/hello")  
        public ModelAndView helloWorld() {  
            String message = "Hello World, Spring MVC @ Javatpoint";  
            return new ModelAndView("hello", "message", message);  
        }  
    }  

ContactController.java
    package com.javatpoint.controller;  
    import org.springframework.stereotype.Controller;  
    import org.springframework.validation.BindingResult;  
    import org.springframework.web.bind.annotation.ModelAttribute;  
    import org.springframework.web.bind.annotation.RequestMapping;  
    import org.springframework.web.bind.annotation.RequestMethod;  
    import org.springframework.web.bind.annotation.SessionAttributes;  
    import org.springframework.web.servlet.ModelAndView;  
    import com.javatpoint.form.Contact;  
    @Controller  
    @SessionAttributes  
    public class ContactController {  
        @RequestMapping(value = "/addContact", method = RequestMethod.POST)  
        public String addContact(@ModelAttribute("contact") Contact contact, BindingResult result) {  
            //write the code here to add contact  
            return "redirect:contact.html";  
        }  
          
        @RequestMapping("/contact")  
        public ModelAndView showContacts() {  
            return new ModelAndView("contact", "command", new Contact());  
        }  
    }  

Form class
Contact.java
    package com.javatpoint.form;  
    public class Contact {  
        private String firstname;  
        private String lastname;  
        private String email;  
        private String telephone;  
        //getters and setters  
    }  

web.xml
In this xml file, we are specifying the servlet class DispatcherServlet that acts as the front controller in Spring Web MVC. All the
incoming request for the html file will be forwarded to the DispatcherServlet.
web.xml
    <?xml version="1.0" encoding="UTF-8"?>  
    <web-app version="2.5"   
        xmlns="http://java.sun.com/xml/ns/javaee"   
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
        xsi:schemaLocation="http://java.sun.com/xml/ns/javaee   
        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">  
        
     <servlet>  
        <servlet-name>spring</servlet-name>  
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>  
        <load-on-startup>1</load-on-startup>  
    </servlet>  
          
    <servlet-mapping>  
        <servlet-name>spring</servlet-name>  
        <url-pattern>*.html</url-pattern>  
    </servlet-mapping>  
          
    </web-app>  

spring-servlet.xml file
This is the important configuration file where we need to specify the ViewResolver and View components. The context:component-scan 
element defines the base-package where DispatcherServlet will search the controller class. Here, the UrlBasedViewResolver class is 
used for the ViewResolver. The prefix+string returned by controller+suffix page will be invoked for the view component. This xml file
should be located inside the WEB-INF directory.

spring-servlet.xml
     <beans xmlns="http://www.springframework.org/schema/beans"  
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
        xmlns:p="http://www.springframework.org/schema/p"  
        xmlns:context="http://www.springframework.org/schema/context"  
        xsi:schemaLocation="http://www.springframework.org/schema/beans  
            http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  
            http://www.springframework.org/schema/context  
            http://www.springframework.org/schema/context/spring-context-3.0.xsd">  
      
        <context:component-scan  
            base-package="com.javatpoint.controller" />  
      
        <bean id="viewResolver"  
            class="org.springframework.web.servlet.view.UrlBasedViewResolver">  
            <property name="viewClass">  
                <value>  
                    org.springframework.web.servlet.view.tiles2.TilesView  
                </value>  
            </property>  
        </bean>  
        <bean id="tilesConfigurer"  
            class="org.springframework.web.servlet.view.tiles2.TilesConfigurer">  
            <property name="definitions">  
                <list>  
                    <value>/WEB-INF/tiles.xml</value>  
                </list>  
            </property>  
        </bean>  
    </beans>  

tiles.xml file
tiles.xml
    <?xml version="1.0" encoding="UTF-8" ?>  
    <!DOCTYPE tiles-definitions PUBLIC  
           "-//Apache Software Foundation//DTD Tiles Configuration 2.0//EN"  
           "http://tiles.apache.org/dtds/tiles-config_2_0.dtd">  
    <tiles-definitions>  
        <definition name="base.definition"  
            template="/WEB-INF/jsp/layout.jsp">  
            <put-attribute name="title" value="" />  
            <put-attribute name="header" value="/WEB-INF/jsp/header.jsp" />  
            <put-attribute name="menu" value="/WEB-INF/jsp/menu.jsp" />  
            <put-attribute name="body" value="" />  
            <put-attribute name="footer" value="/WEB-INF/jsp/footer.jsp" />  
        </definition>  
      
        <definition name="contact" extends="base.definition">  
            <put-attribute name="title" value="Contact Manager" />  
            <put-attribute name="body" value="/WEB-INF/jsp/contact.jsp" />  
        </definition>  
      
        <definition name="hello" extends="base.definition">  
            <put-attribute name="title" value="Hello Spring MVC" />  
            <put-attribute name="body" value="/WEB-INF/jsp/hello.jsp" />  
        </definition>  
      
    </tiles-definitions>  

View Components
hello.jsp
    <html>  
    <head>  
        <title>Spring MVC Example</title>  
    </head>  
    <body>  
    <h1>Welcome to Spring MVC</h1>  
        <p>Message is: ${message}</p>  
    </body>  
    </html>  

contact.jsp
    <%@taglib uri="http://www.springframework.org/tags/form" prefix="form"%>  
    <html>  
    <head>  
        <title>Spring Tiles Contact Form</title>  
    </head>  
    <body>  
    <h2>Contact Manager</h2>  
    <form:form method="post" action="addContact.html">  
      
        <table>  
        <tr>  
            <td><form:label path="firstname">First Name</form:label></td>  
            <td><form:input path="firstname" /></td>   
        </tr>  
        <tr>  
            <td><form:label path="lastname">Last Name</form:label></td>  
            <td><form:input path="lastname" /></td>  
        </tr>  
        <tr>  
            <td><form:label path="lastname">Email</form:label></td>  
            <td><form:input path="email" /></td>  
        </tr>  
        <tr>  
            <td><form:label path="lastname">Telephone</form:label></td>  
            <td><form:input path="telephone" /></td>  
        </tr>  
        <tr>  
            <td colspan="2">  
                <input type="submit" value="Add Contact"/>  
            </td>  
        </tr>  
    </table>    
          
    </form:form>  
    </body>  
    </html>  

header.jsp
    <h2>Header</h2>  
    <hr/>  

footer.jsp
    <hr/>  
    <p>Copyright  2010-2014 javatpoint.com.</p>  

menu.jsp
    <p>Menu 1</p>  
    <p>Menu 2</p>  

layout.jsp
    <%@ taglib uri="http://tiles.apache.org/tags-tiles" prefix="tiles"%>  
    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
    "http://www.w3.org/TR/html4/loose.dtd">  
    <html>  
    <head>  
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  
    <title><tiles:insertAttribute name="title" ignore="true" /></title>  
    </head>  
    <body>  
            <div><tiles:insertAttribute name="header" /></div>  
            <div style="float:left;padding:10px;width:15%;"><tiles:insertAttribute name="menu" /></div>  
            <div style="float:left;padding:10px;width:80%;border-left:1px solid pink;">  
            <tiles:insertAttribute name="body" /></div>  
            <div style="clear:both"><tiles:insertAttribute name="footer" /></div>  
      
    </body>  
    </html>  


6 :  What are benefits of using spring?

Following is the list of few of the great benefits of using Spring Framework:

    Lightweight: Spring is lightweight when it comes to size and transparency. The basic version of spring framework is around 2MB.

    Inversion of control (IOC): Loose coupling is achieved in spring using the technique Inversion of Control. The objects give their
    dependencies instead of creating or looking for dependent objects.

    Aspect oriented (AOP): Spring supports Aspect oriented programming and enables cohesive development by separating application
    business logic from system services.

    Container: Spring contains and manages the life cycle and configuration of application objects.

    MVC Framework: Spring's web framework is a well-designed web MVC framework, which provides a great alternative to web frameworks
    such as Struts or other over engineered or less popular web frameworks.

    Transaction Management: Spring provides a consistent transaction management interface that can scale down to a local transaction 
    (using a single database, for example) and scale up to global transactions (using JTA, for example).

    Exception Handling: Spring provides a convenient API to translate technology-specific exceptions (thrown by JDBC, Hibernate, or 
    JDO, for example) into consistent, unchecked exceptions


7 :  What are the different modules in Spring framework?

Following are the modules of the Spring framework:

    Core module

    Bean module

    Context module

    Expression Language module

    JDBC module

    ORM module

    OXM module

    Java Messaging Service(JMS) module

    Transaction module

    Web module

    Web-Servlet module

    Web-Struts module

    Web-Portlet module


8 : What is a Configration file.

You need to create a Bean Configuration file which is an XML file and acts as cement that glues the beans ie. classes together. This
file needs to be created under the src directory. Usually developers keep this file name as Beans.xml, but you are independent to 
choose any name you like. You have to make sure that this file is available in CLASSPATH and use the same name in main application 
while creating application context as shown in MainApp.java file.

The Beans.xml is used to assign unique IDs to different beans and to control the creation of objects with different values without 
impacting any of the Spring source files. For example, using below file you can pass any value for "message" variable and so you can
print different values of message without impacting HelloWorld.java and MainApp.java files. Let us see how it works:

<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <bean id="helloWorld" class="com.tutorialspoint.HelloWorld">
       <property name="message" value="Hello World!"/>
   </bean>

</beans>

When Spring application gets loaded into the memory, Framework makes use of the above configuration file to create all the beans 
defined and assign them a unique ID as defined in <bean> tag. You can use <property> tag to pass the values of different variables
used at the time of object creation.


9 : What is Dependency Injection?

Inversion of Control (IoC) is a general concept, and it can be expressed in many different ways and Dependency Injection is merely one concrete example of Inversion of Control.

This concept says that you do not create your objects but describe how they should be created. You don't directly connect your components and services together in code but describe
which services are needed by which components in a configuration file. A container (the IOC container) is then responsible for hooking it all up.

10 : What are the different types of IoC (dependency injection)?

Types of IoC are:

    Constructor-based dependency injection: Constructor-based DI is accomplished when the container invokes a class constructor with
					    a number of arguments, each representing a dependency on other class.

    Setter-based dependency injection: Setter-based DI is accomplished by the container calling setter methods on your beans after
				       invoking a no-argument constructor or no-argument static factory method to instantiate your
				       bean.


11 : Which DI would you suggest Constructor-based or setter-based DI?

Since you can mix both, Constructor- and Setter-based DI, it is a good rule of thumb to use constructor arguments for mandatory 
dependencies and setters for optional dependencies. Note that the use of a @Required annotation on a setter can be used to make 
setters required dependencies.


12 :  What are the benefits of IOC?

The main benefits of IOC or dependency injection are:

    It minimizes the amount of code in your application.

    It makes your application easy to test as it doesn't require any singletons or JNDI lookup mechanisms in your unit test cases.

    Loose coupling is promoted with minimal effort and least intrusive mechanism.

    IOC containers support eager instantiation and lazy loading of services.


13 :  What are types of IoC containers? Explain them.

There are two types of IoC containers:

    Bean Factory container: This is the simplest container providing basic support for DI .The BeanFactory is usually preferred where
    the resources are limited like mobile devices or applet based applications

    Spring ApplicationContext Container: This container adds more enterprise-specific functionality such as the ability to resolve 
    textual messages from a properties file and the ability to publish application events to interested event listeners.


14 : Give an example of BeanFactory implementation.

The most commonly used BeanFactory implementation is the XmlBeanFactory class. This container reads the configuration metadata from 
an XML file and uses it to create a fully configured system or application.



15 : What are the common implementations of the ApplicationContext?

The three commonly used implementation of 'Application Context' are:

    FileSystemXmlApplicationContext: This container loads the definitions of the beans from an XML file. Here you need to provide the
    full path of the XML bean configuration file to the constructor.

    ClassPathXmlApplicationContext: This container loads the definitions of the beans from an XML file. Here you do not need to 
    provide the full path of the XML file but you need to set CLASSPATH properly because this container will look bean configuration XML file in CLASSPATH.

    WebXmlApplicationContext: This container loads the XML file with definitions of all beans from within a web application.


16 : What are Spring beans?

The objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is
an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. These beans are created with the
configuration metadata that you supply to the container, for example, in the form of XML <bean/> definitions.


17 :  How do you provide configuration metadata to the Spring Container?

There are following three important methods to provide configuration metadata to the Spring Container:

    XML based configuration file.

    Annotation-based configuration

    Java-based configuration

18 : How do add a bean in spring application?

Check the following example:

<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd">

   <bean id="helloWorld" class="com.tutorialspoint.HelloWorld">
       <property name="message" value="Hello World!"/>
   </bean>

</beans>


19 : How do you define a bean scope?

When defining a <bean> in Spring, you have the option of declaring a scope for that bean. For example, to force Spring to produce a 
new bean instance each time one is needed, you should declare the bean's scope attribute to be prototype. Similar way if you want
Spring to return the same bean instance each time one is needed, you should declare the bean's scope attribute to be singleton.


20 : What bean scopes does Spring support? Explain them.

The Spring Framework supports following five scopes, three of which are available only if you use a web-aware ApplicationContext.

    singleton: This scopes the bean definition to a single instance per Spring IoC container.

    prototype: This scopes a single bean definition to have any number of object instances.

    request: This scopes a bean definition to an HTTP request. Only valid in the context of a web-aware Spring ApplicationContext.

    session: This scopes a bean definition to an HTTP session. Only valid in the context of a web-aware Spring ApplicationContext.

    global-session: This scopes a bean definition to a global HTTP session. Only valid in the context of a web-aware Spring4
    ApplicationContext.


21 : What is default scope of bean in Spring framework?

The default scope of bean is Singleton for Spring framework.



22 :  What are inner beans in Spring?

A <bean/> element inside the <property/> or <constructor-arg/> elements defines a so-called inner bean. An inner bean definition does
not require a defined id or name; the container ignores these values. It also ignores the scope flag. Inner beans are always 
anonymous and they are always scoped as prototypes.


23 : How can you inject Java Collection in Spring?

Spring offers four types of collection configuration elements which are as follows:

    <list>: This helps in wiring i.e. injecting a list of values, allowing duplicates.

    <set>: This helps in wiring a set of values but without any duplicates.

    <map>: This can be used to inject a collection of name-value pairs where name and value can be of any type.

    <props>: This can be used to inject a collection of name-value pairs where the name and value are both Strings.


24 : What are different Modes of auto wiring?

The autowiring functionality has five modes which can be used to instruct Spring container to use autowiring for dependency injection:

    no: This is default setting which means no autowiring and you should use explicit bean reference for wiring. You have nothing to 
	do special for this wiring. This is what you already have seen in Dependency Injection chapter.

    byName: Autowiring by property name. Spring container looks at the properties of the beans on which autowire attribute is set to
	    byName in the XML configuration file. It then tries to match and wire its properties with the beans defined by the same
	    names in the configuration file.

    byType: Autowiring by property datatype. Spring container looks at the properties of the beans on which autowire attribute is
	    set to byType in the XML configuration file. It then tries to match and wire a property if its type matches with exactly
	    one of the beans name in configuration file. If more than one such beans exist, a fatal exception is thrown.

    constructor: Similar to byType, but type applies to constructor arguments. If there is not exactly one bean of the constructor
		 argument type in the container, a fatal error is raised.

    autodetect: Spring first tries to wire using autowire by constructor, if it does not work, Spring tries to autowire by byType.


25 :  What are the limitations with autowiring?

Limitations of autowiring are:

    Overriding possibility: You can still specify dependencies using <constructor-arg> and <property> settings which will always 
			    override autowiring.

    Primitive data types: You cannot autowire so-called simple properties such as primitives, Strings, and Classes.

    Confusing nature: Autowiring is less exact than explicit wiring, so if possible prefer using explicit wiring.


26 :  Can you inject null and empty string values in Spring?

Yes.


27 : What does @Required annotation mean?

This annotation simply indicates that the affected bean property must be populated at configuration time, through an explicit 
property value in a bean definition or through autowiring. The container throws BeanInitializationException if the affected bean 
property has not been populated.


28 : What does @Autowired annotation mean?

The @Autowired annotation can be used to autowire bean on the setter method just like @Required annotation, constructor, a property 
or methods with arbitrary names and/or multiple arguments.


29 : What does @Qualifier annotation mean?

There may be a situation when you create more than one bean of the same type and want to wire only one of them with a property, in 
such case you can use @Qualifier annotation along with @Autowired to remove the confusion by specifying which exact bean will be 
wired.


30 : What is Spring Java Based Configuration? Give some annotation example.

Java based configuration option enables you to write most of your Spring configuration without XML but with the help of few 
Java-based annotations.

For example: Annotation @Configuration indicates that the class can be used by the Spring IoC container as a source of bean 
definitions. The @Bean annotation tells Spring that a method annotated with @Bean will return an object that should be registered as 
a bean in the Spring application context.


31 : Describe some of the standard Spring events.

Spring provides the following standard events:

    ContextRefreshedEvent: This event is published when the ApplicationContext is either initialized or refreshed. This can also be
			   raised using the refresh() method on the ConfigurableApplicationContext interface.

    ContextStartedEvent: This event is published when the ApplicationContext is started using the start() method on the 
			 configurableApplicationContext interface. You can poll your database or you can re/start any stopped application after receiving this event.

    ContextStoppedEvent: This event is published when the ApplicationContext is stopped using the stop() method on the 
			 ConfigurableApplicationContext interface. You can do required housekeep work after receiving this event.

    ContextClosedEvent: This event is published when the ApplicationContext is closed using the close() method on the 
			ConfigurableApplicationContext interface. A closed context reaches its end of life; it cannot be refreshed or
			restarted.

    RequestHandledEvent: This is a web-specific event telling all beans that an HTTP request has been serviced.


32 : What is the difference between concern and cross-cutting concern in Spring AOP?

Concern: Concern is behavior which we want to have in a module of an application. Concern may be defined as a functionality we want 
to implement. Issues in which we are interested define our concerns.

Cross-cutting concern: It's a concern which is applicable throughout the application and it affects the entire application. e.g.
logging , security and data transfer are the concerns which are needed in almost every module of an application, hence are 
cross-cutting concerns.


33 :  What is Join point?

This represents a point in your application where you can plug-in AOP aspect. You can also say, it is the actual place in the 
application where an action will be taken using Spring AOP framework.


34 : What is Advice?

This is the actual action to be taken either before or after the method execution. This is actual piece of code that is invoked 
during program execution by Spring AOP framework.


35 :  What is Pointcut?

This is a set of one or more joinpoints where an advice should be executed. You can specify pointcuts using expressions or patterns
as we will see in our AOP examples.


36 : What is Introduction?

An introduction allows you to add new methods or attributes to existing classes.


37 : What is Target object?
	
The object being advised by one or more aspects, this object will always be a proxy object. Also referred to as the advised object.


38 : What is Weaving?

Weaving is the process of linking aspects with other application types or objects to create an advised object.


39 : What are the different points where weaving can be applied?

Weaving can be done at compile time, load time, or at runtime.


40 :  How JDBC can be used more efficiently in spring framework?

JDBC can be used more efficiently with the help of a template class provided by spring framework called as JdbcTemplate.


41 :  How JdbcTemplate can be used?

With use of Spring JDBC framework the burden of resource management and error handling is reduced a lot. So it leaves developers to 
write the statements and queries to get the data to and from the database. JdbcTemplate provides many convenience methods for doing 
things such as converting database data into primitives or objects, executing prepared and callable statements, and providing custom
database error handling.


42 : What are the types of the transaction management Spring supports?

Spring supports two types of transaction management:

    Programmatic transaction management: This means that you have managed the transaction with the help of programming. That gives
					  you extreme flexibility, but it is difficult to maintain.

    Declarative transaction management: This means you separate transaction management from the business code. You only use 
					annotations or XML based configuration to manage the transactions.


43 : What is a DispatcherServlet?

The Spring Web MVC framework is designed around a DispatcherServlet that handles all the HTTP requests and responses.


44 : What is WebApplicationContext ?

The WebApplicationContext is an extension of the plain ApplicationContext that has some extra features necessary for web 
applications. It differs from a normal ApplicationContext in that it is capable of resolving themes, and that it knows which servlet
it is associated with.


45 :  What are the ways to access Hibernate by using Spring?

There are two ways to access hibernate using spring:

    Inversion of Control with a Hibernate Template and Callback.

    Extending HibernateDAOSupport and Applying an AOP Interceptor node.


46 : What are ORM's Spring supports ?

Spring supports the following ORM's :

    Hibernate

    iBatis

    JPA (Java Persistence API)

    TopLink

    JDO (Java Data Objects)

    OJB.


47 : What is spring framework? Why Java programmer should use Spring framework

Very common Spring interview question, Spring is a framework which helps Java programmer in development. Spring provides dependency 
Injection and IOC container, Spring MVC flow and several useful API for Java programmer.


48 :  Spring beans different scopes : 

In spring framework bean declared in ApplicationContext.xml can reside in five scopes:

1) Singleton (default scope)
2) prototype
3) request
4) session
5) global-session

Singleton and prototype are two common bean scope which is available on all Spring Application Context while request, session and 
global session bean scope are only available on Web aware application Context like WebApplicationContext.

Singleton bean scope is default scope for bean declared in Spring and applicable when you don't specify scope attribute while 
specifying bean details in ApplicationContext.xml or Spring configuration file. Singleton bean scope is like Singleton pattern in 
Java where only one instance of bean is created per Spring container. So no matter how many times you call getBean() method, same 
bean instance will be returned if its bean scope is declared as Singleton. While in case of prototype bean scope, every getBean() 
call creates a new instance of Spring bean. 

On the other hand request bean scope allows each HTTP request to have its own instance of bean created and supplied by Spring 
framework, while Session bean scope allows Web application to have bean instance per session basis. 
both of these bean scope are available on WebApplicationContext or any web aware application context. Last one which is global 
session bean scope is only applicable on portlet aware bean scope and allows bean instance per global session. In short Singleton vs
prototype is an important which clearly segregate one instance to multiple instances of bean.

How to specify Bean Scope in Spring Framework

In order to specify bean scope you can either use Annotation on Spring or you can define it on Application Context, for example in 
below Spring configuration file AuditService is configured as Singleton using singleton bean scope and PaymentService as prototype 
bean scope.

//bean configured on singleton bean scope
<bean id="auditService" class="com.sample.service.impl.AuditServiceImpl"  scope="singleton"/>

Since singleton is also default scope in spring framework, following declaration is exactly same and creates bean on singleton scope.

<bean id="auditService" class="com.sample.service.impl.AuditServiceImpl" />

Though I prefer explicit declaration to make bean scope loud and clear. Now every time you call getBean("auditService") it will 
return same instance of AuditService.

AuditService auditService = ApplicationContext.getBean("auditService");


//bean configured on prototype bean scope
<bean id="auditService" class="com.sample.service.impl.AuditServiceImpl"  scope="prototype"/>


In case of prototype beans cope every call to getBean("auditServie") will return different instance of AuditServiceImpl class. If you
want to use Annotation to define bean scope than you can use @Scope("singleton") or @Scope("prototype") on Bean class. you will also 
need to enable component scanning in Order to let Spring knows about bean scope. which you can do it spring 2.5 as <context:component
-scan base-package="com.sample.service.impl" />. Bean scope has not been changed from various spring version and so far two most used
 spring version spring 2.5 and spring 3.0 has only five bean scope.

Bean Scope in Spring 2.5 and Spring 3.0 is similar, all default scopes are still supported in spring 3.0 with addition of few new 
scopes like thread scope or SimpleThreadScope  which is a scope backed by thread. You can also register your own custom scope using 
CustomScopeConfigurer utility., there is no new scope for bean is introduced on spring 3.0

That’s about what is bean scope in Spring framework. Since bean creation is managed by Spring IOC container its worth remember that 
how to specify scope for a particular Bean and what is default scope of Bean which is Singleton to avoid any assumption and code 
accordingly.


49 : What is the difference between singleton and prototype bean?

This is another popular spring interview questions and an important concept to understand. Basically, a bean has scopes which define 
their existence on the application.

Singleton: means single bean definition to a single object instance per Spring IOC container.
Prototype: means a single bean definition to any number of object instances.

Whatever beans we defined in spring framework are singleton beans. There is an attribute in bean tag named ‘singleton’ if specified
true then bean becomes singleton and if set to false then the bean becomes a prototype bean. By default, it is set to true. So, all 
the beans in spring framework are by default singleton beans.

  <bean id="createNewStock"     class="springexample.stockMarket.CreateNewStockAccont" singleton=”false”>
        <property name="newBid"/>
  </bean>


50 : Does Spring singleton beans are thread-safe ?
No, Spring singleton beans are not thread-safe. Singleton doesn't mean bean would be thread-safe.


51 : What is view Resolver pattern ? how it work in Spring MVC

View Resolver pattern is a J2EE pattern which allows a web application to dynamically choose it's view technology e.g. HTML, JSP, 
Tapestry, JSF, XSLT or any other view technology. In this pattern, View resolver holds mapping of different views, controller return
name of the view, which is then passed to View Resolver for selecting an appropriate view


52 : Difference-between-setter-injection-vs-constructor-injection-spring-framework?

Use Setter injection when a number of dependencies are more or you need readability. Use Constructor Injection when Object must
be created with all of its dependency.


53 : How to load multiple spring configration files in a single project?

In a large project structure, the Spring’s bean configuration files are located in different folders for easy maintainability 
and modular. For example, Spring-Common.xml in common folder, Spring-Connection.xml in connection folder, Spring-ModuleA.xml in 
ModuleA folder…and etc.

You may load multiple Spring bean configuration files in the code :
ApplicationContext context =
    	new ClassPathXmlApplicationContext(new String[] {"Spring-Common.xml",
              "Spring-Connection.xml","Spring-ModuleA.xml"});


Put all spring xml files under project classpath.
project-classpath/Spring-Common.xml
project-classpath/Spring-Connection.xml
project-classpath/Spring-ModuleA.xml


Solution
The above ways are lack of organizing and error prone, the better way should be organized all your Spring bean configuration files 
into a single XML file. For example, create a Spring-All-Module.xml file, and import the entire Spring bean files like this :

File : Spring-All-Module.xml

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<import resource="common/Spring-Common.xml"/>
        <import resource="connection/Spring-Connection.xml"/>
        <import resource="moduleA/Spring-ModuleA.xml"/>

</beans>

Now you can load a single xml file like this :
ApplicationContext context =
    		new ClassPathXmlApplicationContext(Spring-All-Module.xml);

Put this file under project classpath.

project-classpath/Spring-All-Module.xml


54 : This Spring interview question is the first step towards Spring framework and many interviewers starts Spring interview from 
this question. As the name implies Inversion of control means now we have inverted the control of creating the object from our own 
using new operator to container or framework. Now it’s the responsibility of container to create an object as required. We maintain
one XML file where we configure our components, services, all the classes and their property. We just need to mention which service 
is needed by which component and container will create the object for us. This concept is known as dependency injection because all 
object dependency (resources) is injected into it by the framework.

Example:
  <bean id="createNewStock" class="springexample.stockMarket.CreateNewStockAccont">
        <property name="newBid"/>
  </bean>

In this example, CreateNewStockAccont class contain getter and setter for newBid and container will instantiate newBid and set the 
value automatically when it is used. This whole process is also called wiring in Spring and by using annotation it can be done 
automatically by Spring, refereed as auto-wiring of bean in Spring.


55 : What are the difference between BeanFactory and ApplicationContext in spring?

Answer: This one is very popular spring interview question and often asks in entry level interview. ApplicationContext is the 
preferred way of using spring because of functionality provided by it and interviewer wanted to check whether you are familiar with
it or not.

ApplicationContext 									BeanFactory
Here we can have more than one config files possible					In this only one config file or .xml file

Application contexts can publish events to beans that are registered as listeners	Doesn’t support.

Support internationalization (I18N) messages						It’s not

Support application life-cycle events, and validation.					Doesn’t support.

Supports  many enterprise services such JNDI access, EJB integration, remoting		Doesn’t support


56 : Difference between constructor and setter injection

There are many key differences between constructor injection and setter injection.

    Partial dependency: can be injected using setter injection but it is not possible by constructor. Suppose there are 3 properties 
			in a class, having 3 arg constructor and setters methods. In such case, if you want to pass information for
			only one property, it is possible by setter method only.

    Overriding: Setter injection overrides the constructor injection. If we use both constructor and setter injection, IOC container
		will use the setter injection.


    Changes: We can easily change the value by setter injection. It doesn't create a new bean instance always like constructor. So 
	     setter injection is flexible than constructor injection.

    More Dependeencies:  If we have more dependencies for example 15 to 20 are there in our bean class then, in this case setter 
			 injection is not recommended as we need to write almost 20 setters right, bean length will increase. 		3. In this case, Constructor injection is highly recommended, as we can inject all the dependencies with in 3 to 4 lines [i mean, by calling one constructor] 


57 : Spring MVC 3.2 Execution Flow
Step 1: First request will be received by DispatcherServlet
Step 2: DispatcherServlet will take the help of HandlerMapping and get to know the Controller class name associated with the given request
Step 3: So request transfer to the Controller, and then controller will process the request by executing appropriate methods and returns ModeAndView object (contains Model data and 
		View name) back to the DispatcherServlet
Step 4: Now DispatcherServlet send the model object to the ViewResolver to get the actual view page
Step 5: Finally DispatcherServlet will pass the Model object to the View page to display the result


Below is the one more answer related to Spring MVC 3.2 Execution Flow : 

image ' SpringMVCFlow ' for your information.
			 
1 : Front controller is the DispatcherServlet in Spring MVC. Every request will pass through this Servlet.
2 : This DispatcherServlet stores all the bean configurations loaded by the application context.
3 : It is front controller's responsiblity to identify the suitable controller class to delegate each request coming from the browser.
4 : Once controller receives the request, it will be the center point for invoking any of the business logic helper classes or DAO layer.
5 : The controller would return the view name where the response will be rendered. This view will be resolved using the content negotiations logic that is part of the Spring MVC framework.

Conclusion : 

1 : While making a request it will go to DispathherServlet which acts as Front Controller and is configured in web.xml(deployment descriptor).
2 : Based on the request URL and its parameter HandlerMapping will map your request to specific Controller class followed by which method to execute.
3 : After execution controller will return the response view by view resolver. Based on the output which page to display is handled by ViewResolver.


58 : Specifying URL Mapping for Handler Method

This is the mandatory task you must do when coding a controller class which is designed for handling one or more specific requests. Spring MVC provides the @RequestMapping annotation
which is used for specifying URL mapping. For example:

@RequestMapping("/login")
That maps the URL pattern /login to be handled by the annotated method or class. When this annotation is used at class level, the class becomes a single-action controller. 
For example:

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
 
@Controller
@RequestMapping("/hello")
public class SingleActionController {
 
    @RequestMapping(method = RequestMethod.GET)
    public String sayHello() {
        return "hello";
    }
}

When the @RequestMapping annotation is used at method level, you can have a multi-action controller. For example:

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
 
@Controller
public class UserController {
 
    @RequestMapping("/listUsers")
    public String listUsers() {
        return "ListUsers";
    }
 
    @RequestMapping("/saveUser")
    public String saveUser() {
        return "EditUser";
    }
 
    @RequestMapping("/deleteUser")
    public String deleteUser() {
        return "DeleteUser";
    }
}

The @RequestMapping annotation can be also used for specifying multiple URL patterns to be handled by a single method. For example:
@RequestMapping({"/hello", "/hi", "/greetings"})

In addition, this annotation has other properties which may be useful in some cases, e.g. the method property which is covered next.


59 : Mapping Request Parameters to Handler Method

One of cool features of Spring MVC is that, you can retrieve request parameters as regular parameters of the handler method by using the @RequestParam annotation. This is a good way 
to decouple the controller from the HttpServletRequest interface of Servlet API.

Let’s see various examples. Consider the following method:
@RequestMapping(value = "/login", method = RequestMethod.POST)
public String doLogin(@RequestParam String username,
                      @RequestParam String password) {
 
}

Spring binds the method parameters username and password to the HTTP request parameters with the same names. That means you can invoke a URL as follows (if request method is GET):
http://localhost:8080/spring/login?username=scott&password=tiger

Type conversion is also done automatically. For example, if you declare a parameter of type integer as follows:
@RequestParam int securityNumber
Then Spring will automatically convert value of the request parameter (String) to the specified type (integer) in the handler method.


In case the parameter name is different than the variable name. You can specify actual name of the parameter as follows:
@RequestParam("SSN") int securityNumber

The @RequestParam annotation also has additional 2 attributes which might be useful in some cases. The required attribute specifies whether the parameter is mandatory or not. 
For example: @RequestParam(required = false) String country
That means the parameter country is optional, hence can be missing from the request. In the above example, the variable country will be null if there is no such parameter present in 
the request.

Another attribute is defaultValue, which can be used as a fallback value when the request parameter is empty. For example: @RequestParam(defaultValue = "18") int age

Spring also allows us to access all parameters as a Map object if the method parameter is of type Map<String, String>. For example: doLogin(@RequestParam Map<String, String> params)
Then the map params contains all request parameters in form of key-value pairs.


60 : Returning Model And View

After business logic is processed, a handler method should return a view which is then resolved by the Spring’s dispatcher servlet. Spring allows us to return either a String or a 
ModelAndView object from the hander method. In the following example, the handler method returns a String represents a view named “LoginForm”.
@RequestMapping(value = "/login", method = RequestMethod.GET)
public String viewLogin() {
    return "LoginForm";
}

That’s the simplest way of returning a view name. But if you want to send additional data to the view, you must return a ModelAndView object. Consider the following handler method.
@RequestMapping("/listUsers")
public ModelAndView listUsers() {
 
    List<User> listUser = new ArrayList<>();
    // get user list from DAO...
 
    ModelAndView modelView = new ModelAndView("UserList");
    modelView.addObject("listUser", listUser);
 
    return modelView;
}
As you can see, this handler method returns a ModelAndView object that holds the view name “UserList” and a collection of User objects which can be used in the view.

Spring is also very flexible, as you can declare the ModelAndView object as a parameter of the handler method instead of creating a new one. Thus, the above example can be re-written
as follows:
@RequestMapping("/listUsers")
public ModelAndView listUsers(ModelAndView modelView) {
 
    List<User> listUser = new ArrayList<>();
    // get user list from DAO...
 
    modelView.setViewName("UserList");
    modelView.addObject("listUser", listUser);
 
    return modelView;
}


61 : Putting Objects into the Model

In an application that follows the MVC architecture, the controller (C) should pass data into the model (M) which is then used in the view (V). As we see in the previous example, the 
addObject() method of the ModelAndView class is for putting an object to the model, in form of name-value pair:
modelView.addObject("listUser", listUser);
modelView.addObject("siteName", new String("CodeJava.net"));
modelView.addObject("users", 1200000);

Again, Spring is very flexible. You can declare a parameter of type Map in the handler method, Spring uses this map to store objects for the model. Let’s see another example:
@RequestMapping(method = RequestMethod.GET)
public String viewStats(Map<String, Object> model) {
    model.put("siteName", "CodeJava.net");
    model.put("pageviews", 320000);
 
    return "Stats";
}

This is even simpler than using ModelAndView object. Depending on your taste, you can use either Map or ModelAndView object. Thanks for the flexibility of Spring.


62 : Redirection in Handler Method

In case you want to redirect the user to another URL if a condition is met, just append redirect:/ before the URL. The following code snippet gives an example:
// check login status....
 
if (!isLogin) {
    return new ModelAndView("redirect:/login");
}
 
 
// return a list of Users


63 : Autowiring Business Classes in the Controller?.

64 : Accessing HttpServletRequest and HttpServletResponse

In some cases, you need to directly access the HttpServletRequest or HttpServletResponse objects within a handler method. By the flexibility of Spring, just add relevant parameter to 
the handler method. For example:
@RequestMapping("/download")
public String doDownloadFile(
        HttpServletRequest request, HttpServletResponse response) {
 
    // access the request
 
    // access the response
 
    return "DownloadPage";
}
Spring detects and automatically injects the HttpServletRequest and HttpServletResponse objects into the method. Then you can access the request and response such as getting
InputStream, OutputStream or returning a specific HTTP code.


65 : Following the Single Responsibility Principle
Finally, there are two good practices you should follow when designing and coding controllers in Spring MVC:
A controller class should not execute business logic. Instead, it should delegate business processing to relevant business classes. This keeps the controller focusing on its designed 
responsibility is to control workflows of the application. For example:
@Controller
public class UserController {
 
    @Autowired
    private UserDAO userDAO;
 
    public String listUser() {
        // handler method to list all users
        userDAO.list();
    }
 
    public String saveUser(User user) {
        // handler method to save/update a user
        userDAO.save(user);
    }
 
    public String deleteUser(User user) {
        // handler method to delete a user
        userDAO.delete(user);
    }
 
    public String getUser(int userId) {
        // handler method to get a user
        userDAO.get(userId);
    }
}
 
Create each separate controller for each business domain. For example, UserController for controlling workflows of the user management, OrderController for controlling workflows of 
order processing, etc. For example:

@Controller
public class UserController {
 
}
 
 
@Controller
public class ProductController {
 
}
 
@Controller
public class OrderController {
 
}
 
@Controller
public class PaymentController {
 
}
 
So far we have shared 14 tips that help you write controller classes in Spring MVC properly and efficiently.


66 : Difference between Spring Core and Spring MVC.

Spring Core
Spring is a framework which helps to connect different components together. There are many modules for IOC, AOP, Web MVC etc.Spring Framework is an open source application framework 
and inversion of control container for the Java platform.

Spring MVC
Spring MVC (Model–view–controller) is one component within the whole Spring Framework, to support development of web applications.


67 : What is DispatcherServlet and ContextLoaderListener?

Spring’s web MVC framework is, like many other web MVC frameworks, request-driven, designed around a central Servlet that handles all the HTTP requests and responses. Spring’s 
DispatcherServlet however, does more than just that. It is completely integrated with the Spring IoC container so it allows you to use every feature that Spring has.

After receiving an HTTP request, DispatcherServlet consults the HandlerMapping (configuration files) to call the appropriate Controller. The Controller takes the request and calls 
the appropriate service methods and set model data and then returns view name to the DispatcherServlet. The DispatcherServlet will take help from ViewResolver to pickup the defined view for the request. Once view is finalized, The DispatcherServlet passes the model data to the view which is finally rendered on the browser.

<web-app>
  <display-name>Archetype Created Web Application</display-name>
   
  <servlet>
        <servlet-name>spring</servlet-name>
            <servlet-class>
                org.springframework.web.servlet.DispatcherServlet
            </servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
 
    <servlet-mapping>
        <servlet-name>spring</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
     
</web-app>
By default, DispatcherServlet loads its configuration file using <servlet_name>-servlet.xml. E.g. with above web.xml file, DispatcherServlet will try to find spring-servlet.xml file
in classpath.


ContextLoaderListener reads the spring configuration file (with value given against “contextConfigLocation” in web.xml), parse it and loads the beans defined in that config 
file. e.g.

<servlet>
    <servlet-name>spring</servlet-name>
    <servlet-class>
        org.springframework.web.servlet.DispatcherServlet
    </servlet-class>
     
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/applicationContext.xml</param-value>
    </init-param>
     
    <load-on-startup>1</load-on-startup>
</servlet>

68 : What is the front controller class of Spring MVC?

A front controller is defined as “a controller which handles all requests for a Web Application.” DispatcherServlet (actually a servlet) is the front controller in Spring MVC that
intercepts every request and then dispatches/forwards requests to an appropriate controller.

When a web request is sent to a Spring MVC application, dispatcher servlet first receives the request. Then it organizes the different components configured in Spring’s web 
application context (e.g. actual request handler controller and view resolvers) or annotations present in the controller itself, all needed to handle the request.


69 : Difference between applicationContext.xml and spring-servlet.xml in Spring

The applicationContext.xml defines the beans for the "root webapp context", i.e. the context associated with the webapp. 

The spring-servlet.xml (or whatever else you call it) defines the beans for one servlet's app context. There can be many of these in a webapp, one per Spring servlet (e.g. spring1
-servlet.xml for servlet spring1, spring2-servlet.xml for servlet spring2). Beans in spring-servlet.xml can reference beans in applicationContext.xml, but not vice versa. 

All Spring MVC controllers must go in the spring-servlet.xml context. 

In most simple cases, the applicationContext.xml context is unnecessary. It is generally used to contain beans that are shared between all servlets in a webapp. If you only have one
servlet, then there's not really much point, unless you have a specific use for it. 


70 : Example of <context:annotation-config> vs <context:component-scan>.

I will elaborate both tags in detail with some examples which will make more sense to us. For keeping the example to simple, I am creating just 3 beans, and I will try to configure
them in configuration file in various ways, then we will see the difference between various configurations in console where output will get printed.

For reference, below are 3 beans. BeanA has reference to BeanB and BeanC additionally.
package com.howtodoinjava.beans;
 
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
 
@SuppressWarnings("unused")
@Component
public class BeanA {
     
    private BeanB beanB;
    private BeanC beanC;
     
    public BeanA(){
        System.out.println("Creating bean BeanA");
    }
 
    @Autowired
    public void setBeanB(BeanB beanB) {
        System.out.println("Setting bean reference for BeanB");
        this.beanB = beanB;
    }
 
    @Autowired
    public void setBeanC(BeanC beanC) {
        System.out.println("Setting bean reference for BeanC");
        this.beanC = beanC;
    }
}
 

//Bean B
package com.howtodoinjava.beans;
 
import org.springframework.stereotype.Component;
 
@Component
public class BeanB {
    public BeanB(){
        System.out.println("Creating bean BeanB");
    }
}
 

//Bean C
package com.howtodoinjava.beans;
 
import org.springframework.stereotype.Component;
 
@Component
public class BeanC {
    public BeanC(){
        System.out.println("Creating bean BeanC");
    }
}


BeanDemo class is used to load and initialize the application context.
package com.howtodoinjava.test;
 
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
 
public class BeanDemo {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("classpath:beans.xml");
    }
}

Now let’s start writing the configuration file "beans.xml" with variations. I will be omitting the schema declarations in below examples, to keep focus on configuration itself.

a) Define only bean tags
<bean id="beanA" class="com.howtodoinjava.beans.BeanA"></bean>
<bean id="beanB" class="com.howtodoinjava.beans.BeanB"></bean>
<bean id="beanC" class="com.howtodoinjava.beans.BeanC"></bean>
 
Output:
 
Creating bean BeanA
Creating bean BeanB
Creating bean BeanC
In this case, all 3 beans are created and no dependency in injected in BeanA because we didn’t used any property/ref attributes.

b) Define bean tags and property ref attributes
<bean id="beanA" class="com.howtodoinjava.beans.BeanA">
    <property name="beanB" ref="beanB"></property>
    <property name="beanC" ref="beanC"></property>
</bean>
<bean id="beanB" class="com.howtodoinjava.beans.BeanB"></bean>
<bean id="beanC" class="com.howtodoinjava.beans.BeanC"></bean>
 
Output:
 
Creating bean BeanA
Creating bean BeanB
Creating bean BeanC
Setting bean reference for BeanB
Setting bean reference for BeanC
Now the beans are created and injected as well. No wonder.

c) Using only <context:annotation-config />
<context:annotation-config />
 
//No Output
As I told already, <context:annotation-config /> activate the annotations only on beans which have already been discovered and registered. Here, we have not discovered any bean so
nothing happened.

d) Using <context:annotation-config /> with bean declarations
<context:annotation-config />
<bean id="beanA" class="com.howtodoinjava.beans.BeanA"></bean>
<bean id="beanB" class="com.howtodoinjava.beans.BeanB"></bean>
<bean id="beanC" class="com.howtodoinjava.beans.BeanC"></bean>
 
Output:
 
Creating bean BeanA
Creating bean BeanB
Setting bean reference for BeanB
Creating bean BeanC
Setting bean reference for BeanC
In above configuration, we have discovered the beans using <bean> tags. Now when we use <context:annotation-config />, it simply activates @Autowired annotation and bean injection
inside BeanA happens.

e) Using only <context:component-scan />
<context:component-scan base-package="com.howtodoinjava.beans" />
 
Output:
 
Creating bean BeanA
Creating bean BeanB
Setting bean reference for BeanB
Creating bean BeanC
Setting bean reference for BeanC
Above configuration does both things as I mentioned earlier in start of post. It does the bean discovery (searches for @Component annotation in base package) and then activates the
additional annotations (e.g. Autowired).

f) Using both <context:component-scan /> and <context:annotation-config />
<context:annotation-config />
<context:component-scan base-package="com.howtodoinjava.beans" />
<bean id="beanA" class="com.howtodoinjava.beans.BeanA"></bean>
<bean id="beanB" class="com.howtodoinjava.beans.BeanB"></bean>
<bean id="beanC" class="com.howtodoinjava.beans.BeanC"></bean>
 
Output:
 
Creating bean BeanA
Creating bean BeanB
Setting bean reference for BeanB
Creating bean BeanC
Setting bean reference for BeanC
Strange !! With above configuration we are discovering beans two times and activating annotations two times as well. But output got printed one time only. Why? Because spring is 
intelligent enough to register any configuration processing only once if it is registered multiple tiles using same or different ways. Cool !!

So, Here i am ending this tutorial and hoping that it will give a more clear picture to you guys when you use these tags in your next project.


71 : Spring @Component, @Repository, @Service and @Controller Annotations

With @Component, @Repository, @Service and @Controller annotations in place and after enabling automatic component scanning, spring will 
automatically import the beans into the container so you don’t have to define them explicitly with XML. These annotations are called Stereotype annotations as well.

Before jumping to example use of these annotations, let’s learn quick facts about these annotations which will help you in making a better decision about when to use which annotation.
@Component, @Repository, @Service and @Controller annotations

1) The @Component annotation marks a java class as a bean so the component-scanning mechanism of spring can pick it up and pull it into the application context. To use this 
annotation, apply it over class as below:

@Component
public class EmployeeDAOImpl implements EmployeeDAO {
    ...
}

2) Although above use of @Component is good enough but you can use more suitable annotation that provides additional benefits specifically for DAOs i.e. @Repository annotation. 
The @Repository annotation is a specialization of the @Component annotation with similar use and functionality. In addition to importing the DAOs into the DI container, it also makes
 the unchecked exceptions (thrown from DAO methods) eligible for translation into Spring DataAccessException.

3) The @Service annotation is also a specialization of the component annotation. It doesn’t currently provide any additional behavior over the @Component annotation, but it’s a good
 idea to use @Service over @Component in service-layer classes because it specifies intent better. 

4) @Controller annotation marks a class as a Spring Web MVC controller. It too is a @Component specialization, so beans marked with it are automatically imported into the DI 
container. When you add the @Controller annotation to a class, you can use another annotation i.e. @RequestMapping; to map URLs to instance methods of a class.

In real life, you will face very rare situations where you will need to use @Component annotation. Most of the time, you will using @Repository, @Service and @Controller annotations. 
@Component should be used when your class does not fall into either of three categories i.e. controller, manager and dao. If you want to define name of the bean with which they will 
be registered in DI container, you can pass the name in annotation itself e.g. @Service (“employeeManager”).

 
How to enable component scanning

Above four annotation will be scanned and configured only when they are scanned by DI container of spring framework. To enable this scanning, you will need to use 
“context:component-scan” tag in your applicationContext.xml file. e.g.

<context:component-scan base-package="com.howtodoinjava.demo.service" />
<context:component-scan base-package="com.howtodoinjava.demo.dao" />
<context:component-scan base-package="com.howtodoinjava.demo.controller" />
The context:component-scan element requires a base-package attribute, which, as its name suggests, specifies a starting point for a recursive component search. You may not want to
give your top package for scanning to spring, so you should declare three component-scan elements, each with a base-package attribute pointing to a different package.

When component-scan is declared, you no longer need to declare context:annotation-config, because autowiring is implicitly enabled when component scanning is enabled.


How to use @Component, @Repository, @Service and @Controller Annotations

As I already said that you use @Repository, @Service and @Controller annotations over DAO, manager and controller classes. But in real life, at DAO and manager layer we often have 
separate classes and interfaces. Interface for defining the contract, and classes for defining the implementations of contracts. Where to use these annotations? Let’s find out.
Always use these annotations over concrete classes; not over interfaces. Once you have these stereotype annotations on beans, you can directly use bean references defined inside 
concrete classes. Note the references are of type interfaces. Spring DI container is smart enough to inject the correct instance in this case.

EmployeeDAO.java and EmployeeDAOImpl.java

public interface EmployeeDAO 
{
    public EmployeeDTO createNewEmployee();
}
 
@Repository ("employeeDao")
public class EmployeeDAOImpl implements EmployeeDAO
{
    public EmployeeDTO createNewEmployee()
    {
        EmployeeDTO e = new EmployeeDTO();
        e.setId(1);
        e.setFirstName("Lokesh");
        e.setLastName("Gupta");
        return e;
    }
}
EmployeeManager.java and EmployeeManagerImpl.java

public interface EmployeeManager 
{
    public EmployeeDTO createNewEmployee();
}
 
 
@Service ("employeeManager")
public class EmployeeManagerImpl implements EmployeeManager
{
    @Autowired
    EmployeeDAO dao;
     
    public EmployeeDTO createNewEmployee()
    {
        return dao.createNewEmployee();
    }
}
EmployeeController.java

@Controller ("employeeController")
public class EmployeeController 
{
        @Autowired
    EmployeeManager manager;
     
    public EmployeeDTO createNewEmployee()
    {
        return manager.createNewEmployee();
    }
}
EmployeeDTO.java

public class EmployeeDTO {
 
    private Integer id;
    private String firstName;
    private String lastName;
 
    public Integer getId() {
        return id;
    }
 
    public void setId(Integer id) {
        this.id = id;
    }
 
    public String getFirstName() {
        return firstName;
    }
 
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
 
    public String getLastName() {
        return lastName;
    }
 
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
 
    @Override
    public String toString() {
        return "Employee [id=" + id + ", firstName=" + firstName
                + ", lastName=" + lastName + "]";
    }
}
Let’s test the above configuration and annotations:

TestSpringContext.java

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
 
import com.howtodoinjava.demo.service.EmployeeManager;
 
public class TestSpringContext 
{
    public static void main(String[] args) 
    {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
 
        //EmployeeManager manager = (EmployeeManager) context.getBean(EmployeeManager.class);
         
        //OR this will also work
         
        EmployeeController controller = (EmployeeController) context.getBean("employeeController");
         
        System.out.println(controller.createNewEmployee());
    }
}
 
Output:
 
Jan 22, 2015 6:17:57 PM org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh
INFO: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@1b2b2f7f: 
startup date [Thu Jan 22 18:17:57 IST 2015]; root of context hierarchy
Jan 22, 2015 6:17:57 PM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
 
INFO: Loading XML bean definitions from class path resource [applicationContext.xml]
 
Employee [id=1, firstName=Lokesh, lastName=Gupta]


72 : What is a MultipartResolver and when its used?

Spring comes with MultipartResolver to handle file upload in web application. There are two concrete implementations included in Spring:
CommonsMultipartResolver for Jakarta Commons FileUpload
StandardServletMultipartResolver for Servlet 3.0 Part API

To define an implementation, create a bean with the id “multipartResolver” in a DispatcherServlet’s application context. If a DispatcherServlet detects a multipart request, it will 
resolve it via the configured MultipartResolver and pass on a wrapped HttpServletRequest. Controllers can then cast their given request to the MultipartHttpServletRequest interface, 
which permits access to any MultipartFiles.


How to upload file in Spring MVC Application?

Let’s say we are going to use CommonsMultipartResolver which uses the Apache commons upload library to handle the file upload in a form. So you will need to add the 
commons-fileupload.jar and commons-io.jar dependencies.

<!-- Apache Commons Upload -->
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.2.2</version>
</dependency>
 
<!-- Apache Commons Upload -->
<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>1.3.2</version>
</dependency>
The following declaration needs to be made in the application context file to enable the MultipartResolver (along with including necessary jar file in the application):

<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <!-- one of the properties available; the maximum file size in bytes -->
    <property name="maxUploadSize" value="100000"/>
</bean>
Now create model class FileUploadForm which will hold the multipart data submitted from HTML form.


import org.springframework.web.multipart.MultipartFile;
public class FileUploadForm 
{
    private MultipartFile file;
 
    public MultipartFile getFile() {
        return file;
    }
 
    public void setFile(MultipartFile file) {
        this.file = file;
    }

}


Now create FileUploadController class which will actually handle the upload logic.
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.multipart.MultipartFile;
import com.howtodoinjava.form.FileUploadForm;
 
@Controller
public class FileUploadController 
{
    @RequestMapping(value = "/upload", method = RequestMethod.POST)
    public String save(@ModelAttribute("uploadForm") FileUploadForm uploadForm, Model map) {
 
        MultipartFile multipartFile = uploadForm.getFile();
 
        String fileName = "default.txt";
 
        if (multipartFile != null) {
            fileName = multipartFile.getOriginalFilename();
        }
         
        //read and store the file as you like
 
        map.addAttribute("files", fileName);
        return "file_upload_success";
    }
}
The upload JSP file looks like this:

<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form"%>
<html>
<body>
    <h2>Spring MVC file upload example</h2>
    <form:form method="post" action="save.html" modelAttribute="uploadForm" enctype="multipart/form-data">
        Please select a file to upload : <input type="file" name="file" />
        <input type="submit" value="upload" />
        <span><form:errors path="file" cssClass="error" /></span>
    </form:form>
</body>
</html>


73 : Validation example from Spring MVC.

Spring supports validations primarily into two ways.

Using JSR-303 Annotations and any reference implementation e.g. Hibernate Validator
Using custom implementation of org.springframework.validation.Validator interface

In next question, you see an example about how to use validation support in spring MVC application.


How to validate form data in Spring Web MVC Framework?

Spring MVC supports validation by means of a validator object that implements the Validator interface. You need to create a class and implement Validator interface. In this custom
validator class, you use utility methods such as rejectIfEmptyOrWhitespace() and rejectIfEmpty() in the ValidationUtils class to validate the required form fields.

@Component
public class EmployeeValidator implements Validator
{
    public boolean supports(Class clazz) {
        return EmployeeVO.class.isAssignableFrom(clazz);
    }
  
    public void validate(Object target, Errors errors)
    {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "error.firstName", "First name is required.");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "lastName", "error.lastName", "Last name is required.");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "email", "error.email", "Email is required.");
    }
}

If any of form fields is empty, these methods will create a field error and bind it to the field. The second argument of these methods is the property name, while the third and 
fourth are the error code and default error message.

To activate this custom validator as a spring managed bean, you need to do one of following things:

1) Add @Component annotation to EmployeeValidator class and activate annotation scanning on the package containing such declarations.
<context:component-scan base-package="com.howtodoinjava.demo" />

2) Alternatively, you can register the validator class bean directly in context file.
<bean id="employeeValidator" class="com.howtodoinjava.demo.validator.EmployeeValidator" />


More information you can see from Spring MVC CRUD example.


74 : What is Spring MVC Interceptor and how to use it?

As you know about servlet filters that they can pre-handle and post-handle every web request they serve — before and after it’s handled by that servlet. In the similar way, you can 
use HandlerInterceptor interface in your spring mvc application to pre-handle and post-handle web requests that are handled by Spring MVC controllers. These handlers are mostly used
to manipulate the model attributes returned/submitted they are passed to the views/controllers.

A handler interceptor can be registered for particular URL mappings, so it only intercepts requests mapped to certain URLs. Each handler interceptor must implement the 
HandlerInterceptor interface, which contains three callback methods for you to implement: preHandle(), postHandle() and afterCompletion().

preHandle() : Before a request is handled by a request handler.
postHandle() : After a request is handled by a request handler. It gives access to the returned ModelAndView object, so you can manipulate the model attributes in it.
afterCompletion() : After the completion of all request processing i.e. after the view has been rendered.

Problem with HandlerInterceptor interface is that your new class will have to implement all three methods irrespective of whether it is needed or not. To avoid overriding, you can 
use HandlerInterceptorAdapter class. This class implements HandlerInterceptor and provide default blank implementations. So whatever methods you want to override in your handler, you 
can extend it from HandlerInterceptorAdapter.


HandlerInterceptor Interface Example

I am reusing the code created for Spring MVC hello world application here. I am creating a CustomRequestHandler class. Methods of this class (i.e. preHandle(), postHandle() and 
afterCompletion()) will be called as per above discussion.

package com.howtodoinjava.demo.handlers;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
 
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
 
public class CustomRequestHandler extends HandlerInterceptorAdapter
{
 
    public boolean preHandle(HttpServletRequest request,
                                HttpServletResponse response,
                                Object handler)
                throws Exception
    {
        long startTime = System.currentTimeMillis();
        request.setAttribute("startTime", startTime);
        return true;
    }
 
    public void postHandle( HttpServletRequest request,
                            HttpServletResponse response,
                            Object handler,
                            ModelAndView modelAndView)
                throws Exception
    {
        long startTime = (Long) request.getAttribute("startTime");
        request.removeAttribute("startTime");
 
        long endTime = System.currentTimeMillis();
        modelAndView.addObject("totalTime", endTime - startTime);
         
        System.out.println("Request Prcessing Time :: " + (endTime - startTime));
    }
 
    public void afterCompletion( HttpServletRequest request,
                                    HttpServletResponse response,
                                    Object handler,
                                    Exception exceptionIfAny)
                    throws Exception
    {
        System.out.println("View Rendered !!");
    }
}

Now when you have created your request handler, it must be declared into spring configuration file so that spring can pass requests to it at appropriate time. A handler interceptor 
is registered to the DefaultAnnotationHandlerMapping bean, which is charged with applying interceptors to any class marked with a @Controller annotation. You can specify multiple 
interceptors in the interceptors property, whose type is an array.

<bean id="customRequestHandler" class="com.howtodoinjava.demo.handlers.CustomRequestHandler" />
 
<bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter" />
     
<bean class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping">
    <property name="interceptors">
        <list>
            <ref bean="customRequestHandler" />
        </list>
    </property>
</bean>
Now when you run the hello world application again, it will print below output.

Request Precessing Time :: 15
View Rendered !!


Applying HandlerInterceptor Interface to certain URLs only

Well, using above approach you handler will be applied on all controllers in your application irrespective of what URLs they are mapped to. If you want to map your handler to certain
URL only then you will have to use <mvc:interceptors>> tag.

<mvc:interceptors>
    <mvc:interceptor>
        <mvc:mapping path="/somepath_one/*"/>
        <ref bean="customRequestHandler_one" />
    </mvc:interceptor>
    <mvc:interceptor>
        <mvc:mapping path="/somepath_two/*"/>
        <ref bean="customRequestHandler_two" />
    </mvc:interceptor>
</mvc:interceptors>


75 : How to handle exceptions in Spring MVC Framework?

In a Spring MVC application, you can register one or more exception resolver beans in the web application context to resolve uncaught exceptions. These beans have to implement the 
HandlerExceptionResolver interface for DispatcherServlet to auto-detect them. Spring MVC comes with a simple exception resolver for you to map each category of exceptions to a 
view i.e. SimpleMappingExceptionResolver to map each category of exceptions to a view in a configurable way.

Let’s say we have an exception class i.e. AuthException. And we want that everytime this exception is thrown from anywhere into application, we want to show a pre-determined view 
page /WEB-INF/views/error/authExceptionView.jsp. So the configuration would be.

<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
    <property name="exceptionMappings">
        <props>
            <prop key="com.howtodoinjava.demo.exception.AuthException">
                error/authExceptionView
            </prop>
        </props>
    </property>
    <property name="defaultErrorView" value="error/genericView"/>
</bean>
The “defaultErrorView” property can be configured to show a generic message for all other exceptions which are not configured inside “exceptionMappings” list.


76 : Spring MVC SimpleMappingExceptionResolver Example
 
In some badly coded applications, when an unknown exception occurs then application server usually displays the evil exception stack trace to the user in webpage itself. In this case,
users have nothing to do with this stack trace and complain that your application is not user friendly. Moreover, it can also prove a potential security risk, as you are exposing the
internal method call hierarchy to users. Though a web application’s web.xml can be configured to display friendly JSP pages in case an HTTP error or class exception occur, Spring MVC
supports a more robust approach to managing views for class exceptions.


HandlerExceptionResolver and SimpleMappingExceptionResolver

In a Spring MVC application, you can register one or more exception resolver beans in the web application context to resolve uncaught exceptions. These beans have to implement the 
HandlerExceptionResolver interface for DispatcherServlet to auto-detect them. Spring MVC comes with such a simple exception resolver i.e. SimpleMappingExceptionResolver to map each 
category of exceptions to a view in a configurable way.

Let’s say we have an exception class i.e. AuthException. And we want that everytime this exception is thrown from anywhere into application, we want to show a pre-determined view 
page /WEB-INF/views/error/authExceptionView.jsp. So the configuration would be.


SimpleMappingExceptionResolver configuration

<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
    <property name="exceptionMappings">
        <props>
            <prop key="com.howtodoinjava.demo.exception.AuthException">
                error/authExceptionView
            </prop>
        </props>
    </property>
    <property name="defaultErrorView" value="error/genericView"/>
</bean>


The complete context configuration is :
applicationContext.xml

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/context/
        http://www.springframework.org/schema/context/spring-context-3.0.xsd">
 
    <context:component-scan base-package="com.howtodoinjava.demo" />
 
    <bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter" />
    <bean class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping" />
     
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/views/" />
        <property name="suffix" value=".jsp" />
    </bean>
     
    <bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
        <property name="basename" value="messages" />
    </bean>
     
    <bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
        <property name="exceptionMappings">
            <props>
                <prop key="com.howtodoinjava.demo.exception.AuthException">
                    error/authExceptionView
                </prop>
            </props>
        </property>
        <property name="defaultErrorView" value="error/genericView"/>
    </bean>
 
</beans>

Notice the “defaultErrorView” property in last. If spring context detects any exception thrown from application which is not listed into “exceptionMappings” properties list, then it
will render the view /WEB-INF/views/error/genericView.jsp.


 
Test SimpleMappingExceptionResolver Configured Application

For testing purpose, let’s create AuthException.java.


AuthException.java
package com.howtodoinjava.demo.exception;
 
import java.util.Date;
 
public class AuthException extends RuntimeException 
{
    private static final long serialVersionUID = 1L;
     
    private Date date;
    private String message;
     
    public AuthException(Date date, String message) {
        super();
        this.date = date;
        this.message = message;
    }
 
    public Date getDate() {
        return date;
    }
 
    public String getMessage() {
        return message;
    }
 
    @Override
    public String toString() {
        return "AuthException [date=" + date + ", message=" + message + "]";
    }
}


And throw this exception from any controller.
EmployeeController.java
@Controller
@RequestMapping("/employee-module")
public class EmployeeController 
{
    @RequestMapping(value="/getAllEmployees", method = RequestMethod.GET)
    public String welcome(Model model) 
    {
        throw new AuthException(new Date(), "Something bad happened dude !! Run Away :-(");
    }
}


And create two jsp files in path /WEB-INF/views/error/

authExceptionView.jsp
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<html>
    <head>
        <title>Authentication Exception</title>
    </head>
     
    <body>
 
        <h2>Exception occured at: </h2><fmt:formatDate value="${exception.date}" pattern="yyyy-MM-dd" />
        <h2>Exception Message   : </h2>${exception.message}
    </body>
</html>


genericView.jsp
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt"%>
<html>
    <head>
        <title>Generic Exception</title>
    </head>
    <body>
        <h2>Some generic error message</h2>
    </body>
</html>

Now throw any other exception from controller such as NullPointerException as below.

@Controller
@RequestMapping("/employee-module")
public class EmployeeController 
{
    @RequestMapping(value="/getAllEmployees", method = RequestMethod.GET)
    public String welcome(Model model) 
    {
        throw new NullPointerException();
    }
}


77 : Give examples of important Spring MVC annotations?

Important Spring MVC annotations are listed below.
@Controller : This class would serve as a controller.
@RequestMapping : Can be used on a class or a method. Maps an url on the class (or method).
@PathVariable : Used to map a dynamic value in the url to a method argument.


78 : How do you integrate Spring MVC with tiles?


79 : What is the importance of Spring bean configuration file?

We use Spring Bean configuration file to define all the beans that will be initialized by Spring Context. When we create the instance of Spring ApplicationContext, it reads the 
spring bean xml file and initialize all of them. Once the context is initialized, we can use it to get different bean instances.

Apart from Spring Bean configuration, this file also contains spring MVC interceptors, view resolvers and other elements to support annotations based configurations.


80 : What are different ways to configure a class as Spring Bean?

There are three different ways to configure Spring Bean.

(1) : XML Configuration: This is the most popular configuration and we can use bean element in context file to configure a Spring Bean. For example:
<bean name="myBean" class="com.journaldev.spring.beans.MyBean"></bean>

(2) : Annotation Based Configuration: We can also use @Component, @Service, @Repository and @Controller annotations with classes to configure them to be as spring bean. For these, we 
would need to provide base package location to scan for these classes. For example:
<context:component-scan base-package="com.journaldev.spring" />


81 : Spring Aware Interfaces

Sometimes we need Spring Framework objects in our beans to perform some operations, for example reading ServletConfig and ServletContext parameters or to know the bean definitions 
loaded by the ApplicationContext. That’s why spring framework provides a bunch of *Aware interfaces that we can implement in our bean classes.

org.springframework.beans.factory.Aware is the root marker interface for all these Aware interfaces. All of the *Aware interfaces are sub-interfaces of Aware and declare a single
setter method to be implemented by the bean. Then spring context uses setter-based dependency injection to inject the corresponding objects in the bean and make it available for our
use.

Spring Aware interfaces are similar to servlet listeners with callback methods and implementing observer design pattern.

Some of the important Aware interfaces are:
ApplicationContextAware – to inject ApplicationContext object, example usage is to get the array of bean definition names.
BeanFactoryAware – to inject BeanFactory object, example usage is to check scope of a bean.
BeanNameAware – to know the bean name defined in the configuration file.
ResourceLoaderAware – to inject ResourceLoader object, example usage is to get the input stream for a file in the classpath.
ServletContextAware – to inject ServletContext object in MVC application, example usage is to read context parameters and attributes.
ServletConfigAware – to inject ServletConfig object in MVC application, example usage is to get servlet config parameters.


82 : What is a Controller in Spring MVC?

Just like MVC design pattern, Controller is the class that takes care of all the client requests and send them to the configured resources to handle it. In Spring MVC,
org.springframework.web.servlet.DispatcherServlet is the front controller class that initializes the context based on the spring beans configurations.

A Controller class is responsible to handle different kind of client requests based on the request mappings. We can create a controller class by using @Controller annotation. 
Usually it’s used with @RequestMapping annotation to define handler methods for specific URI mapping.


83 : What are the minimum configurations needed to create Spring MVC application?

For creating a simple Spring MVC application, we would need to do following tasks.

(1) : Configure DispatcherServlet in the web.xml file to handle requests through spring container.
(2) : Spring bean configuration file to define beans, if using annotations then it has to be configured here. Also we need to configure view resolver for view pages.
(3) : Controller class with request mappings defined to handle the client requests.
Above steps should be enough to create a simple Spring MVC Hello World application


84 : How would you relate Spring MVC Framework to MVC architecture?

As the name suggests Spring MVC is built on top of Model-View-Controller architecture. DispatcherServlet is the Front Controller in the Spring MVC application that takes care of all 
the incoming requests and delegate it to different controller handler methods.

Model can be any Java Bean in the Spring Framework, just like any other MVC framework Spring provides automatic binding of form data to java beans. We can set model beans as 
attributes to be used in the view pages.

View Pages can be JSP, static HTMLs etc. and view resolvers are responsible for finding the correct view page. Once the view page is identified, control is given back to the 
DispatcherServlet controller. DispatcherServlet is responsible for rendering the view and returning the final response to the client.


85 : What are some of the important Spring annotations you have used?

Some of the Spring annotations that I have used in my project are:

@Controller – for controller classes in Spring MVC project.
@RequestMapping – for configuring URI mapping in controller handler methods. This is a very important annotation, so you should go through Spring MVC RequestMapping Annotation 
Examples.
@ResponseBody – for sending Object as response, usually for sending XML or JSON data as response.
@PathVariable – for mapping dynamic values from the URI to handler method arguments.
@Autowired – for autowiring dependencies in spring beans.
@Qualifier – with @Autowired annotation to avoid confusion when multiple instances of bean type is present.
@Service – for service classes.
@Scope – for configuring scope of the spring bean.
@Configuration, @ComponentScan and @Bean – for java based configurations.
AspectJ annotations for configuring aspects and advices, @Aspect, @Before, @After, @Around, @Pointcut etc.


86 : What is Spring DAO?

Spring DAO support is provided to work with data access technologies like JDBC, Hibernate in a consistent and easy way. For example we have JdbcDaoSupport, HibernateDaoSupport, 
JdoDaoSupport and JpaDaoSupport for respective technologies.

Spring DAO also provides consistency in exception hierarchy and we don’t need to catch specific exceptions.


87 : Spring 3 JavaConfig example

Since Spring 3, JavaConfig features are included in core Spring module, it allow developer to move bean definition and Spring configuration out of XML file 
into Java class. But, you are still allow to use the classic XML way to define beans and configuration, the JavaConfig is just another alternative solution.
See the different between classic XML definition and JavaConfig to define a bean in Spring container.


Spring XML file :

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

	<bean id="helloBean" class="com.mkyong.hello.impl.HelloWorldImpl">

</beans>


Equivalent configuration in JavaConfig :
package com.mkyong.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import com.mkyong.hello.HelloWorld;
import com.mkyong.hello.impl.HelloWorldImpl;

@Configuration
public class AppConfig {

    @Bean(name="helloBean")
    public HelloWorld helloWorld() {
        return new HelloWorldImpl();
    }

}


Spring JavaConfig Hello World
Now, see a full Spring JavaConfig example.

 
1. Dependency Library
To use JavaConfig (@Configuration), you need to include CGLIB library. See dependencies :

<!-- Spring 3 dependencies -->
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-core</artifactId>
	<version>${spring.version}</version>
</dependency>

<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-context</artifactId>
	<version>${spring.version}</version>
</dependency>

<!-- JavaConfig need this library -->
<dependency>
	<groupId>cglib</groupId>
	<artifactId>cglib</artifactId>
	<version>2.2.2</version>
</dependency>


2. Spring Bean
A simple bean.

package com.mkyong.hello;

public interface HelloWorld {

	void printHelloWorld(String msg);

}


3. package com.mkyong.hello.impl;

import com.mkyong.hello.HelloWorld;

public class HelloWorldImpl implements HelloWorld {

	@Override
	public void printHelloWorld(String msg) {

		System.out.println("Hello : " + msg);
	}

}
4. JavaConfig Annotation
Annotate with @Configuration to tell Spring that this is the core Spring configuration file, and define bean via @Bean.

package com.mkyong.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import com.mkyong.hello.HelloWorld;
import com.mkyong.hello.impl.HelloWorldImpl;

@Configuration
public class AppConfig {

    @Bean(name="helloBean")
    public HelloWorld helloWorld() {
        return new HelloWorldImpl();
    }

}
5. Run it
Load your JavaConfig class with AnnotationConfigApplicationContext.

package com.mkyong.core;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import com.mkyong.config.AppConfig;
import com.mkyong.hello.HelloWorld;

public class App {
	public static void main(String[] args) {

            ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
	    HelloWorld obj = (HelloWorld) context.getBean("helloBean");

	    obj.printHelloWorld("Spring3 Java Config");

	}
}
Output

Hello : Spring3 Java Config


88 : Spring 3 JavaConfig @Import example

Normally, you will split a large Spring XML bean files into multiple small files, group by module or category, to make things more maintainable and modular. For example,

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<import resource="config/customer.xml"/>
        <import resource="config/scheduler.xml"/>

</beans>


In Spring3 JavaConfig, the equivalent functionality is @Import.

package com.mkyong.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@Import({ CustomerConfig.class, SchedulerConfig.class })
public class AppConfig {

}


@Import Example
See a full example of using JavaConfig @Import.

File : CustomerBo.java

package com.mkyong.core;

public class CustomerBo {

	public void printMsg(String msg) {

		System.out.println("CustomerBo : " + msg);
	}

}
File : SchedulerBo.java

package com.mkyong.core;

public class SchedulerBo {

	public void printMsg(String msg) {

		System.out.println("SchedulerBo : " + msg);
	}

}
1. @Configuration example
Now, use JavaConfig @Configuration to declare above beans.

2. File : CustomerConfig.java

package com.mkyong.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.mkyong.core.CustomerBo;

@Configuration
public class CustomerConfig {

	@Bean(name="customer")
	public CustomerBo customerBo(){

		return new CustomerBo();

	}
}
3. File : SchedulerConfig.java

package com.mkyong.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import com.mkyong.core.SchedulerBo;

@Configuration
public class SchedulerConfig {

	@Bean(name="scheduler")
	public SchedulerBo suchedulerBo(){

		return new SchedulerBo();

	}

}
4. @Import example
Use @Import to load multiple configuration files.

File : AppConfig.java

package com.mkyong.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@Import({ CustomerConfig.class, SchedulerConfig.class })
public class AppConfig {

}
5. Run it
Load the main configuration file , and test it.

package com.mkyong.core;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import com.mkyong.config.AppConfig;

public class App {
	public static void main(String[] args) {

		ApplicationContext context = new AnnotationConfigApplicationContext(
				AppConfig.class);

		CustomerBo customer = (CustomerBo) context.getBean("customer");
		customer.printMsg("Hello 1");

		SchedulerBo scheduler = (SchedulerBo) context.getBean("scheduler");
		scheduler.printMsg("Hello 2");

	}
}
Output

CustomerBo : Hello 1
SchedulerBo : Hello 2


89 : Constructor injection type ambiguities in Spring

In Spring framework, when your class contains multiple constructors with same number of arguments, it will always cause the constructor injection argument type ambiguities issue.

Problem
Let’s see this customer bean example. It contains two constructor methods, both accept 3 arguments with different data type.

package com.mkyong.common;

public class Customer
{
	private String name;
	private String address;
	private int age;

	public Customer(String name, String address, int age) {
		this.name = name;
		this.address = address;
		this.age = age;
	}

	public Customer(String name, int age, String address) {
		this.name = name;
		this.age = age;
		this.address = address;
	}
	//getter and setter methods
	public String toString(){
		return " name : " +name + "\n address : "
               + address + "\n age : " + age;
	}

}
In Spring bean configuration file, pass a ‘mkyong’ for name, ‘188’ for address and ’28’ for age.

<!--Spring-Customer.xml-->
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="CustomerBean" class="com.mkyong.common.Customer">

		<constructor-arg>
			<value>mkyong</value>
		</constructor-arg>

		<constructor-arg>
			<value>188</value>
		</constructor-arg>

		<constructor-arg>
			<value>28</value>
		</constructor-arg>
        </bean>

</beans>
Run it, what’s your expected result?

package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App
{
    public static void main( String[] args )
    {
    	ApplicationContext context =
    	  new ClassPathXmlApplicationContext(new String[] {"Spring-Customer.xml"});

    	Customer cust = (Customer)context.getBean("CustomerBean");
    	System.out.println(cust);
    }
}
Output

name : mkyong
address : 28
age : 188
The result is not what we expected, the second constructor is run, instead of the first constructor. In Spring, the argument type ‘188’ is capable convert to int, so Spring just 
convert it and take the second constructor, even you assume it should be a String.

In addition, if Spring can’t resolve which constructor to use, it will prompt following error message

constructor arguments specified but no matching constructor
found in bean 'CustomerBean' (hint: specify index and/or
type arguments for simple parameters to avoid type ambiguities)

 
Solution
To fix it, you should always specify the exact data type for constructor, via type attribute like this :

<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="CustomerBean" class="com.mkyong.common.Customer">

		<constructor-arg type="java.lang.String">
			<value>mkyong</value>
		</constructor-arg>

		<constructor-arg type="java.lang.String">
			<value>188</value>
		</constructor-arg>

		<constructor-arg type="int">
			<value>28</value>
		</constructor-arg>

	</bean>

</beans>
Run it again, now you get what you expected.

Output

name : mkyong
address : 188
age : 28


90 : Spring bean reference example

In Spring, beans can “access” to each other by specify the bean references in the same or different bean configuration file.

1. Bean in different XML files
If you are referring to a bean in different XML file, you can reference it with a ‘ref‘ tag, ‘bean‘ attribute.

<ref bean="someBean"/>
In this example, the bean “OutputHelper” declared in ‘Spring-Common.xml‘ can access to other beans in ‘Spring-Output.xml‘ – “CsvOutputGenerator” or “JsonOutputGenerator“, by using a 
‘ref’ attribute in property tag.

File : Spring-Common.xml

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="OutputHelper" class="com.mkyong.output.OutputHelper">
		<property name="outputGenerator" >
			<ref bean="CsvOutputGenerator"/>
		</property>
	</bean>

</beans>
File : Spring-Output.xml

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="CsvOutputGenerator" class="com.mkyong.output.impl.CsvOutputGenerator" />
	<bean id="JsonOutputGenerator" class="com.mkyong.output.impl.JsonOutputGenerator" />

</beans>

 
2. Bean in same XML file
If you are referring to a bean in same XML file, you can reference it with ‘ref‘ tag, ‘local‘ attribute.

<ref local="someBean"/>
In this example, the bean “OutputHelper” declared in ‘Spring-Common.xml‘ can access to each other “CsvOutputGenerator” or “JsonOutputGenerator“.

File : Spring-Common.xml

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="OutputHelper" class="com.mkyong.output.OutputHelper">
		<property name="outputGenerator" >
			<ref local="CsvOutputGenerator"/>
		</property>
	</bean>

	<bean id="CsvOutputGenerator" class="com.mkyong.output.impl.CsvOutputGenerator" />
	<bean id="JsonOutputGenerator" class="com.mkyong.output.impl.JsonOutputGenerator" />

</beans>


91 : How to inject value into bean properties in Spring

In Spring, there are three ways to inject value into bean properties.

Normal way
Shortcut
“p” schema
See a simple Java class, which contains two properties – name and type. Later you will use Spring to inject value into the bean properties.

package com.mkyong.common;

public class FileNameGenerator
{
	private String name;
	private String type;

	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getType() {
		return type;
	}
	public void setType(String type) {
		this.type = type;
	}
}
1. Normal way
Inject value within a ‘value’ tag and enclosed with ‘property’ tag.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="FileNameGenerator" class="com.mkyong.common.FileNameGenerator">
		<property name="name">
			<value>mkyong</value>
		</property>
		<property name="type">
			<value>txt</value>
		</property>
	</bean>
</beans>

 
2. Shortcut
Inject value with “value” attribute.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="FileNameGenerator" class="com.mkyong.common.FileNameGenerator">
		<property name="name" value="mkyong" />
		<property name="type" value="txt" />
	</bean>

</beans>

 
3. “p” schema
Inject value by using “p” schema as an attributes.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:p="http://www.springframework.org/schema/p"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="FileNameGenerator" class="com.mkyong.common.FileNameGenerator"
             p:name="mkyong" p:type="txt" />

</beans>
Remember declares the xmlns:p=”http://www.springframework.org/schema/p in the Spring XML bean configuration file.

Conclusion
Which methods to use is totally base on personal preference, it will not affect the value inject into the bean properties.


92 : How to load multiple Spring bean configuration file


Problem
In a large project structure, the Spring’s bean configuration files are located in different folders for easy maintainability and modular. For example, Spring-Common.xml in common folder, Spring-Connection.xml in connection folder, Spring-ModuleA.xml in ModuleA folder…and etc.

You may load multiple Spring bean configuration files in the code :

ApplicationContext context =
    	new ClassPathXmlApplicationContext(new String[] {"Spring-Common.xml",
              "Spring-Connection.xml","Spring-ModuleA.xml"});
Put all spring xml files under project classpath.

project-classpath/Spring-Common.xml
project-classpath/Spring-Connection.xml
project-classpath/Spring-ModuleA.xml

 
Solution
The above ways are lack of organizing and error prone, the better way should be organized all your Spring bean configuration files into a single XML file. For example, create a 
Spring-All-Module.xml file, and import the entire Spring bean files like this :

File : Spring-All-Module.xml
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<import resource="common/Spring-Common.xml"/>
        <import resource="connection/Spring-Connection.xml"/>
        <import resource="moduleA/Spring-ModuleA.xml"/>

</beans>
Now you can load a single xml file like this :

ApplicationContext context =
    		new ClassPathXmlApplicationContext(Spring-All-Module.xml);
Put this file under project classpath.

project-classpath/Spring-All-Module.xml
Note
In Spring3, the alternative solution is using JavaConfig @Import.


93 : Spring inner bean examples


In Spring framework, whenever a bean is used for only one particular property, it’s advise to declare it as an inner bean. And the inner bean is supported both in setter injection 
‘property‘ and constructor injection ‘constructor-arg‘.

See a detail example to demonstrate the use of Spring inner bean.

package com.mkyong.common;

public class Customer
{
	private Person person;

	public Customer(Person person) {
		this.person = person;
	}

	public void setPerson(Person person) {
		this.person = person;
	}

	@Override
	public String toString() {
		return "Customer [person=" + person + "]";
	}
}
package com.mkyong.common;

public class Person
{
	private String name;
	private String address;
	private int age;

	//getter and setter methods

	@Override
	public String toString() {
		return "Person [address=" + address + ",
                               age=" + age + ", name=" + name + "]";
	}
}
Often times, you may use ‘ref‘ attribute to reference the “Person” bean into “Customer” bean, person property as following :

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="CustomerBean" class="com.mkyong.common.Customer">
		<property name="person" ref="PersonBean" />
	</bean>

	<bean id="PersonBean" class="com.mkyong.common.Person">
		<property name="name" value="mkyong" />
		<property name="address" value="address1" />
		<property name="age" value="28" />
	</bean>

</beans>
In general, it’s fine to reference like this, but since the ‘mkyong’ person bean is only used for Customer bean only, it’s better to declare this ‘mkyong’ person as an inner bean as
 following :

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="CustomerBean" class="com.mkyong.common.Customer">
		<property name="person">
			<bean class="com.mkyong.common.Person">
				<property name="name" value="mkyong" />
				<property name="address" value="address1" />
				<property name="age" value="28" />
			</bean>
		</property>
	</bean>
</beans>
This inner bean also supported in constructor injection as following :

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="CustomerBean" class="com.mkyong.common.Customer">
		<constructor-arg>
			<bean class="com.mkyong.common.Person">
				<property name="name" value="mkyong" />
				<property name="address" value="address1" />
				<property name="age" value="28" />
			</bean>
		</constructor-arg>
	</bean>
</beans>
Note
The id or name value in bean class is not necessary in an inner bean, it will simply ignored by the Spring container.
Run it

package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App
{
    public static void main( String[] args )
    {
    	ApplicationContext context =
    	  new ClassPathXmlApplicationContext(new String[] {"Spring-Customer.xml"});

    	Customer cust = (Customer)context.getBean("CustomerBean");
    	System.out.println(cust);

    }
}
Output

Customer [person=Person [address=address1, age=28, name=mkyong]]


94 : Spring bean scopes example


In Spring, bean scope is used to decide which type of bean instance should be return from Spring container back to the caller.

5 types of bean scopes supported :

singleton – Return a single bean instance per Spring IoC container
prototype – Return a new bean instance each time when requested
request – Return a single bean instance per HTTP request. *
session – Return a single bean instance per HTTP session. *
globalSession – Return a single bean instance per global HTTP session. *
In most cases, you may only deal with the Spring’s core scope – singleton and prototype, and the default scope is singleton.

P.S * means only valid in the context of a web-aware Spring ApplicationContext

Singleton vs Prototype
Here’s an example to show you what’s the different between bean scope : singleton and prototype.

package com.mkyong.customer.services;

public class CustomerService
{
	String message;

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}
}

 
1. Singleton example
If no bean scope is specified in bean configuration file, default to singleton.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

       <bean id="customerService"
            class="com.mkyong.customer.services.CustomerService" />

</beans>
Run it

package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.mkyong.customer.services.CustomerService;

public class App
{
    public static void main( String[] args )
    {
    	ApplicationContext context =
    	 new ClassPathXmlApplicationContext(new String[] {"Spring-Customer.xml"});

    	CustomerService custA = (CustomerService)context.getBean("customerService");
    	custA.setMessage("Message by custA");
    	System.out.println("Message : " + custA.getMessage());

    	//retrieve it again
    	CustomerService custB = (CustomerService)context.getBean("customerService");
    	System.out.println("Message : " + custB.getMessage());
    }
}
Output

Message : Message by custA
Message : Message by custA
Since the bean ‘customerService’ is in singleton scope, the second retrieval by ‘custB’ will display the message set by ‘custA’ also, even it’s retrieve by a new getBean() method. In singleton, only a single instance per Spring IoC container, no matter how many time you retrieve it with getBean(), it will always return the same instance.


 
2. Prototype example
If you want a new ‘customerService’ bean instance, every time you call it, use prototype instead.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

   <bean id="customerService" class="com.mkyong.customer.services.CustomerService"
         scope="prototype"/>

</beans>
Run it again

Message : Message by custA
Message : null
In prototype scope, you will have a new instance for each getBean() method called.

3. Bean scopes annotation
You can also use annotation to define your bean scope.

package com.mkyong.customer.services;

import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Service;

@Service
@Scope("prototype")
public class CustomerService
{
	String message;

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}
}
Enable auto component scanning

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
	http://www.springframework.org/schema/context
	http://www.springframework.org/schema/context/spring-context-2.5.xsd">

       <context:component-scan base-package="com.mkyong.customer" />

</beans>


95 : Spring ListFactoryBean example


The ‘ListFactoryBean‘ class provides developer a way to create a concrete List collection class (ArrayList and LinkedList) in Spring’s bean configuration file.

Here’s a ListFactoryBean example, it will instantiate an ArrayList at runtime, and inject it into a bean property.

package com.mkyong.common;

import java.util.List;

public class Customer
{
	private List lists;
	//...
}
Spring’s bean configuration file.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="CustomerBean" class="com.mkyong.common.Customer">
		<property name="lists">
			<bean class="org.springframework.beans.factory.config.ListFactoryBean">
				<property name="targetListClass">
					<value>java.util.ArrayList</value>
				</property>
				<property name="sourceList">
					<list>
						<value>1</value>
						<value>2</value>
						<value>3</value>
					</list>
				</property>
			</bean>
		</property>
	</bean>

</beans>
Alternatively, you also can use util schema and <util:list> to achieve the same thing.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
	http://www.springframework.org/schema/util
	http://www.springframework.org/schema/util/spring-util-2.5.xsd">

	<bean id="CustomerBean" class="com.mkyong.common.Customer">
		<property name="lists">
			<util:list list-class="java.util.ArrayList">
				<value>1</value>
				<value>2</value>
				<value>3</value>
			</util:list>
		</property>
	</bean>

</beans>
Remember to include the util schema, else you will hit the following error

Caused by: org.xml.sax.SAXParseException:
	The prefix "util" for element "util:list" is not bound.
Run it…

package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext(
				"SpringBeans.xml");

		Customer cust = (Customer) context.getBean("CustomerBean");
		System.out.println(cust);

	}
}
Ouput

Customer [lists=[1, 2, 3]] Type=[class java.util.ArrayList]
You have instantiated ArrayList and injected it into Customer’s lists property at runtime


96 : Spring SetFactoryBean example


The ‘SetFactoryBean‘ class provides developer a way to create a concrete Set collection (HashSet and TreeSet) in Spring’s bean configuration file.

Here’s a ListFactoryBean example, it will instantiate an HashSet at runtime, and inject it into a bean property

package com.mkyong.common;

import java.util.Set;

public class Customer
{
	private Set sets;
	//...
}
Spring’s bean configuration file.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="CustomerBean" class="com.mkyong.common.Customer">
		<property name="sets">
			<bean class="org.springframework.beans.factory.config.SetFactoryBean">
				<property name="targetSetClass">
					<value>java.util.HashSet</value>
				</property>
				<property name="sourceSet">
					<list>
						<value>1</value>
						<value>2</value>
						<value>3</value>
					</list>
				</property>
			</bean>
		</property>
	</bean>

</beans>
Alternatively, you also can use util schema and <util:set> to achieve the same thing.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
	http://www.springframework.org/schema/util
	http://www.springframework.org/schema/util/spring-util-2.5.xsd">

	<bean id="CustomerBean" class="com.mkyong.common.Customer">
		<property name="sets">
			<util:set set-class="java.util.HashSet">
				<value>1</value>
				<value>2</value>
				<value>3</value>
			</util:set>
		</property>
	</bean>

</beans>
Remember to include the util schema, else you will hit the following error

Caused by: org.xml.sax.SAXParseException:
	The prefix "util" for element "util:set" is not bound.
Run it…

package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App
{
    public static void main( String[] args )
    {
    	ApplicationContext context = new ClassPathXmlApplicationContext("SpringBeans.xml");

    	Customer cust = (Customer)context.getBean("CustomerBean");
    	System.out.println(cust);

    }
}
Ouput

Customer [sets=[3, 2, 1]] Type=[class java.util.HashSet]
You have instantiated HashSet and and injected it into Customer’s sets property at runtime


97 : Spring MapFactoryBean example


The ‘MapFactoryBean‘ class provides developer a way to create a concrete Map collection class (HashMap and TreeMap) in Spring’s bean configuration file.

Here’s a MapFactoryBean example, it will instantiate a HashMap at runtime,, and inject it into a bean property.

package com.mkyong.common;

import java.util.Map;

public class Customer
{
	private Map maps;
	//...
}
Spring’s bean configuration file.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="CustomerBean" class="com.mkyong.common.Customer">
		<property name="maps">
			<bean class="org.springframework.beans.factory.config.MapFactoryBean">
				<property name="targetMapClass">
					<value>java.util.HashMap</value>
				</property>
				<property name="sourceMap">
					<map>
						<entry key="Key1" value="1" />
						<entry key="Key2" value="2" />
						<entry key="Key3" value="3" />
					</map>
				</property>
			</bean>
		</property>
	</bean>

</beans>
Alternatively, you also can use util schema and <util:map> to achieve the same thing.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
	http://www.springframework.org/schema/util
	http://www.springframework.org/schema/util/spring-util-2.5.xsd">

	<bean id="CustomerBean" class="com.mkyong.common.Customer">
		<property name="maps">
			<util:map map-class="java.util.HashMap">
				<entry key="Key1" value="1" />
				<entry key="Key2" value="2" />
				<entry key="Key3" value="3" />
			</util:map>
		</property>
	</bean>

</beans>
Remember to include the util schema, else you will hit the following error

Caused by: org.xml.sax.SAXParseException:
	The prefix "util" for element "util:map" is not bound.
Run it…

package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App
{
    public static void main( String[] args )
    {
    	ApplicationContext context = new ClassPathXmlApplicationContext("SpringBeans.xml");

    	Customer cust = (Customer)context.getBean("CustomerBean");
    	System.out.println(cust);

    }
}
Ouput

Customer [maps={Key2=2, Key1=1, Key3=3}] Type=[class java.util.HashMap]
You have instantiated a HashMap and injected it into Customer’s map property at runtime.


98 : Spring inject Date into bean property – CustomDateEditor

Spring example to show you how to inject a “Date” into bean property.

package com.mkyong.common;

import java.util.Date;

public class Customer {

	Date date;

	public Date getDate() {
		return date;
	}

	public void setDate(Date date) {
		this.date = date;
	}

	@Override
	public String toString() {
		return "Customer [date=" + date + "]";
	}

}
Bean configuration file

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="customer" class="com.mkyong.common.Customer">
		<property name="date" value="2010-01-31" />
	</bean>

</beans>
Run it

package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext(
				"SpringBeans.xml");

		Customer cust = (Customer) context.getBean("customer");
		System.out.println(cust);

	}
}
You will encounter follow error messages :

Caused by: org.springframework.beans.TypeMismatchException:
	Failed to convert property value of type [java.lang.String] to
	required type [java.util.Date] for property 'date';

nested exception is java.lang.IllegalArgumentException:
	Cannot convert value of type [java.lang.String] to
	required type [java.util.Date] for property 'date':
	no matching editors or conversion strategy found
Solution
In Spring, you can inject a Date via two methods :


 
1. Factory bean
Declare a dateFormat bean, in “customer” bean, reference “dateFormat” bean as a factory bean. The factory method will call SimpleDateFormat.parse() to convert String into Date 
object automatically.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="dateFormat" class="java.text.SimpleDateFormat">
		<constructor-arg value="yyyy-MM-dd" />
	</bean>

	<bean id="customer" class="com.mkyong.common.Customer">
		<property name="date">
			<bean factory-bean="dateFormat" factory-method="parse">
				<constructor-arg value="2010-01-31" />
			</bean>
		</property>
	</bean>

</beans>

99 : Spring PropertyPlaceholderConfigurer example


Often times, most Spring developers just put the entire deployment details (database details, log file path) in XML bean configuration file as following :

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="customerDAO" class="com.mkyong.customer.dao.impl.JdbcCustomerDAO">

		<property name="dataSource" ref="dataSource" />
	</bean>

	<bean id="customerSimpleDAO" class="com.mkyong.customer.dao.impl.SimpleJdbcCustomerDAO">

		<property name="dataSource" ref="dataSource" />
	</bean>

	<bean id="dataSource"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">

		<property name="driverClassName" value="com.mysql.jdbc.Driver" />
		<property name="url" value="jdbc:mysql://localhost:3306/mkyongjava" />
		<property name="username" value="root" />
		<property name="password" value="password" />
	</bean>

</beans>
But, in a corporate environment, deployment detail is usually only can ‘touch’ by your system or database administrator, they just refuse to access your bean
configuration file directly, and they will request a separate file for deployment configuration, for example, a simple properties, with deployment detail only.

PropertyPlaceholderConfigurer example
To fix it, you can use PropertyPlaceholderConfigurer class to externalize the deployment details into a properties file, and access from bean configuration 
file via a special format – ${variable}.

Create a properties file (database.properties), include your database details, put it into your project class path.

jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mkyongjava
jdbc.username=root
jdbc.password=password
Declare a PropertyPlaceholderConfigurer in bean configuration file and map to the ‘database.properties‘ properties file you created just now.

<bean
	class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">

	<property name="location">
		<value>database.properties</value>
	</property>
</bean>
Full example

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean
		class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">

		<property name="location">
			<value>database.properties</value>
		</property>
	</bean>

	<bean id="customerDAO" class="com.mkyong.customer.dao.impl.JdbcCustomerDAO">

		<property name="dataSource" ref="dataSource" />
	</bean>

	<bean id="customerSimpleDAO"
                class="com.mkyong.customer.dao.impl.SimpleJdbcCustomerDAO">

		<property name="dataSource" ref="dataSource" />
	</bean>

	<bean id="dataSource"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">

		<property name="driverClassName" value="${jdbc.driverClassName}" />
		<property name="url" value="${jdbc.url}" />
		<property name="username" value="${jdbc.username}" />
		<property name="password" value="${jdbc.password}" />
	</bean>

</beans>
Alternative usage
You also can use PropertyPlaceholderConfigurer to share some constant variables to all other beans. For example, define your log file location in a properties
file, and access the properties value from different beans configuration files via ${log.filepath}


100 : Spring bean configuration inheritance


In Spring, the inheritance is supported in bean configuration for a bean to share common values, properties or configurations.

A child bean or inherited bean can inherit its parent bean configurations, properties and some attributes. In additional, the child beans are allow to override
the inherited value.

See following full example to show you how bean configuration inheritance works in Spring.

package com.mkyong.common;

public class Customer {

	private int type;
	private String action;
	private String Country;

	//...

}
Bean configuration file

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="BaseCustomerMalaysia" class="com.mkyong.common.Customer">
		<property name="country" value="Malaysia" />
	</bean>

	<bean id="CustomerBean" parent="BaseCustomerMalaysia">
		<property name="action" value="buy" />
		<property name="type" value="1" />
	</bean>

</beans>
Above is a ‘BaseCustomerMalaysia’ bean contains a ‘Malaysia’ value for country property, and the ‘CustomerBean’ bean inherited this value from its parent 
(‘BaseCustomerMalaysia’).

Run it

package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App
{
    public static void main( String[] args )
    {
    	ApplicationContext context =
			new ClassPathXmlApplicationContext("SpringBeans.xml");

    	Customer cust = (Customer)context.getBean("CustomerBean");
    	System.out.println(cust);

    }
}
output

Customer [type=1, action=buy, Country=Malaysia]
The ‘CustomerBean’ bean just inherited the country property from its parent (‘BaseCustomerMalaysia’).

Inheritance with abstract
In above example, the ‘BaseCustomerMalaysia’ is still able to instantiate, for example,

Customer cust = (Customer)context.getBean("BaseCustomerMalaysia");
If you want to make this base bean as a template and not allow others to instantiate it, you can add an ‘abstract‘ attribute in the <bean> element. For
 example

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="BaseCustomerMalaysia" class="com.mkyong.common.Customer" abstract="true">
		<property name="country" value="Malaysia" />
	</bean>

	<bean id="CustomerBean" parent="BaseCustomerMalaysia">
		<property name="action" value="buy" />
		<property name="type" value="1" />
	</bean>

</beans>
Now, the ‘BaseCustomerMalaysia’ bean is a pure template, for bean to inherit it only, if you try to instantiate it, you will encounter the following error 
message.

Customer cust = (Customer)context.getBean("BaseCustomerMalaysia");
org.springframework.beans.factory.BeanIsAbstractException:
	Error creating bean with name 'BaseCustomerMalaysia':
	Bean definition is abstract

 
Pure Inheritance Template
Actually, parent bean is not necessary to define class attribute, often times, you may just need a common property for sharing. Here’s is an example

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="BaseCustomerMalaysia" abstract="true">
		<property name="country" value="Malaysia" />
	</bean>

	<bean id="CustomerBean" parent="BaseCustomerMalaysia"
	    class="com.mkyong.common.Customer">

		<property name="action" value="buy" />
		<property name="type" value="1" />
	</bean>

</beans>
In this case, the ‘BaseCustomerMalaysia’ bean is a pure template, to share its ‘country’ property only.


 
Overrride it
However, you are still allow to override the inherited value by specify the new value in the child bean. Let’s see this example

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="BaseCustomerMalaysia" class="com.mkyong.common.Customer" abstract="true">
		<property name="country" value="Malaysia" />
	</bean>

	<bean id="CustomerBean" parent="BaseCustomerMalaysia">
	    <property name="country" value="Japan" />
		<property name="action" value="buy" />
		<property name="type" value="1" />
	</bean>

</beans>
The ‘CustomerBean’ bean is just override the parent (‘BaseCustomerMalaysia’) country property, from ‘Malaysia’ to ‘Japan’.

Customer [Country=Japan, action=buy, type=1]
Conclusion
The Spring bean configuration inheritance is very useful to avoid the repeated common value or configurations for multiple beans.


101 : Spring properties dependency checking


In Spring,you can use dependency checking feature to make sure the required properties have been set or injected.

Dependency checking modes
4 dependency checking modes are supported:

none – No dependency checking.
simple – If any properties of primitive type (int, long,double…) and collection types (map, list..) have not been set, UnsatisfiedDependencyException will be
thrown.
objects – If any properties of object type have not been set, UnsatisfiedDependencyException will be thrown.
all – If any properties of any type have not been set, an UnsatisfiedDependencyException
will be thrown.
P.S The default mode is none


 
Example
A Customer and Person object for the demonstration.

package com.mkyong.common;

public class Customer
{
	private Person person;
	private int type;
	private String action;

	//getter and setter methods
}
package com.mkyong.common;

public class Person
{
	private String name;
	private String address;
	private int age;

	//getter and setter methods
}

 
1. none dependency checking
Spring bean configuration file with ‘none’ dependency checking mode.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="CustomerBean" class="com.mkyong.common.Customer" >
		<property name="action" value="buy" />
	</bean>

	<bean id="PersonBean" class="com.mkyong.common.Person">
		<property name="name" value="mkyong" />
		<property name="address" value="address ABC" />
		<property name="age" value="29" />
	</bean>

</beans>
If you did not explicitly define the dependency checking mode, it’s default to ‘none’. No dependency checking will perform.

2. simple dependency checking
Spring bean configuration file with ‘simple’ dependency checking mode.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="CustomerBean" class="com.mkyong.common.Customer"
         dependency-check="simple">

		<property name="person" ref="PersonBean" />
		<property name="action" value="buy" />
	</bean>

	<bean id="PersonBean" class="com.mkyong.common.Person">
		<property name="name" value="mkyong" />
		<property name="address" value="address ABC" />
		<property name="age" value="29" />
	</bean>

</beans>
The ‘type’ property (primitive type or collection types) have not been set, an UnsatisfiedDependencyException will throw.

org.springframework.beans.factory.UnsatisfiedDependencyException:
Error creating bean with name 'CustomerBean'
defined in class path resource [config/Spring-Customer.xml]:
Unsatisfied dependency expressed through bean property 'type':
Set this property value or disable dependency checking for this bean.
3. objects dependency checking
Spring bean configuration file with ‘objects’ dependency checking mode.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="CustomerBean" class="com.mkyong.common.Customer"
         dependency-check="objects">

		<property name="action" value="buy" />
		<property name="type" value="1" />
	</bean>

	<bean id="PersonBean" class="com.mkyong.common.Person">
		<property name="name" value="mkyong" />
		<property name="address" value="address ABC" />
		<property name="age" value="29" />
	</bean>

</beans>
The ‘person’ property (objects type) have not been set, an UnsatisfiedDependencyException will throw.

org.springframework.beans.factory.UnsatisfiedDependencyException:
Error creating bean with name 'CustomerBean'
defined in class path resource [config/Spring-Customer.xml]:
Unsatisfied dependency expressed through bean property 'person':
Set this property value or disable dependency checking for this bean.
4. all dependency checking
Spring bean configuration file with ‘all’ dependency checking mode.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="CustomerBean" class="com.mkyong.common.Customer"
         dependency-check="all">

		<property name="action" value="buy" />
	</bean>

	<bean id="PersonBean" class="com.mkyong.common.Person">
		<property name="name" value="mkyong" />
		<property name="address" value="address ABC" />
		<property name="age" value="29" />
	</bean>

</beans>
The combination of ‘simple’ and ‘objects’ mode, if any properties of any type (primitive, collection and object) have not been set, an 
UnsatisfiedDependencyException will be thrown.

Global default dependency checking
Explicitly define the dependency checking mode for every beans is tedious and error prone, you can set a default-dependency-check attribute in the <beans> root
 element to force the entire beans declared within <beans> root element to apply this rule. However, this root default mode will be overridden by a bean’s own mode if specified.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"
	default-dependency-check="all">

	<bean id="CustomerBean" class="com.mkyong.common.Customer">
		<property name="action" value="buy" />
		<property name="type" value="1" />
	</bean>

	<bean id="PersonBean" class="com.mkyong.common.Person">
		<property name="name" value="mkyong" />
		<property name="address" value="address ABC" />
		<property name="age" value="29" />
	</bean>

</beans>
All beans declared in this configuration file are default to ‘all’ dependency checking mode.


102 : Spring dependency checking with @Required Annotation

Spring’s dependency checking in bean configuration file is used to make sure all properties of a certain types (primitive, collection or object) have been set.
In most scenarios, you just need to make sure a particular property has been set, but not all properties.

For this case, you need @Required annotation, see following example :

@Required example
A Customer object, apply @Required in setPerson() method to make sure the person property has been set.

package com.mkyong.common;

import org.springframework.beans.factory.annotation.Required;

public class Customer
{
	private Person person;
	private int type;
	private String action;

	public Person getPerson() {
		return person;
	}
	@Required
	public void setPerson(Person person) {
		this.person = person;
	}
}
Simply apply the @Required annotation will not enforce the property checking, you also need to register an RequiredAnnotationBeanPostProcessor to aware of the 
@Required annotation in bean configuration file.

The RequiredAnnotationBeanPostProcessor can be enabled in two ways.

1. Include <context:annotation-config />

Add Spring context and <context:annotation-config /> in bean configuration file.

<beans
	...
	xmlns:context="http://www.springframework.org/schema/context"
	...
	http://www.springframework.org/schema/context
	http://www.springframework.org/schema/context/spring-context-2.5.xsd">
	...
	<context:annotation-config />
	...
</beans>
Full example,

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
	http://www.springframework.org/schema/context
	http://www.springframework.org/schema/context/spring-context-2.5.xsd">

	<context:annotation-config />

	<bean id="CustomerBean" class="com.mkyong.common.Customer">
		<property name="action" value="buy" />
		<property name="type" value="1" />
	</bean>

	<bean id="PersonBean" class="com.mkyong.common.Person">
		<property name="name" value="mkyong" />
		<property name="address" value="address ABC" />
		<property name="age" value="29" />
	</bean>

</beans>
2. Include RequiredAnnotationBeanPostProcessor

Include ‘RequiredAnnotationBeanPostProcessor’ directly in bean configuration file.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

<bean
class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"/>

	<bean id="CustomerBean" class="com.mkyong.common.Customer">
		<property name="action" value="buy" />
		<property name="type" value="1" />
	</bean>

	<bean id="PersonBean" class="com.mkyong.common.Person">
		<property name="name" value="mkyong" />
		<property name="address" value="address ABC" />
		<property name="age" value="29" />
	</bean>

</beans>
If you run it , the following error message will be throw, because person property is unset.

org.springframework.beans.factory.BeanInitializationException:
	Property 'person' is required for bean 'CustomerBean'

 
Conclusion
Try @Required annotation, it is more flexible than dependency checking in XML file, because it can apply to a particular property only.


103 : Define custom @Required-style annotation in Spring


The @Required annotation is used to make sure a particular property has been set. If you are migrate your existing project to Spring framework or have your own
@Required-style annotation for whatever reasons, Spring is allow you to define your custom @Required-style annotation, which is equivalent to 
@Required annotation.

In this example, you will create a custom @Required-style annotation named @Mandatory, which is equivalent to @Required annotation.

1. Create the @Mandatory interface
package com.mkyong.common;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Mandatory {
}

 
2. Apply it to a property
package com.mkyong.common;

public class Customer
{
	private Person person;
	private int type;
	private String action;

	@Mandatory
	public void setPerson(Person person) {
		this.person = person;
	}
	//getter and setter methods
}

 
3. Register it
Include your new @Mandatory annotation in ‘RequiredAnnotationBeanPostProcessor’ class.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

<bean
class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor">
	<property name="requiredAnnotationType" value="com.mkyong.common.Mandatory"/>
</bean>

	<bean id="CustomerBean" class="com.mkyong.common.Customer">
		<property name="action" value="buy" />
		<property name="type" value="1" />
	</bean>

</beans>
4. Done
Done, you just created a new custom @Required-style annotation named @Mandatory, which is equivalent to @Required annotation


104 : Spring InitializingBean and DisposableBean example


In Spring, InitializingBean and DisposableBean are two marker interfaces, a useful way for Spring to perform certain actions upon bean initialization and 
destruction.

For bean implemented InitializingBean, it will run afterPropertiesSet() after all bean properties have been set.
For bean implemented DisposableBean, it will run destroy() after Spring container is released the bean.

Example : Here’s an example to show you how to use InitializingBeanand DisposableBean. A CustomerService bean to implement both InitializingBean and 
DisposableBean interface, and has a message property.

package com.mkyong.customer.services;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;

public class CustomerService implements InitializingBean, DisposableBean
{
	String message;

	public String getMessage() {
	  return message;
	}

	public void setMessage(String message) {
	  this.message = message;
	}

	public void afterPropertiesSet() throws Exception {
	  System.out.println("Init method after properties are set : " + message);
	}

	public void destroy() throws Exception {
	  System.out.println("Spring Container is destroy! Customer clean up");
	}

}
File : Spring-Customer.xml

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

       <bean id="customerService" class="com.mkyong.customer.services.CustomerService">
		<property name="message" value="i'm property message" />
       </bean>

</beans>
Run it

package com.mkyong.common;

import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.mkyong.customer.services.CustomerService;

public class App
{
    public static void main( String[] args )
    {
    	ConfigurableApplicationContext context =
			new ClassPathXmlApplicationContext(new String[] {"Spring-Customer.xml"});

    	CustomerService cust = (CustomerService)context.getBean("customerService");

    	System.out.println(cust);

    	context.close();
    }
}
The ConfigurableApplicationContext.close() will close the application context, releasing all resources and destroying all cached singleton beans. It’s use for
destroy() method demo purpose only :)

Output

Init method after properties are set : im property message
com.mkyong.customer.services.CustomerService@47393f
...
INFO: Destroying singletons in org.springframework.beans.factory.
support.DefaultListableBeanFactory@77158a:
defining beans [customerService]; root of factory hierarchy
Spring Container is destroy! Customer clean up
The afterPropertiesSet() method is called, after the message property is set; while the destroy() method is call after the context.close();

Thoughts…
I would not recommend to use InitializingBean and DisposableBean interface, because it will tight coupled your code to Spring. A better approach should be 
specifying the init-method and destroy-method attributes in your bean configuration file.


105 : Spring init-method and destroy-method example


In Spring, you can use init-method and destroy-method as attribute in bean configuration file for bean to perform certain actions upon initialization and 
destruction. Alternative to InitializingBean and DisposableBean interface.

Example
Here’s an example to show you how to use init-method and destroy-method.

package com.mkyong.customer.services;

public class CustomerService
{
	String message;

	public String getMessage() {
	  return message;
	}

	public void setMessage(String message) {
	  this.message = message;
	}

	public void initIt() throws Exception {
	  System.out.println("Init method after properties are set : " + message);
	}

	public void cleanUp() throws Exception {
	  System.out.println("Spring Container is destroy! Customer clean up");
	}

}
File : Spring-Customer.xml, define init-method and destroy-method attribute in your bean.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="customerService" class="com.mkyong.customer.services.CustomerService"
		init-method="initIt" destroy-method="cleanUp">

		<property name="message" value="i'm property message" />
	</bean>

</beans>
Run it

package com.mkyong.common;

import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.mkyong.customer.services.CustomerService;

public class App
{
    public static void main( String[] args )
    {
    	ConfigurableApplicationContext context =
		new ClassPathXmlApplicationContext(new String[] {"Spring-Customer.xml"});

    	CustomerService cust = (CustomerService)context.getBean("customerService");

    	System.out.println(cust);

    	context.close();
    }
}
The ConfigurableApplicationContext.close will close the application context, releasing all resources and destroying all cached singleton beans.

Output

Init method after properties are set : i'm property message
com.mkyong.customer.services.CustomerService@47393f
...
INFO: Destroying singletons in org.springframework.beans.factory.
support.DefaultListableBeanFactory@77158a:
defining beans [customerService]; root of factory hierarchy
Spring Container is destroy! Customer clean up
The initIt() method is called, after the message property is set, and the cleanUp() method is called after the context.close();

Thoughts…
It’s always recommended to use init-method and destroy-method in bean configuration file, instead of implement the InitializingBean and DisposableBean 
interface to cause unnecessarily coupled your code to Spring.


106 : Spring @PostConstruct and @PreDestroy example


In Spring, you can either implements InitializingBean and DisposableBean interface or specify the init-method and destroy-method in bean configuration file for
the initialization and destruction callback function. In this article, we show you how to use annotation @PostConstruct and @PreDestroy to do the same thing.

Note
The @PostConstruct and @PreDestroy annotation are not belong to Spring, it’s located in the J2ee library – common-annotations.jar.
@PostConstruct and @PreDestroy
A CustomerService bean with @PostConstruct and @PreDestroy annotation

package com.mkyong.customer.services;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

public class CustomerService
{
	String message;

	public String getMessage() {
	  return message;
	}

	public void setMessage(String message) {
	  this.message = message;
	}

	@PostConstruct
	public void initIt() throws Exception {
	  System.out.println("Init method after properties are set : " + message);
	}

	@PreDestroy
	public void cleanUp() throws Exception {
	  System.out.println("Spring Container is destroy! Customer clean up");
	}

}
By default, Spring will not aware of the @PostConstruct and @PreDestroy annotation. To enable it, you have to either register 
‘CommonAnnotationBeanPostProcessor‘ or specify the ‘<context:annotation-config />‘ in bean configuration file,


 
1. CommonAnnotationBeanPostProcessor
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor" />

	<bean id="customerService" class="com.mkyong.customer.services.CustomerService">
		<property name="message" value="i'm property message" />
	</bean>

</beans>

 
2. <context:annotation-config />
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
	http://www.springframework.org/schema/context
	http://www.springframework.org/schema/context/spring-context-2.5.xsd">

	<context:annotation-config />

	<bean id="customerService" class="com.mkyong.customer.services.CustomerService">
		<property name="message" value="i'm property message" />
	</bean>

</beans>
Run it

package com.mkyong.common;

import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.mkyong.customer.services.CustomerService;

public class App
{
    public static void main( String[] args )
    {
    	ConfigurableApplicationContext context =
    	  new ClassPathXmlApplicationContext(new String[] {"Spring-Customer.xml"});

    	CustomerService cust = (CustomerService)context.getBean("customerService");

    	System.out.println(cust);

    	context.close();
    }
}
Output

Init method after properties are set : im property message
com.mkyong.customer.services.CustomerService@47393f
...
INFO: Destroying singletons in org.springframework.beans.factory.
support.DefaultListableBeanFactory@77158a:
defining beans [customerService]; root of factory hierarchy
Spring Container is destroy! Customer clean up
The initIt() method (@PostConstruct) is called, after the message property is set, and the cleanUp() method (@PreDestroy) is call after the context.close();


107 : Spring EL hello world example


The Spring EL is similar with OGNL and JSF EL, and evaluated or executed during the bean creation time. In addition, all Spring expressions are available via 
XML or annotation.

In this tutorial, we show you how to use Spring Expression Language(SpEL), to inject String, integer and bean into property, both in XML and annotation.

1. Spring EL Dependency
Declares the core Spring jars in Maven pom.xml file, it will download the Spring EL dependencies automatically.

File : pom.xml

<properties>
	<spring.version>3.0.5.RELEASE</spring.version>
</properties>

<dependencies>

	<!-- Spring 3 dependencies -->
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-core</artifactId>
		<version>${spring.version}</version>
	</dependency>

	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-context</artifactId>
		<version>${spring.version}</version>
	</dependency>

<dependencies>

 
2. Spring Beans
Two simple beans, later use SpEL to inject values into property, in XML and annotation.

package com.mkyong.core;

public class Customer {

	private Item item;

	private String itemName;

}
package com.mkyong.core;

public class Item {

	private String name;

	private int qty;

}

 
3. Spring EL in XML
The SpEL are enclosed with #{ SpEL expression }, see following example in XML bean definition file.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

	<bean id="itemBean" class="com.mkyong.core.Item">
		<property name="name" value="itemA" />
		<property name="qty" value="10" />
	</bean>

	<bean id="customerBean" class="com.mkyong.core.Customer">
		<property name="item" value="#{itemBean}" />
		<property name="itemName" value="#{itemBean.name}" />
	</bean>

</beans>
#{itemBean} – inject “itemBean” into “customerBean” bean’s “item” property.
#{itemBean.name} – inject “itemBean”‘s “name” property into “customerBean” bean’s “itemName” property.
4. Spring EL in Annotation
See equivalent version in annotation mode.

Note
To use SpEL in annotation, you must register your component via annotation. If you register your bean in XML and define @Value in Java class, the @Value will 
failed to execute.

package com.mkyong.core;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("customerBean")
public class Customer {

	@Value("#{itemBean}")
	private Item item;

	@Value("#{itemBean.name}")
	private String itemName;

	//...

}
package com.mkyong.core;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("itemBean")
public class Item {

	@Value("itemA") //inject String directly
	private String name;

	@Value("10") //inject interger directly
	private int qty;

	public String getName() {
		return name;
	}

	//...
}
Enable auto component scanning.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
	http://www.springframework.org/schema/context
	http://www.springframework.org/schema/context/spring-context-3.0.xsd">

	<context:component-scan base-package="com.mkyong.core" />

</beans>
In annotation mode, you use @Value to define Spring EL. In this case, you inject a String and Integer value directly into the “itemBean“, and later inject the
“itemBean” into “customerBean” property.

5. Output
Run it, both SpEL in XML and annotation are display the same result :

package com.mkyong.core;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
	public static void main(String[] args) {
	    ApplicationContext context = new ClassPathXmlApplicationContext("SpringBeans.xml");

	    Customer obj = (Customer) context.getBean("customerBean");
	    System.out.println(obj);
	}
}
Output

Customer [item=Item [name=itemA, qty=10], itemName=itemA]


108 : Spring EL bean reference example


In Spring EL, you can reference a bean, and nested properties using a ‘dot (.)‘ symbol. For example, “bean.property_name“.

public class Customer {

	@Value("#{addressBean.country}")
	private String country;
In above code snippet, it inject the value of “country” property from “addressBean” bean into current “customer” class, “country” property.

Spring EL in Annotation
See following example, show you how to use SpEL to reference a bean, bean property and also it’s method.

package com.mkyong.core;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("customerBean")
public class Customer {

	@Value("#{addressBean}")
	private Address address;

	@Value("#{addressBean.country}")
	private String country;

	@Value("#{addressBean.getFullAddress('mkyong')}")
	private String fullAddress;

	//getter and setter methods

	@Override
	public String toString() {
		return "Customer [address=" + address + "\n, country=" + country
				+ "\n, fullAddress=" + fullAddress + "]";
	}

}
package com.mkyong.core;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("addressBean")
public class Address {

	@Value("Block ABC, LakeView")
	private String street;

	@Value("98700")
	private int postcode;

	@Value("US")
	private String country;

	public String getFullAddress(String prefix) {

		return prefix + " : " + street + " " + postcode + " " + country;
	}

	//getter and setter methods

	public void setCountry(String country) {
		this.country = country;
	}

	@Override
	public String toString() {
		return "Address [street=" + street + ", postcode=" + postcode
				+ ", country=" + country + "]";
	}

}
Run it

Customer obj = (Customer) context.getBean("customerBean");
System.out.println(obj);
Output

Customer [address=Address [street=Block ABC, LakeView, postcode=98700, country=US]
, country=US
, fullAddress=mkyong : Block ABC, LakeView 98700 US]

 
Spring EL in XML
See equivalent version in bean definition XML file.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

	<bean id="customerBean" class="com.mkyong.core.Customer">
		<property name="address" value="#{addressBean}" />
		<property name="country" value="#{addressBean.country}" />
		<property name="fullAddress" value="#{addressBean.getFullAddress('mkyong')}" />
	</bean>

	<bean id="addressBean" class="com.mkyong.core.Address">
		<property name="street" value="Block ABC, LakeView" />
		<property name="postcode" value="98700" />
		<property name="country" value="US" />
	</bean>

</beans>


109 : Spring EL method invocation example


Spring expression language (SpEL) allow developer uses expression to execute method and inject the method returned value into property, or so called 
“SpEL method invocation“.

Spring EL in Annotation
See how to do Spring EL method invocation with @Value annotation.

package com.mkyong.core;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("customerBean")
public class Customer {

	@Value("#{'mkyong'.toUpperCase()}")
	private String name;

	@Value("#{priceBean.getSpecialPrice()}")
	private double amount;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public double getAmount() {
		return amount;
	}

	public void setAmount(double amount) {
		this.amount = amount;
	}

	@Override
	public String toString() {
		return "Customer [name=" + name + ", amount=" + amount + "]";
	}

}
package com.mkyong.core;

import org.springframework.stereotype.Component;

@Component("priceBean")
public class Price {

	public double getSpecialPrice() {
		return new Double(99.99);
	}

}
Output

Customer [name=MKYONG, amount=99.99]
Explanation

Call the ‘toUpperCase()‘ method on the string literal.

@Value("#{'mkyong'.toUpperCase()}")
private String name;
Call the ‘getSpecialPrice()‘ method on bean ‘priceBean‘.

@Value("#{priceBean.getSpecialPrice()}")
private double amount;

 
Spring EL in XML
This is the equivalent version in bean definition XML file.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

	<bean id="customerBean" class="com.mkyong.core.Customer">
		<property name="name" value="#{'mkyong'.toUpperCase()}" />
		<property name="amount" value="#{priceBean.getSpecialPrice()}" />
	</bean>

	<bean id="priceBean" class="com.mkyong.core.Price" />

</beans>
Output

Customer [name=MKYONG, amount=99.99]


110 : Spring EL ternary operator (if-then-else) example


Spring EL supports ternary operator , perform “if then else” conditional checking. For example,

condition ? true : false
Spring EL in Annotation
Spring EL ternary operator with @Value annotation. In this example, if “itemBean.qtyOnHand” is less than 100, then set “customerBean.warning” to true, else set it to false.

package com.mkyong.core;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("customerBean")
public class Customer {

	@Value("#{itemBean.qtyOnHand < 100 ? true : false}")
	private boolean warning;

	public boolean isWarning() {
		return warning;
	}

	public void setWarning(boolean warning) {
		this.warning = warning;
	}

	@Override
	public String toString() {
		return "Customer [warning=" + warning + "]";
	}

}
package com.mkyong.core;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("itemBean")
public class Item {

	@Value("99")
	private int qtyOnHand;

	public int getQtyOnHand() {
		return qtyOnHand;
	}

	public void setQtyOnHand(int qtyOnHand) {
		this.qtyOnHand = qtyOnHand;
	}

}
Output

Customer [warning=true]

 
Spring EL in XML
See equivalent version in bean definition XML file.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

	<bean id="customerBean" class="com.mkyong.core.Customer">
		<property name="warning"
                          value="#{itemBean.qtyOnHand < 100 ? true : false}" />
	</bean>

	<bean id="itemBean" class="com.mkyong.core.Item">
		<property name="qtyOnHand" value="99" />
	</bean>

</beans>
Output

Customer [warning=true]
In XML, you need to replace less than operator "<" with "&lt;".


111 : Spring EL Lists, Maps example


In this article, we show you how to use Spring EL to get value from Map and List. Actually, the way of SpEL works with Map and List is exactly same with Java.
See example :

//get map whete key = 'MapA'
@Value("#{testBean.map['MapA']}")
private String mapA;

//get first value from list, list is 0-based.
@Value("#{testBean.list[0]}")
private String list;
Spring EL in Annotation
Here, created a HashMap and ArrayList, with some initial data for testing.

package com.mkyong.core;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("customerBean")
public class Customer {

	@Value("#{testBean.map['MapA']}")
	private String mapA;

	@Value("#{testBean.list[0]}")
	private String list;

	public String getMapA() {
		return mapA;
	}

	public void setMapA(String mapA) {
		this.mapA = mapA;
	}

	public String getList() {
		return list;
	}

	public void setList(String list) {
		this.list = list;
	}

	@Override
	public String toString() {
		return "Customer [mapA=" + mapA + ", list=" + list + "]";
	}

}
package com.mkyong.core;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.springframework.stereotype.Component;

@Component("testBean")
public class Test {

	private Map<String, String> map;
	private List<String> list;

	public Test() {
		map = new HashMap<String, String>();
		map.put("MapA", "This is A");
		map.put("MapB", "This is B");
		map.put("MapC", "This is C");

		list = new ArrayList<String>();
		list.add("List0");
		list.add("List1");
		list.add("List2");

	}

	public Map<String, String> getMap() {
		return map;
	}

	public void setMap(Map<String, String> map) {
		this.map = map;
	}

	public List<String> getList() {
		return list;
	}

	public void setList(List<String> list) {
		this.list = list;
	}

}
Run it

Customer obj = (Customer) context.getBean("customerBean");
System.out.println(obj);
Output

Customer [mapA=This is A, list=List0]

 
Spring EL in XML
See equivalent version in bean definition XML file.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

	<bean id="customerBean" class="com.mkyong.core.Customer">
		<property name="mapA" value="#{testBean.map['MapA']}" />
		<property name="list" value="#{testBean.list[0]}" />
	</bean>

	<bean id="testBean" class="com.mkyong.core.Test" />

</beans>

112 : Spring Auto scanning components


Normally you declare all the beans or components in XML bean configuration file, so that Spring container can detect and register your beans or components.
Actually, Spring is able to auto scan, detect and instantiate your beans from pre-defined project package, no more tedious beans declaration in in XML file.

Following is a simple Spring project, including a customer service and dao layer. Let’s explore the different between declare components manually and auto components scanning in Spring.

1. Declares Components Manually
See a normal way to declare a bean in Spring.

Normal bean.

package com.mkyong.customer.dao;

public class CustomerDAO
{
	@Override
	public String toString() {
		return "Hello , This is CustomerDAO";
	}
}
DAO layer.

package com.mkyong.customer.services;

import com.mkyong.customer.dao.CustomerDAO;

public class CustomerService
{
	CustomerDAO customerDAO;

	public void setCustomerDAO(CustomerDAO customerDAO) {
		this.customerDAO = customerDAO;
	}

	@Override
	public String toString() {
		return "CustomerService [customerDAO=" + customerDAO + "]";
	}

}
Bean configuration file (Spring-Customer.xml), a normal bean configuration in Spring.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="customerService" class="com.mkyong.customer.services.CustomerService">
		<property name="customerDAO" ref="customerDAO" />
	</bean>

	<bean id="customerDAO" class="com.mkyong.customer.dao.CustomerDAO" />

</beans>
Run it

package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.mkyong.customer.services.CustomerService;

public class App
{
    public static void main( String[] args )
    {
    	ApplicationContext context =
    	  new ClassPathXmlApplicationContext(new String[] {"Spring-Customer.xml"});

    	CustomerService cust = (CustomerService)context.getBean("customerService");
    	System.out.println(cust);

    }
}
output

CustomerService [customerDAO=Hello , This is CustomerDAO]

 
2. Auto Components Scanning
Now, enable Spring auto component scanning features.

Annotate with @Component to indicate this is class is an auto scan component.

package com.mkyong.customer.dao;

import org.springframework.stereotype.Component;

@Component
public class CustomerDAO
{
	@Override
	public String toString() {
		return "Hello , This is CustomerDAO";
	}
}
DAO layer, add @Component to indicate this is an auto scan component also.

package com.mkyong.customer.services;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.mkyong.customer.dao.CustomerDAO;

@Component
public class CustomerService
{
	@Autowired
	CustomerDAO customerDAO;

	@Override
	public String toString() {
		return "CustomerService [customerDAO=" + customerDAO + "]";
	}
}
Put this “context:component” in bean configuration file, it means, enable auto scanning feature in Spring. The base-package is indicate where are your
components stored, Spring will scan this folder and find out the bean (annotated with @Component) and register it in Spring container.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
	http://www.springframework.org/schema/context
	http://www.springframework.org/schema/context/spring-context-2.5.xsd">

	<context:component-scan base-package="com.mkyong.customer" />

</beans>
Run it

package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.mkyong.customer.services.CustomerService;

public class App
{
    public static void main( String[] args )
    {
    	ApplicationContext context =
    	   new ClassPathXmlApplicationContext(new String[] {"Spring-AutoScan.xml"});

    	CustomerService cust = (CustomerService)context.getBean("customerService");
    	System.out.println(cust);

    }
}
output

CustomerService [customerDAO=Hello , This is CustomerDAO]
This is how auto components scanning works in Spring.


In Spring 2.5, there are 4 types of auto components scan annotation types

@Component – Indicates a auto scan component.
@Repository – Indicates DAO component in the persistence layer.
@Service – Indicates a Service component in the business layer.
@Controller – Indicates a controller component in the presentation layer.
So, which one to use? It’s really doesn’t matter. Let see the source code of @Repository,@Service or @Controller.

You will noticed that all @Repository,@Service or @Controller are annotated with @Component. So, can we use just @Component for all the components for auto
scanning? Yes, you can, and Spring will auto scan all your components with @Component annotated.

It’s working fine, but not a good practice, for readability, you should always declare @Repository,@Service or @Controller for a specified layer to make your
code more easier to read, as following :

DAO layer

package com.mkyong.customer.dao;

import org.springframework.stereotype.Repository;

@Repository
public class CustomerDAO
{
	@Override
	public String toString() {
		return "Hello , This is CustomerDAO";
	}
}
Service layer

package com.mkyong.customer.services;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.mkyong.customer.dao.CustomerDAO;

@Service
public class CustomerService
{
	@Autowired
	CustomerDAO customerDAO;

	@Override
	public String toString() {
		return "CustomerService [customerDAO=" + customerDAO + "]";
	}

}


113 : Spring Autowiring by Name


In Spring, “Autowiring by Name” means, if the name of a bean is same as the name of other bean property, auto wire it.

For example, if a “customer” bean exposes an “address” property, Spring will find the “address” bean in current container and wire it automatically. And if no
matching found, just do nothing.

You can enable this feature via autowire="byName" like below :

<!-- customer has a property name "address" -->
<bean id="customer" class="com.mkyong.common.Customer" autowire="byName" />

<bean id="address" class="com.mkyong.common.Address" >
	<property name="fulladdress" value="Block A 888, CA" />
</bean>
See a full example of Spring auto wiring by name.

1. Beans
Two beans, customer and address.

package com.mkyong.common;

public class Customer
{
	private Address address;
	//...
}
package com.mkyong.common;

public class Address
{
	private String fulladdress;
	//...
}

 
2. Spring Wiring
Normally, you wire the bean explicitly, via ref attribute like this :

<bean id="customer" class="com.mkyong.common.Customer" >
	<property name="address" ref="address" />
</bean>

<bean id="address" class="com.mkyong.common.Address" >
	<property name="fulladdress" value="Block A 888, CA" />
</bean>
Output

Customer [address=Address [fulladdress=Block A 888, CA]]
With autowire by name enabled, you do not need to declares the property tag anymore. As long as the “address” bean is same name as the property of “customer”
bean, which is “address”, Spring will wire it automatically.

<bean id="customer" class="com.mkyong.common.Customer" autowire="byName" />

<bean id="address" class="com.mkyong.common.Address" >
	<property name="fulladdress" value="Block A 888, CA" />
</bean>
Output

Customer [address=Address [fulladdress=Block A 888, CA]]
See another example, this time, the wiring will failed, caused the bean “addressABC” is not match the property name of bean “customer”.

<bean id="customer" class="com.mkyong.common.Customer" autowire="byName" />

<bean id="addressABC" class="com.mkyong.common.Address" >
	<property name="fulladdress" value="Block A 888, CA" />
</bean>
Output

Customer [address=null]

114 : Spring Autowiring by Type


In Spring, “Autowiring by Type” means, if data type of a bean is compatible with the data type of other bean property, auto wire it.

For example, a “person” bean exposes a property with data type of “ability” class, Spring will find the bean with same data type of class “ability” and wire
it automatically. And if no matching found, just do nothing.

You can enable this feature via autowire="byType" like below :

<!-- person has a property type of class "ability" -->
<bean id="person" class="com.mkyong.common.Person" autowire="byType" />

<bean id="invisible" class="com.mkyong.common.Ability" >
	<property name="skill" value="Invisible" />
</bean>
See a full example of Spring auto wiring by type.

1. Beans
Two beans, person and ability.

package com.mkyong.common;

public class Person
{
	private Ability ability;
	//...
}
package com.mkyong.common;

public class Ability
{
	private String skill;
	//...
}

 
2. Spring Wiring
Normally, you wire the bean explicitly :

<bean id="person" class="com.mkyong.common.Person">
	<property name="ability" ref="invisible" />
</bean>

<bean id="invisible" class="com.mkyong.common.Ability" >
	<property name="skill" value="Invisible" />
</bean>
Output

Person [ability=Ability [skill=Invisible]]
With autowire by type enabled, you can leave the ability property unset. Spring will find the same data type and wire it automatcailly.

<bean id="person" class="com.mkyong.common.Person" autowire="byType" />

<bean id="invisible" class="com.mkyong.common.Ability" >
	<property name="skill" value="Invisible" />
</bean>
Output

Person [ability=Ability [skill=Invisible]]
Wait, what if you have two beans with same data type of class “ability”?

<bean id="person" class="com.mkyong.common.Person" autowire="byType" />

<bean id="steal" class="com.mkyong.common.Ability" >
	<property name="skill" value="Steal" />
</bean>

<bean id="invisible" class="com.mkyong.common.Ability" >
	<property name="skill" value="Invisible" />
</bean>
Output

Exception in thread "main" org.springframework.beans.factory.UnsatisfiedDependencyException:
...
No unique bean of type [com.mkyong.common.Ability] is defined:
expected single matching bean but found 2: [steal, invisible]; nested exception is
org.springframework.beans.factory.NoSuchBeanDefinitionException:
No unique bean of type [com.mkyong.common.Ability] is defined:
expected single matching bean but found 2: [steal, invisible]
In this case, you will hits the UnsatisfiedDependencyException error message.

Note
In autowiring by type mode, you just have to make sure only one unique data type of bean is declared.


115 : Spring Autowiring by Constructor


In Spring, “Autowiring by Constructor” is actually autowiring by Type in constructor argument. It means, if data type of a bean is same as the data type of 
other bean constructor argument, auto wire it.

See a full example of Spring auto wiring by constructor.

1. Beans
Two beans, developer and language.

package com.mkyong.common;

public class Developer {
	private Language language;

	//autowire by constructor
	public Developer(Language language) {
		this.language = language;
	}

	//...

}
package com.mkyong.common;

public class Language {
	private String name;
	//...
}

 
2. Spring Wiring
Normally, you wire the bean via constructor like this :

<bean id="developer" class="com.mkyong.common.Developer">
	<constructor-arg>
		<ref bean="language" />
	</constructor-arg>
</bean>

<bean id="language" class="com.mkyong.common.Language" >
	<property name="name" value="Java" />
</bean>
Output

Developer [language=Language [name=Java]]
With autowire by constructor enabled, you can leave the constructor property unset. Spring will find the compatible data type and wire it automatcailly.

<bean id="developer" class="com.mkyong.common.Developer" autowire="constructor" />

<bean id="language" class="com.mkyong.common.Language" >
	<property name="name" value="Java" />
</bean>
Output

Developer [language=Language [name=Java]]


116 : Spring Autowiring by AutoDetect (mentioned by SpringFrameworkInfo.txt).

117 : Spring and JDBC example : 

(a) : 

Spring + JDBC example

In this tutorial, we will extend last Maven + Spring hello world example by adding JDBC support, to use Spring + JDBC to insert a record into a customer 
table.

1. Customer table
In this example, we are using MySQL database.

CREATE TABLE `customer` (
  `CUST_ID` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `NAME` varchar(100) NOT NULL,
  `AGE` int(10) unsigned NOT NULL,
  PRIMARY KEY (`CUST_ID`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

 
2. Project Dependency
Add Spring and MySQL dependencies in Maven pom.xml file.

File : pom.xml

<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
  http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.mkyong.common</groupId>
  <artifactId>SpringExample</artifactId>
  <packaging>jar</packaging>
  <version>1.0-SNAPSHOT</version>
  <name>SpringExample</name>
  <url>http://maven.apache.org</url>

  <dependencies>

        <!-- Spring framework -->
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring</artifactId>
		<version>2.5.6</version>
	</dependency>

        <!-- MySQL database driver -->
	<dependency>
		<groupId>mysql</groupId>
		<artifactId>mysql-connector-java</artifactId>
		<version>5.1.9</version>
	</dependency>

  </dependencies>
</project>

 
3. Customer model
Add a customer model to store customer’s data.

package com.mkyong.customer.model;

import java.sql.Timestamp;

public class Customer
{
	int custId;
	String name;
	int age;
	//getter and setter methods

}
4. Data Access Object (DAO) pattern
Customer Dao interface.

package com.mkyong.customer.dao;

import com.mkyong.customer.model.Customer;

public interface CustomerDAO
{
	public void insert(Customer customer);
	public Customer findByCustomerId(int custId);
}
Customer Dao implementation, use JDBC to issue a simple insert and select statement.

package com.mkyong.customer.dao.impl;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.sql.DataSource;
import com.mkyong.customer.dao.CustomerDAO;
import com.mkyong.customer.model.Customer;

public class JdbcCustomerDAO implements CustomerDAO
{
	private DataSource dataSource;

	public void setDataSource(DataSource dataSource) {
		this.dataSource = dataSource;
	}

	public void insert(Customer customer){

		String sql = "INSERT INTO CUSTOMER " +
				"(CUST_ID, NAME, AGE) VALUES (?, ?, ?)";
		Connection conn = null;

		try {
			conn = dataSource.getConnection();
			PreparedStatement ps = conn.prepareStatement(sql);
			ps.setInt(1, customer.getCustId());
			ps.setString(2, customer.getName());
			ps.setInt(3, customer.getAge());
			ps.executeUpdate();
			ps.close();

		} catch (SQLException e) {
			throw new RuntimeException(e);

		} finally {
			if (conn != null) {
				try {
					conn.close();
				} catch (SQLException e) {}
			}
		}
	}

	public Customer findByCustomerId(int custId){

		String sql = "SELECT * FROM CUSTOMER WHERE CUST_ID = ?";

		Connection conn = null;

		try {
			conn = dataSource.getConnection();
			PreparedStatement ps = conn.prepareStatement(sql);
			ps.setInt(1, custId);
			Customer customer = null;
			ResultSet rs = ps.executeQuery();
			if (rs.next()) {
				customer = new Customer(
					rs.getInt("CUST_ID"),
					rs.getString("NAME"),
					rs.getInt("Age")
				);
			}
			rs.close();
			ps.close();
			return customer;
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			if (conn != null) {
				try {
				conn.close();
				} catch (SQLException e) {}
			}
		}
	}
}
5. Spring bean configuration
Create the Spring bean configuration file for customerDAO and datasource.
File : Spring-Customer.xml

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="customerDAO" class="com.mkyong.customer.dao.impl.JdbcCustomerDAO">
		<property name="dataSource" ref="dataSource" />
	</bean>

</beans>
File : Spring-Datasource.xml

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="dataSource"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">

		<property name="driverClassName" value="com.mysql.jdbc.Driver" />
		<property name="url" value="jdbc:mysql://localhost:3306/mkyongjava" />
		<property name="username" value="root" />
		<property name="password" value="password" />
	</bean>

</beans>
File : Spring-Module.xml

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<import resource="database/Spring-Datasource.xml" />
	<import resource="customer/Spring-Customer.xml" />

</beans>.


6. Run it
package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.mkyong.customer.dao.CustomerDAO;
import com.mkyong.customer.model.Customer;

public class App
{
    public static void main( String[] args )
    {
    	ApplicationContext context =
    		new ClassPathXmlApplicationContext("Spring-Module.xml");

        CustomerDAO customerDAO = (CustomerDAO) context.getBean("customerDAO");
        Customer customer = new Customer(1, "mkyong",28);
        customerDAO.insert(customer);

        Customer customer1 = customerDAO.findByCustomerId(1);
        System.out.println(customer1);

    }
}
output

Customer [age=28, custId=1, name=mkyong]


(b) : Spring + JdbcTemplate + JdbcDaoSupport examples

In Spring JDBC development, you can use JdbcTemplate and JdbcDaoSupport classes to simplify the overall database operation processes.

In this tutorial, we will reuse the last Spring + JDBC example, to see the different between a before (No JdbcTemplate support) and after (With JdbcTemplate 
support) example.

1. Example Without JdbcTemplate
Witout JdbcTemplate, you have to create many redundant codes (create connection , close connection , handle exception) in all the DAO database operation 
methods – insert, update and delete. It just not efficient, ugly, error prone and tedious.

private DataSource dataSource;

public void setDataSource(DataSource dataSource) {
	this.dataSource = dataSource;
}

public void insert(Customer customer){

	String sql = "INSERT INTO CUSTOMER " +
			"(CUST_ID, NAME, AGE) VALUES (?, ?, ?)";
	Connection conn = null;

	try {
		conn = dataSource.getConnection();
		PreparedStatement ps = conn.prepareStatement(sql);
		ps.setInt(1, customer.getCustId());
		ps.setString(2, customer.getName());
		ps.setInt(3, customer.getAge());
		ps.executeUpdate();
		ps.close();

	} catch (SQLException e) {
		throw new RuntimeException(e);

	} finally {
		if (conn != null) {
			try {
				conn.close();
			} catch (SQLException e) {}
		}
	}
}

 
2. Example With JdbcTemplate
With JdbcTemplate, you save a lot of typing on the redundant codes, becuase JdbcTemplate will handle it automatically.

private DataSource dataSource;
private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {
	this.dataSource = dataSource;
}

public void insert(Customer customer){

	String sql = "INSERT INTO CUSTOMER " +
		"(CUST_ID, NAME, AGE) VALUES (?, ?, ?)";

	jdbcTemplate = new JdbcTemplate(dataSource);

	jdbcTemplate.update(sql, new Object[] { customer.getCustId(),
		customer.getName(),customer.getAge()
	});

}
See the different?


 
3. Example With JdbcDaoSupport
By extended the JdbcDaoSupport, set the datasource and JdbcTemplate in your class is no longer required, you just need to inject the correct datasource into
JdbcCustomerDAO. And you can get the JdbcTemplate by using a getJdbcTemplate() method.

public class JdbcCustomerDAO extends JdbcDaoSupport implements CustomerDAO
{
   //no need to set datasource here
   public void insert(Customer customer){

	String sql = "INSERT INTO CUSTOMER " +
		"(CUST_ID, NAME, AGE) VALUES (?, ?, ?)";

	getJdbcTemplate().update(sql, new Object[] { customer.getCustId(),
			customer.getName(),customer.getAge()
	});

}
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="dataSource"
         class="org.springframework.jdbc.datasource.DriverManagerDataSource">

		<property name="driverClassName" value="com.mysql.jdbc.Driver" />
		<property name="url" value="jdbc:mysql://localhost:3306/mkyongjava" />
		<property name="username" value="root" />
		<property name="password" value="password" />
	</bean>

</beans>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="customerDAO" class="com.mkyong.customer.dao.impl.JdbcCustomerDAO">
		<property name="dataSource" ref="dataSource" />
	</bean>

</beans>

Note
In Spring JDBC development, it’s always recommended to use JdbcTemplate and JdbcDaoSupport, instead of coding JDBC code yourself.


(c) : Spring JdbcTemplate batchUpdate() example

In some cases, you may required to insert a batch of records into database in one shot. If you call a single insert method for every record, the SQL statement
will be compiled repeatedly and causing your system slow to perform.

In above case, you can use JdbcTemplate batchUpdate() method to perform the batch insert operations. With this method, the statement is compiled only once and 
executed multiple times.

See batchUpdate() example in JdbcTemplate class.

//insert batch example
public void insertBatch(final List<Customer> customers){

  String sql = "INSERT INTO CUSTOMER " +
	"(CUST_ID, NAME, AGE) VALUES (?, ?, ?)";

  getJdbcTemplate().batchUpdate(sql, new BatchPreparedStatementSetter() {

	@Override
	public void setValues(PreparedStatement ps, int i) throws SQLException {
		Customer customer = customers.get(i);
		ps.setLong(1, customer.getCustId());
		ps.setString(2, customer.getName());
		ps.setInt(3, customer.getAge() );
	}

	@Override
	public int getBatchSize() {
		return customers.size();
	}
  });
}
Alternatively, you can execute the SQL directly.

//insert batch example with SQL
public void insertBatchSQL(final String sql){

	getJdbcTemplate().batchUpdate(new String[]{sql});

}
Spring’s bean configuration file

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="customerDAO" class="com.mkyong.customer.dao.impl.JdbcCustomerDAO">
		<property name="dataSource" ref="dataSource" />
	</bean>

	<bean id="dataSource"
        class="org.springframework.jdbc.datasource.DriverManagerDataSource">

		<property name="driverClassName" value="com.mysql.jdbc.Driver" />
		<property name="url" value="jdbc:mysql://localhost:3306/mkyongjava" />
		<property name="username" value="root" />
		<property name="password" value="password" />
	</bean>

</beans>
Run it

package com.mkyong.common;

import java.util.ArrayList;
import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.mkyong.customer.dao.CustomerDAO;
import com.mkyong.customer.model.Customer;

public class App
{
    public static void main( String[] args )
    {
    	ApplicationContext context =
    		new ClassPathXmlApplicationContext("Spring-Customer.xml");

        CustomerDAO customerDAO = (CustomerDAO) context.getBean("customerDAO");
        Customer customer1 = new Customer(1, "mkyong1",21);
        Customer customer3 = new Customer(2, "mkyong2",22);
        Customer customer2 = new Customer(3, "mkyong3",23);

        List<Customer>customers = new ArrayList<Customer>();
        customers.add(customer1);
        customers.add(customer2);
        customers.add(customer3);

        customerDAO.insertBatch(customers);

        String sql = "UPDATE CUSTOMER SET NAME ='BATCHUPDATE'";
        customerDAO.insertBatchSQL(sql);

    }
}
In this example, you are inserted three customers’ records and update all customer’s name in batch.


(d) : Spring SimpleJdbcTemplate batchUpdate() example

In this tutorial, we show you how to use batchUpdate() in SimpleJdbcTemplate class.

See batchUpdate() example in SimpleJdbcTemplate class.

//insert batch example
public void insertBatch(final List<Customer> customers){
	String sql = "INSERT INTO CUSTOMER " +
		"(CUST_ID, NAME, AGE) VALUES (?, ?, ?)";

	List<Object[]> parameters = new ArrayList<Object[]>();

	for (Customer cust : customers) {
        parameters.add(new Object[] {cust.getCustId(),
            cust.getName(), cust.getAge()}
        );
    }
    getSimpleJdbcTemplate().batchUpdate(sql, parameters);
}
Alternatively, you can execute the SQL directly.

//insert batch example with SQL
public void insertBatchSQL(final String sql){

	getJdbcTemplate().batchUpdate(new String[]{sql});

}
Spring’s bean configuration file

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="customerSimpleDAO"
        class="com.mkyong.customer.dao.impl.SimpleJdbcCustomerDAO">

		<property name="dataSource" ref="dataSource" />
	</bean>

	<bean id="dataSource"
        class="org.springframework.jdbc.datasource.DriverManagerDataSource">

		<property name="driverClassName" value="com.mysql.jdbc.Driver" />
		<property name="url" value="jdbc:mysql://localhost:3306/mkyongjava" />
		<property name="username" value="root" />
		<property name="password" value="password" />
	</bean>

</beans>
Run it

package com.mkyong.common;

import java.util.ArrayList;
import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.mkyong.customer.dao.CustomerDAO;
import com.mkyong.customer.model.Customer;

public class App
{
    public static void main( String[] args )
    {
    	ApplicationContext context =
    		new ClassPathXmlApplicationContext("Spring-Customer.xml");

        CustomerDAO customerSimpleDAO =
                      (CustomerDAO) context.getBean("customerSimpleDAO");

        Customer customer1 = new Customer(1, "mkyong1",21);
        Customer customer3 = new Customer(2, "mkyong2",22);
        Customer customer2 = new Customer(3, "mkyong3",23);

        List<Customer>customers = new ArrayList<Customer>();
        customers.add(customer1);
        customers.add(customer2);
        customers.add(customer3);

        customerSimpleDAO.insertBatch(customers);

        String sql = "UPDATE CUSTOMER SET NAME ='BATCHUPDATE'";
        customerSimpleDAO.insertBatchSQL(sql);

    }
}
In this example, you are inserted three customers’ records and update all customer’s name in batch.


(e) : Spring JdbcTemplate Querying examples


Here are few examples to show you how to use JdbcTemplate query() methods to query or extract data from database.

1. Querying for Single Row
Here’s two ways to query or extract a single row record from database, and convert it into a model class.


 
1.1 Custom RowMapper
In general, It’s always recommended to implement the RowMapper interface to create a custom RowMapper to suit your needs.

package com.mkyong.customer.model;

import java.sql.ResultSet;
import java.sql.SQLException;

import org.springframework.jdbc.core.RowMapper;

public class CustomerRowMapper implements RowMapper
{
	public Object mapRow(ResultSet rs, int rowNum) throws SQLException {
		Customer customer = new Customer();
		customer.setCustId(rs.getInt("CUST_ID"));
		customer.setName(rs.getString("NAME"));
		customer.setAge(rs.getInt("AGE"));
		return customer;
	}

}
Pass it to queryForObject() method, the returned result will call your custom mapRow() method to match the value into the properly.

public Customer findByCustomerId(int custId){

	String sql = "SELECT * FROM CUSTOMER WHERE CUST_ID = ?";

	Customer customer = (Customer)getJdbcTemplate().queryForObject(
			sql, new Object[] { custId }, new CustomerRowMapper());

	return customer;
}

 
1.2 BeanPropertyRowMapper
In Spring 2.5, comes with a handy RowMapper implementation called ‘BeanPropertyRowMapper’, which can maps a row’s column value to a property by matching their
names. Just make sure both the property and column has the same name, e.g property ‘custId’ will match to column name ‘CUSTID’ or with underscores ‘CUST_ID’.

public Customer findByCustomerId2(int custId){

	String sql = "SELECT * FROM CUSTOMER WHERE CUST_ID = ?";

	Customer customer = (Customer)getJdbcTemplate().queryForObject(
			sql, new Object[] { custId },
			new BeanPropertyRowMapper(Customer.class));

	return customer;
}
2. Querying for Multiple Rows
Now, query or extract multiple rows from database, and convert it into a List.

2.1 Map it manually
In mutiple return rows, RowMapper is not supported in queryForList() method, you need to map it manually.

public List<Customer> findAll(){

	String sql = "SELECT * FROM CUSTOMER";

	List<Customer> customers = new ArrayList<Customer>();

	List<Map> rows = getJdbcTemplate().queryForList(sql);
	for (Map row : rows) {
		Customer customer = new Customer();
		customer.setCustId((Long)(row.get("CUST_ID")));
		customer.setName((String)row.get("NAME"));
		customer.setAge((Integer)row.get("AGE"));
		customers.add(customer);
	}

	return customers;
}
2.2 BeanPropertyRowMapper
The simplest solution is using the BeanPropertyRowMapper class.

public List<Customer> findAll(){

	String sql = "SELECT * FROM CUSTOMER";

	List<Customer> customers  = getJdbcTemplate().query(sql,
			new BeanPropertyRowMapper(Customer.class));

	return customers;
}
3. Querying for a Single Value
In this example, it shows how to query or extract a single column value from database.

3.1 Single column name
It shows how to query a single column name as String.

public String findCustomerNameById(int custId){

	String sql = "SELECT NAME FROM CUSTOMER WHERE CUST_ID = ?";

	String name = (String)getJdbcTemplate().queryForObject(
			sql, new Object[] { custId }, String.class);

	return name;

}
3.2 Total number of rows
It shows how to query a total number of rows from database.

public int findTotalCustomer(){

	String sql = "SELECT COUNT(*) FROM CUSTOMER";

	int total = getJdbcTemplate().queryForInt(sql);

	return total;
}
Run it

package com.mkyong.common;

import java.util.ArrayList;
import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.mkyong.customer.dao.CustomerDAO;
import com.mkyong.customer.model.Customer;

public class JdbcTemplateApp
{
    public static void main( String[] args )
    {
    	 ApplicationContext context =
    		new ClassPathXmlApplicationContext("Spring-Customer.xml");

         CustomerDAO customerDAO = (CustomerDAO) context.getBean("customerDAO");

         Customer customerA = customerDAO.findByCustomerId(1);
         System.out.println("Customer A : " + customerA);

         Customer customerB = customerDAO.findByCustomerId2(1);
         System.out.println("Customer B : " + customerB);

         List<Customer> customerAs = customerDAO.findAll();
         for(Customer cust: customerAs){
         	 System.out.println("Customer As : " + customerAs);
         }

         List<Customer> customerBs = customerDAO.findAll2();
         for(Customer cust: customerBs){
         	 System.out.println("Customer Bs : " + customerBs);
         }

         String customerName = customerDAO.findCustomerNameById(1);
         System.out.println("Customer Name : " + customerName);

         int total = customerDAO.findTotalCustomer();
         System.out.println("Total : " + total);

    }
}
Conclusion
The JdbcTemplate class, comes with many useful overloaded query methods. It’s advise to refer to the existing query method before you create own customize 
query method, because Spring may done it for you already.

(f) : Spring SimpleJdbcTemplate Querying examples


Here are few examples to show how to use SimpleJdbcTemplate query() methods to query or extract data from database. In JdbcTemplate query(), you need to 
manually cast the returned result to desire object type, and pass an Object array as parameters. In SimpleJdbcTemplate, it is more user friendly and simple.

1. Querying for Single Row
Here’s two ways to show you how to query or extract a single row from database, and convert it into a model class.


 
1.1 Custom RowMapper
In general, It’s always recommend to implement the RowMapper interface to create a custom RowMapper to suit your needs.

package com.mkyong.customer.model;

import java.sql.ResultSet;
import java.sql.SQLException;

import org.springframework.jdbc.core.RowMapper;

public class CustomerRowMapper implements RowMapper
{
	public Object mapRow(ResultSet rs, int rowNum) throws SQLException {
		Customer customer = new Customer();
		customer.setCustId(rs.getInt("CUST_ID"));
		customer.setName(rs.getString("NAME"));
		customer.setAge(rs.getInt("AGE"));
		return customer;
	}

}
public Customer findByCustomerId(int custId){

	String sql = "SELECT * FROM CUSTOMER WHERE CUST_ID = ?";

	Customer customer = getSimpleJdbcTemplate().queryForObject(
			sql,  new CustomerParameterizedRowMapper(), custId);

	return customer;
}

 
1.2 BeanPropertyRowMapper
In SimpleJdbcTemplate, you need to use ‘ParameterizedBeanPropertyRowMapper’ instead of ‘BeanPropertyRowMapper’.

public Customer findByCustomerId2(int custId){

	String sql = "SELECT * FROM CUSTOMER WHERE CUST_ID = ?";

	Customer customer = getSimpleJdbcTemplate().queryForObject(sql,
          ParameterizedBeanPropertyRowMapper.newInstance(Customer.class), custId);

	return customer;
}
2. Querying for Multiple Rows
Query or extract multiple rows from database, and convert it into a List.

2.1 ParameterizedBeanPropertyRowMapper
public List<Customer> findAll(){

	String sql = "SELECT * FROM CUSTOMER";

	List<Customer> customers =
		getSimpleJdbcTemplate().query(sql,
		   ParameterizedBeanPropertyRowMapper.newInstance(Customer.class));

	return customers;
}
3. Querying for a Single Value
Query or extract a single column value from database.

3.1 Single column name
It shows how to query a single column name as String.

public String findCustomerNameById(int custId){

	String sql = "SELECT NAME FROM CUSTOMER WHERE CUST_ID = ?";

	String name = getSimpleJdbcTemplate().queryForObject(
		sql, String.class, custId);

	return name;

}
3.2 Total number of rows
It shows how to query a total number of rows from database.

public int findTotalCustomer(){

	String sql = "SELECT COUNT(*) FROM CUSTOMER";

	int total = getSimpleJdbcTemplate().queryForInt(sql);

	return total;
}
Run it

package com.mkyong.common;

import java.util.ArrayList;
import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.mkyong.customer.dao.CustomerDAO;
import com.mkyong.customer.model.Customer;

public class SimpleJdbcTemplateApp
{
    public static void main( String[] args )
    {
    	 ApplicationContext context =
    		new ClassPathXmlApplicationContext("Spring-Customer.xml");

         CustomerDAO customerSimpleDAO =
                (CustomerDAO) context.getBean("customerSimpleDAO");

         Customer customerA = customerSimpleDAO.findByCustomerId(1);
         System.out.println("Customer A : " + customerA);

         Customer customerB = customerSimpleDAO.findByCustomerId2(1);
         System.out.println("Customer B : " + customerB);

         List<Customer> customerAs = customerSimpleDAO.findAll();
         for(Customer cust: customerAs){
         	 System.out.println("Customer As : " + customerAs);
         }

         List<Customer> customerBs = customerSimpleDAO.findAll2();
         for(Customer cust: customerBs){
         	 System.out.println("Customer Bs : " + customerBs);
         }

         String customerName = customerSimpleDAO.findCustomerNameById(1);
         System.out.println("Customer Name : " + customerName);

         int total = customerSimpleDAO.findTotalCustomer();
         System.out.println("Total : " + total);

    }
}
Conclusion
The SimpleJdbcTemplate isn’t a replacement for JdbcTemplate, it’s just a java5-friendly supplement to it.


118 : Spring and HIbernate : 

(a) : Maven + Spring + Hibernate + MySql Example


This example will use Maven to create a simple Java project structure, and demonstrate how to use Hibernate in Spring framework to do the data manipulation 
works(insert, select, update and delete) in MySQL database.

 
1. Table creation
Create a ‘stock’ table in MySQL database. SQL statement as follow :

CREATE TABLE  `mkyong`.`stock` (
  `STOCK_ID` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `STOCK_CODE` varchar(10) NOT NULL,
  `STOCK_NAME` varchar(20) NOT NULL,
  PRIMARY KEY (`STOCK_ID`) USING BTREE,
  UNIQUE KEY `UNI_STOCK_NAME` (`STOCK_NAME`),
  UNIQUE KEY `UNI_STOCK_ID` (`STOCK_CODE`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

 
2. Project File Structure
Create a quick project file structure with Maven command ‘mvn archetype:generate‘, see example here. Convert it to Eclipse project (mvn eclipse:eclipse) and 
import it into Eclipse IDE.

E:\workspace>mvn archetype:generate
[INFO] Scanning for projects...
...
Choose a number:
(1/2/3....) 15: : 15
...
Define value for groupId: : com.mkyong.common
Define value for artifactId: : HibernateExample
Define value for version:  1.0-SNAPSHOT: :
Define value for package:  com.mkyong.common: : com.mkyong.common
[INFO] OldArchetype created in dir: E:\workspace\HibernateExample
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
3. Pom.xml file configuration
Add the Spring, Hibernate , MySQL and their dependency in the Maven’s pom.xml file.

<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
  http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.mkyong.common</groupId>
  <artifactId>SpringExample</artifactId>
  <packaging>jar</packaging>
  <version>1.0-SNAPSHOT</version>
  <name>SpringExample</name>
  <url>http://maven.apache.org</url>

  <dependencies>

        <!-- JUnit testing framework -->
        <dependency>
                <groupId>junit</groupId>
                <artifactId>junit</artifactId>
                <version>3.8.1</version>
                <scope>test</scope>
        </dependency>

        <!-- Spring framework -->
        <dependency>
	        <groupId>org.springframework</groupId>
	        <artifactId>spring</artifactId>
	        <version>2.5.6</version>
        </dependency>

        <!-- Spring AOP dependency -->
        <dependency>
    	        <groupId>cglib</groupId>
		<artifactId>cglib</artifactId>
		<version>2.2</version>
	</dependency>

        <!-- MySQL database driver -->
	<dependency>
		<groupId>mysql</groupId>
		<artifactId>mysql-connector-java</artifactId>
		<version>5.1.9</version>
	</dependency>

	<!-- Hibernate framework -->
	<dependency>
		<groupId>hibernate</groupId>
		<artifactId>hibernate3</artifactId>
		<version>3.2.3.GA</version>
	</dependency>


	<!-- Hibernate library dependecy start -->
	<dependency>
		<groupId>dom4j</groupId>
		<artifactId>dom4j</artifactId>
		<version>1.6.1</version>
	</dependency>

	<dependency>
		<groupId>commons-logging</groupId>
		<artifactId>commons-logging</artifactId>
		<version>1.1.1</version>
	</dependency>

	<dependency>
		<groupId>commons-collections</groupId>
		<artifactId>commons-collections</artifactId>
		<version>3.2.1</version>
	</dependency>

	<dependency>
		<groupId>antlr</groupId>
		<artifactId>antlr</artifactId>
		<version>2.7.7</version>
	</dependency>
	<!-- Hibernate library dependecy end -->

  </dependencies>
</project>
4. Model & BO & DAO
The Model, Business Object (BO) and Data Access Object (DAO) pattern is useful to identify the layer clearly to avoid mess up the project structure.

Stock Model

A Stock model class to store the stock data later.

package com.mkyong.stock.model;

import java.io.Serializable;

public class Stock implements Serializable {

	private static final long serialVersionUID = 1L;

	private Long stockId;
	private String stockCode;
	private String stockName;

	//getter and setter methods...
}
Stock Business Object (BO))

Stock business object (BO) interface and implementation, it’s used to store the project’s business function, the real database operations (CRUD) works 
should not involved in this class, instead it has a DAO (StockDao) class to do it.

package com.mkyong.stock.bo;

import com.mkyong.stock.model.Stock;

public interface StockBo {

	void save(Stock stock);
	void update(Stock stock);
	void delete(Stock stock);
	Stock findByStockCode(String stockCode);
}
package com.mkyong.stock.bo.impl;

import com.mkyong.stock.bo.StockBo;
import com.mkyong.stock.dao.StockDao;
import com.mkyong.stock.model.Stock;

public class StockBoImpl implements StockBo{

	StockDao stockDao;

	public void setStockDao(StockDao stockDao) {
		this.stockDao = stockDao;
	}

	public void save(Stock stock){
		stockDao.save(stock);
	}

	public void update(Stock stock){
		stockDao.update(stock);
	}

	public void delete(Stock stock){
		stockDao.delete(stock);
	}

	public Stock findByStockCode(String stockCode){
		return stockDao.findByStockCode(stockCode);
	}
}
Stock Data Access Object

A Stock DAO interface and implementation, the dao implementation class extends the Spring’s “HibernateDaoSupport” to make Hibernate support in Spring 
framework. Now, you can execute the Hibernate function via getHibernateTemplate().

package com.mkyong.stock.dao;

import com.mkyong.stock.model.Stock;

public interface StockDao {

	void save(Stock stock);
	void update(Stock stock);
	void delete(Stock stock);
	Stock findByStockCode(String stockCode);

}
package com.mkyong.stock.dao.impl;

import java.util.List;

import org.springframework.orm.hibernate3.support.HibernateDaoSupport;

import com.mkyong.stock.dao.StockDao;
import com.mkyong.stock.model.Stock;

public class StockDaoImpl extends HibernateDaoSupport implements StockDao{

	public void save(Stock stock){
		getHibernateTemplate().save(stock);
	}

	public void update(Stock stock){
		getHibernateTemplate().update(stock);
	}

	public void delete(Stock stock){
		getHibernateTemplate().delete(stock);
	}

	public Stock findByStockCode(String stockCode){
		List list = getHibernateTemplate().find(
                      "from Stock where stockCode=?",stockCode
                );
		return (Stock)list.get(0);
	}

}
5. Resource Configuration
Create a ‘resources‘ folder under ‘project_name/main/java/‘, Maven will treat all files under this folder as resources file. It will used to store the Spring,
 Hibernate and others configuration file.

Hibernate Configuration

Create a Hibernate mapping file (Stock.hbm.xml) for Stock table, put it under “resources/hibernate/” folder.

<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">

<hibernate-mapping>
    <class name="com.mkyong.stock.model.Stock" table="stock" catalog="mkyong">
        <id name="stockId" type="java.lang.Long">
            <column name="STOCK_ID" />
            <generator class="identity" />
        </id>
        <property name="stockCode" type="string">
            <column name="STOCK_CODE" length="10" not-null="true" unique="true" />
        </property>
        <property name="stockName" type="string">
            <column name="STOCK_NAME" length="20" not-null="true" unique="true" />
        </property>
    </class>
</hibernate-mapping>
Spring Configuration

Database related….

Create a properties file (database.properties) for the database details, put it into the “resources/properties” folder. It’s good practice disparate the 
database details and Spring bean configuration into different files.

database.properties

jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mkyong
jdbc.username=root
jdbc.password=password
Create a “dataSource” bean configuration file (DataSource.xml) for your database, and import the properties from database.properties, put it into the 
“resources/database” folder.

DataSource.xml

<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

<bean
class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
	<property name="location">
		<value>properties/database.properties</value>
	</property>
</bean>

<bean id="dataSource"
         class="org.springframework.jdbc.datasource.DriverManagerDataSource">
	<property name="driverClassName" value="${jdbc.driverClassName}" />
	<property name="url" value="${jdbc.url}" />
	<property name="username" value="${jdbc.username}" />
	<property name="password" value="${jdbc.password}" />
</bean>

</beans>
Hibernate related….

Create a session factory bean configuration file (Hibernate.xml), put it into the “resources/database” folder. This LocalSessionFactoryBean class will set up
a shared Hibernate SessionFactory in a Spring application context.

Hibernate.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

<!-- Hibernate session factory -->
<bean id="sessionFactory"
     class="org.springframework.orm.hibernate3.LocalSessionFactoryBean">

    <property name="dataSource">
      <ref bean="dataSource"/>
    </property>

    <property name="hibernateProperties">
       <props>
         <prop key="hibernate.dialect">org.hibernate.dialect.MySQLDialect</prop>
         <prop key="hibernate.show_sql">true</prop>
       </props>
     </property>

     <property name="mappingResources">
	<list>
           <value>/hibernate/Stock.hbm.xml</value>
	</list>
      </property>

    </bean>
</beans>
Spring beans related….

Create a bean configuration file (Stock.xml) for BO and DAO classes, put it into the “resources/spring” folder. Dependency inject the dao (stockDao) bean
into the bo (stockBo) bean; sessionFactory bean into the stockDao.

Stock.xml

<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

    <!-- Stock business object -->
   <bean id="stockBo" class="com.mkyong.stock.bo.impl.StockBoImpl" >
   		<property name="stockDao" ref="stockDao" />
   </bean>

   <!-- Stock Data Access Object -->
   <bean id="stockDao" class="com.mkyong.stock.dao.impl.StockDaoImpl" >
   		<property name="sessionFactory" ref="sessionFactory"></property>
   </bean>

</beans>
Import all the Spring’s beans configuration files into a single file (BeanLocations.xml), put it into the “resources/config” folder.

BeanLocations.xml

<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<!-- Database Configuration -->
	<import resource="../database/DataSource.xml"/>
	<import resource="../database/Hibernate.xml"/>

	<!-- Beans Declaration -->
	<import resource="../beans/Stock.xml"/>

</beans>
6. Run it
You have all the files and configurations , run it.

package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.mkyong.stock.bo.StockBo;
import com.mkyong.stock.model.Stock;

public class App
{
    public static void main( String[] args )
    {
    	ApplicationContext appContext =
    	  new ClassPathXmlApplicationContext("spring/config/BeanLocations.xml");

    	StockBo stockBo = (StockBo)appContext.getBean("stockBo");

    	/** insert **/
    	Stock stock = new Stock();
    	stock.setStockCode("7668");
    	stock.setStockName("HAIO");
    	stockBo.save(stock);

    	/** select **/
    	Stock stock2 = stockBo.findByStockCode("7668");
    	System.out.println(stock2);

    	/** update **/
    	stock2.setStockName("HAIO-1");
    	stockBo.update(stock2);

    	/** delete **/
    	stockBo.delete(stock2);

    	System.out.println("Done");
    }
}
output

Hibernate: insert into mkyong.stock (STOCK_CODE, STOCK_NAME) values (?, ?)
Hibernate: select stock0_.STOCK_ID as STOCK1_0_,
stock0_.STOCK_CODE as STOCK2_0_, stock0_.STOCK_NAME as STOCK3_0_
from mkyong.stock stock0_ where stock0_.STOCK_CODE=?
Stock [stockCode=7668, stockId=11, stockName=HAIO]
Hibernate: update mkyong.stock set STOCK_CODE=?, STOCK_NAME=? where STOCK_ID=?
Hibernate: delete from mkyong.stock where STOCK_ID=?
Done


(b) : Maven + (Spring + Hibernate) Annotation + MySql Example

Download It – Spring-Hibernate-Annotation-Example.zip
In last tutorial, you use Maven to create a simple Java project structure, and demonstrate how to use Hibernate in Spring framework to do the data manipulation works(insert, select, update and delete) in MySQL database. In this tutorial, you will learn how to do the same thing in Spring and Hibernate annotation way.

Prerequisite requirement
– Installed and configured Maven, MySQL, Eclipse IDE.

The javaee.jar library is required as well, you can get it from j2ee SDK, and include it manually, there is no full version of javaee.jar available in any of
the Maven repository yet.
 
 
1. Table creation
Create a ‘stock’ table in MySQL database. SQL statement as follow :

CREATE TABLE  `mkyong`.`stock` (
  `STOCK_ID` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `STOCK_CODE` varchar(10) NOT NULL,
  `STOCK_NAME` varchar(20) NOT NULL,
  PRIMARY KEY (`STOCK_ID`) USING BTREE,
  UNIQUE KEY `UNI_STOCK_NAME` (`STOCK_NAME`),
  UNIQUE KEY `UNI_STOCK_ID` (`STOCK_CODE`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;
2. Project File Structure
Create a quick project file structure with Maven command ‘mvn archetype:generate‘, see example here. Convert it to Eclipse project (mvn eclipse:eclipse) and 
import it into Eclipse IDE.

E:\workspace>mvn archetype:generate
[INFO] Scanning for projects...
...
Choose a number:
(1/2/3....) 15: : 15
...
Define value for groupId: : com.mkyong.common
Define value for artifactId: : HibernateExample
Define value for version:  1.0-SNAPSHOT: :
Define value for package:  com.mkyong.common: : com.mkyong.common
[INFO] OldArchetype created in dir: E:\workspace\HibernateExample
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
3. Pom.xml file configuration
Add the Spring, Hibernate, Annotation and MySQL and their dependency in the Maven’s pom.xml file.

<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
  http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.mkyong.common</groupId>
  <artifactId>SpringExample</artifactId>
  <packaging>jar</packaging>
  <version>1.0-SNAPSHOT</version>
  <name>SpringExample</name>
  <url>http://maven.apache.org</url>

  <repositories>
    <repository>
      <id>JBoss repository</id>
      <url>http://repository.jboss.com/maven2/</url>
    </repository>
  </repositories>

  <dependencies>

        <!-- JUnit testing framework -->
        <dependency>
                <groupId>junit</groupId>
                <artifactId>junit</artifactId>
                <version>3.8.1</version>
                <scope>test</scope>
        </dependency>

        <!-- Spring framework -->
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring</artifactId>
		<version>2.5.6</version>
	</dependency>

        <!-- Spring AOP dependency -->
        <dependency>
    	        <groupId>cglib</groupId>
		<artifactId>cglib</artifactId>
		<version>2.2</version>
	</dependency>

        <!-- MySQL database driver -->
	<dependency>
		<groupId>mysql</groupId>
		<artifactId>mysql-connector-java</artifactId>
		<version>5.1.9</version>
	</dependency>

	<!-- Hibernate framework -->
	<dependency>
		<groupId>hibernate</groupId>
		<artifactId>hibernate3</artifactId>
		<version>3.2.3.GA</version>
	</dependency>

	<!-- Hibernate annotation -->
	<dependency>
		<groupId>hibernate-annotations</groupId>
		<artifactId>hibernate-annotations</artifactId>
		<version>3.3.0.GA</version>
	</dependency>

	<dependency>
		<groupId>hibernate-commons-annotations</groupId>
		<artifactId>hibernate-commons-annotations</artifactId>
		<version>3.0.0.GA</version>
	</dependency>

	<!-- Hibernate library dependecy start -->
	<dependency>
		<groupId>dom4j</groupId>
		<artifactId>dom4j</artifactId>
		<version>1.6.1</version>
	</dependency>

	<dependency>
		<groupId>commons-logging</groupId>
		<artifactId>commons-logging</artifactId>
		<version>1.1.1</version>
	</dependency>

	<dependency>
		<groupId>commons-collections</groupId>
		<artifactId>commons-collections</artifactId>
		<version>3.2.1</version>
	</dependency>

	<dependency>
		<groupId>antlr</groupId>
		<artifactId>antlr</artifactId>
		<version>2.7.7</version>
	</dependency>
	<!-- Hibernate library dependecy end -->

  </dependencies>
</project>
4. Model & BO & DAO
The Model, Business Object (BO) and Data Access Object (DAO) pattern is useful to identify the layer clearly to avoid mess up the project structure.

Stock Model (Annotation)

A Stock model annotation class to store the stock data.

package com.mkyong.stock.model;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import static javax.persistence.GenerationType.IDENTITY;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;

@Entity
@Table(name = "stock", catalog = "mkyong", uniqueConstraints = {
		@UniqueConstraint(columnNames = "STOCK_NAME"),
		@UniqueConstraint(columnNames = "STOCK_CODE") })
public class Stock implements java.io.Serializable {

	private Integer stockId;
	private String stockCode;
	private String stockName;

	public Stock() {
	}

	public Stock(String stockCode, String stockName) {
		this.stockCode = stockCode;
		this.stockName = stockName;
	}

	@Id
	@GeneratedValue(strategy = IDENTITY)
	@Column(name = "STOCK_ID", unique = true, nullable = false)
	public Integer getStockId() {
		return this.stockId;
	}

	public void setStockId(Integer stockId) {
		this.stockId = stockId;
	}

	@Column(name = "STOCK_CODE", unique = true, nullable = false, length = 10)
	public String getStockCode() {
		return this.stockCode;
	}

	public void setStockCode(String stockCode) {
		this.stockCode = stockCode;
	}

	@Column(name = "STOCK_NAME", unique = true, nullable = false, length = 20)
	public String getStockName() {
		return this.stockName;
	}

	public void setStockName(String stockName) {
		this.stockName = stockName;
	}

	@Override
	public String toString() {
		return "Stock [stockCode=" + stockCode + ", stockId=" + stockId
				+ ", stockName=" + stockName + "]";
	}
}
Stock Business Object (BO))

Stock business object (BO) interface and implementation, it’s used to store the project’s business function, the real database operations (CRUD) works should
not involved in this class, instead it has a DAO (StockDao) class to do it.

package com.mkyong.stock.bo;

import com.mkyong.stock.model.Stock;

public interface StockBo {

	void save(Stock stock);
	void update(Stock stock);
	void delete(Stock stock);
	Stock findByStockCode(String stockCode);
}
Make this class as a bean “stockBo” in Spring Ioc container, and autowire the stock dao class.

package com.mkyong.stock.bo.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.mkyong.stock.bo.StockBo;
import com.mkyong.stock.dao.StockDao;
import com.mkyong.stock.model.Stock;

@Service("stockBo")
public class StockBoImpl implements StockBo{

	@Autowired
	StockDao stockDao;

	public void setStockDao(StockDao stockDao) {
		this.stockDao = stockDao;
	}

	public void save(Stock stock){
		stockDao.save(stock);
	}

	public void update(Stock stock){
		stockDao.update(stock);
	}

	public void delete(Stock stock){
		stockDao.delete(stock);
	}

	public Stock findByStockCode(String stockCode){
		return stockDao.findByStockCode(stockCode);
	}
}
Stock Data Access Object

A Stock DAO interface and implementation. In last tutorial, you DAO classes are directly extends the “HibernateDaoSupport“, but it’s not possible to do it in 
annotation mode, because you have no way to auto wire the session Factory bean from your DAO class. The workaround is create a custom class 
(CustomHibernateDaoSupport) and extends the “HibernateDaoSupport” and auto wire the session factory, and your DAO classes extends this class.

package com.mkyong.stock.dao;

import com.mkyong.stock.model.Stock;

public interface StockDao {

	void save(Stock stock);
	void update(Stock stock);
	void delete(Stock stock);
	Stock findByStockCode(String stockCode);

}
package com.mkyong.util;

import org.hibernate.SessionFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.orm.hibernate3.support.HibernateDaoSupport;

public abstract class CustomHibernateDaoSupport extends HibernateDaoSupport
{
    @Autowired
    public void anyMethodName(SessionFactory sessionFactory)
    {
        setSessionFactory(sessionFactory);
    }
}
package com.mkyong.stock.dao.impl;

import java.util.List;

import org.springframework.stereotype.Repository;

import com.mkyong.stock.dao.StockDao;
import com.mkyong.stock.model.Stock;
import com.mkyong.util.CustomHibernateDaoSupport;

@Repository("stockDao")
public class StockDaoImpl extends CustomHibernateDaoSupport implements StockDao{

	public void save(Stock stock){
		getHibernateTemplate().save(stock);
	}

	public void update(Stock stock){
		getHibernateTemplate().update(stock);
	}

	public void delete(Stock stock){
		getHibernateTemplate().delete(stock);
	}

	public Stock findByStockCode(String stockCode){
		List list = getHibernateTemplate().find(
                     "from Stock where stockCode=?",stockCode
                );
		return (Stock)list.get(0);
	}

}
5. Resource Configuration
Create a ‘resources‘ folder under ‘project_name/main/java/‘, Maven will treat all files under this folder as resources file. It will used to store the 
Spring, Hibernate and others configuration file.

Spring Configuration

Database related….

Create a properties file (database.properties) for the database details, put it into the “resources/properties” folder. It’s good practice disparate the 
database details and Spring bean configuration into different files.

database.properties

jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mkyong
jdbc.username=root
jdbc.password=password
Create a “dataSource” bean configuration file (DataSource.xml) for your database, and import the properties from database.properties, put it into the 
“resources/database” folder.

DataSource.xml

<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

<bean
class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
	<property name="location">
		<value>properties/database.properties</value>
	</property>
</bean>

<bean id="dataSource"
         class="org.springframework.jdbc.datasource.DriverManagerDataSource">
	<property name="driverClassName" value="${jdbc.driverClassName}" />
	<property name="url" value="${jdbc.url}" />
	<property name="username" value="${jdbc.username}" />
	<property name="password" value="${jdbc.password}" />
</bean>

</beans>
Hibernate related….

Create a session factory bean configuration file (Hibernate.xml), put it into the “resources/database” folder. In annotation you have to use the 
AnnotationSessionFactoryBean, instead of LocalSessionFactoryBean, and specify your annotated model classes in ‘annotatedClasses‘ property instead of
‘mappingResources‘ property.

Hibernate.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

<!-- Hibernate session factory -->
<bean id="sessionFactory"
class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean">

    <property name="dataSource">
      <ref bean="dataSource"/>
    </property>

    <property name="hibernateProperties">
       <props>
         <prop key="hibernate.dialect">org.hibernate.dialect.MySQLDialect</prop>
         <prop key="hibernate.show_sql">true</prop>
       </props>
    </property>

    <property name="annotatedClasses">
	<list>
		<value>com.mkyong.stock.model.Stock</value>
	</list>
    </property>

    </bean>
</beans>
Import all the Spring’s beans configuration files into a single file (BeanLocations.xml), put it into the “resources/config” folder.

BeanLocations.xml
Import the Spring database configuration and enable the Spring’s auto scan feature.

<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:context="http://www.springframework.org/schema/context"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context-2.5.xsd">

	<!-- Database Configuration -->
	<import resource="../database/DataSource.xml"/>
	<import resource="../database/Hibernate.xml"/>

	<!-- Auto scan the components -->
	<context:component-scan
		base-package="com.mkyong.stock" />

</beans>
6. Run it
You have all the files and configurations , run it.

package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.mkyong.stock.bo.StockBo;
import com.mkyong.stock.model.Stock;

public class App
{
    public static void main( String[] args )
    {
    	ApplicationContext appContext =
    	  new ClassPathXmlApplicationContext("spring/config/BeanLocations.xml");

    	StockBo stockBo = (StockBo)appContext.getBean("stockBo");

    	/** insert **/
    	Stock stock = new Stock();
    	stock.setStockCode("7668");
    	stock.setStockName("HAIO");
    	stockBo.save(stock);

    	/** select **/
    	Stock stock2 = stockBo.findByStockCode("7668");
    	System.out.println(stock2);

    	/** update **/
    	stock2.setStockName("HAIO-1");
    	stockBo.update(stock2);

    	/** delete **/
    	stockBo.delete(stock2);

    	System.out.println("Done");
    }
}
output

Hibernate: insert into mkyong.stock (STOCK_CODE, STOCK_NAME) values (?, ?)
Hibernate: select stock0_.STOCK_ID as STOCK1_0_,
stock0_.STOCK_CODE as STOCK2_0_, stock0_.STOCK_NAME as STOCK3_0_
from mkyong.stock stock0_ where stock0_.STOCK_CODE=?
Stock [stockCode=7668, stockId=11, stockName=HAIO]
Hibernate: update mkyong.stock set STOCK_CODE=?, STOCK_NAME=? where STOCK_ID=?
Hibernate: delete from mkyong.stock where STOCK_ID=?
Done

Conclusion
All Spring, Hibernate related classes and configuration files are annotated, it just left the database details in XML file. Should you know how to annotate
the database configuration details, please let me know. Personally, i do not use annotation feature much, because somehow you may need some workaround for 
certain situation, like ‘CustomHibernateDaoSupport’ extends ‘HibernateDaoSupport’ above. The mature developed XML file in Spring and Hibernate. is more 
preferably.


(c) : Example ' Spring-Hibernate-Transaction-Example ' in CoreJava folder in D drive.


119 : Spring – Sending e-mail with attachment


Here’s an example to use Spring to send e-mail that has attachments via Gmail SMTP server. In order to contains the attachment in your e-mail, you have to use
Spring’s JavaMailSender & MimeMessage , instead of MailSender & SimpleMailMessage.

1. Project dependency
Add the JavaMail and Spring’s dependency.

File : pom.xml

<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
  http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.mkyong.common</groupId>
  <artifactId>SpringExample</artifactId>
  <packaging>jar</packaging>
  <version>1.0-SNAPSHOT</version>
  <name>SpringExample</name>
  <url>http://maven.apache.org</url>

  <repositories>
  	<repository>
  		<id>Java.Net</id>
  		<url>http://download.java.net/maven/2/</url>
  	</repository>
  </repositories>

  <dependencies>

    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>3.8.1</version>
        <scope>test</scope>
    </dependency>

    <!-- Java Mail API -->
    <dependency>
	    <groupId>javax.mail</groupId>
	    <artifactId>mail</artifactId>
	    <version>1.4.3</version>
    </dependency>

    <!-- Spring framework -->
    <dependency>
     	<groupId>org.springframework</groupId>
	    <artifactId>spring</artifactId>
	    <version>2.5.6</version>
    </dependency>

  </dependencies>
</project>

 
2. Spring’s Mail Sender
You have to use JavaMailSender instead of MailSender to send attachments, and attach the resources with MimeMessageHelper. In this example, it will get the 
“c:\\log.txt” text file from your file system (FileSystemResource) as an e-mail attachment.

Beside file system, you can also get any resources from URL path(UrlResource), Classpath (ClassPathResource), InputStream (InputStreamResource)… please refer
to Spring’s AbstractResource implemented classes.

File : MailMail.java

package com.mkyong.common;

import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;

import org.springframework.core.io.FileSystemResource;
import org.springframework.mail.MailParseException;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;

public class MailMail
{
	private JavaMailSender mailSender;
	private SimpleMailMessage simpleMailMessage;

	public void setSimpleMailMessage(SimpleMailMessage simpleMailMessage) {
		this.simpleMailMessage = simpleMailMessage;
	}

	public void setMailSender(JavaMailSender mailSender) {
		this.mailSender = mailSender;
	}

	public void sendMail(String dear, String content) {

	   MimeMessage message = mailSender.createMimeMessage();

	   try{
		MimeMessageHelper helper = new MimeMessageHelper(message, true);

		helper.setFrom(simpleMailMessage.getFrom());
		helper.setTo(simpleMailMessage.getTo());
			helper.setSubject(simpleMailMessage.getSubject());
		helper.setText(String.format(
			simpleMailMessage.getText(), dear, content));

		FileSystemResource file = new FileSystemResource("C:\\log.txt");
		helper.addAttachment(file.getFilename(), file);

	     }catch (MessagingException e) {
		throw new MailParseException(e);
	     }
	     mailSender.send(message);
         }
}

 
3. Bean configuration file
Configure the mailSender bean, email template and specify the email details for the Gmail SMTP server.

File : Spring-Mail.xml

<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

<bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl">
	<property name="host" value="smtp.gmail.com" />
	<property name="port" value="587" />
	<property name="username" value="username" />
	<property name="password" value="password" />

	<property name="javaMailProperties">
		<props>
           	<prop key="mail.smtp.auth">true</prop>
           	<prop key="mail.smtp.starttls.enable">true</prop>
       	</props>
	</property>
</bean>

<bean id="mailMail" class="com.mkyong.common.MailMail">
	<property name="mailSender" ref="mailSender" />
	<property name="simpleMailMessage" ref="customeMailMessage" />
</bean>

<bean id="customeMailMessage"
	class="org.springframework.mail.SimpleMailMessage">

	<property name="from" value="from@no-spam.com" />
	<property name="to" value="to@no-spam.com" />
	<property name="subject" value="Testing Subject" />
	<property name="text">
	<value>
		<![CDATA[
			Dear %s,
			Mail Content : %s
		]]>
	</value>
    </property>
</bean>

</beans>
4. Run it
package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App
{
    public static void main( String[] args )
    {
    	ApplicationContext context =
            new ClassPathXmlApplicationContext("Spring-Mail.xml");

    	MailMail mm = (MailMail) context.getBean("mailMail");
        mm.sendMail("Yong Mook Kim", "This is text content");

    }
}
output

Dear Yong Mook Kim,
Mail Content : This is text content

Attachment : log.txt


120 : Spring – Sending E-mail via Gmail SMTP server with MailSender


Spring comes with a useful ‘org.springframework.mail.javamail.JavaMailSenderImpl‘ class to simplify the e-mail sending process via JavaMail API. Here’s a 
Maven build project to use Spring’s ‘JavaMailSenderImpl‘ to send an email via Gmail SMTP server.

1. Project dependency
Add the JavaMail and Spring’s dependency.

File : pom.xml

<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
  http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.mkyong.common</groupId>
  <artifactId>SpringExample</artifactId>
  <packaging>jar</packaging>
  <version>1.0-SNAPSHOT</version>
  <name>SpringExample</name>
  <url>http://maven.apache.org</url>

  <repositories>
  	<repository>
  		<id>Java.Net</id>
  		<url>http://download.java.net/maven/2/</url>
  	</repository>
  </repositories>

  <dependencies>

    <dependency>
              <groupId>junit</groupId>
              <artifactId>junit</artifactId>
              <version>3.8.1</version>
             <scope>test</scope>
    </dependency>

    <!-- Java Mail API -->
    <dependency>
	    <groupId>javax.mail</groupId>
	    <artifactId>mail</artifactId>
	    <version>1.4.3</version>
    </dependency>

    <!-- Spring framework -->
    <dependency>
     	    <groupId>org.springframework</groupId>
	    <artifactId>spring</artifactId>
	    <version>2.5.6</version>
    </dependency>

  </dependencies>
</project>

 
2. Spring’s Mail Sender
A Java class to send email with the Spring’s MailSender interface.

File : MailMail.java

package com.mkyong.common;

import org.springframework.mail.MailSender;
import org.springframework.mail.SimpleMailMessage;

public class MailMail
{
	private MailSender mailSender;

	public void setMailSender(MailSender mailSender) {
		this.mailSender = mailSender;
	}

	public void sendMail(String from, String to, String subject, String msg) {

		SimpleMailMessage message = new SimpleMailMessage();

		message.setFrom(from);
		message.setTo(to);
		message.setSubject(subject);
		message.setText(msg);
		mailSender.send(message);
	}
}

 
3. Bean configuration file
Configure the mailSender bean and specify the email details for the Gmail SMTP server.

Note
Gmail configuration details – http://mail.google.com/support/bin/answer.py?hl=en&answer=13287
File : Spring-Mail.xml

<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

<bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl">
	<property name="host" value="smtp.gmail.com" />
	<property name="port" value="587" />
	<property name="username" value="username" />
	<property name="password" value="password" />

	<property name="javaMailProperties">
	   <props>
       	      <prop key="mail.smtp.auth">true</prop>
       	      <prop key="mail.smtp.starttls.enable">true</prop>
       	   </props>
	</property>
</bean>

<bean id="mailMail" class="com.mkyong.common.MailMail">
	<property name="mailSender" ref="mailSender" />
</bean>

</beans>
4. Run it
package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App
{
    public static void main( String[] args )
    {
    	ApplicationContext context =
             new ClassPathXmlApplicationContext("Spring-Mail.xml");

    	MailMail mm = (MailMail) context.getBean("mailMail");
        mm.sendMail("from@no-spam.com",
    		   "to@no-spam.com",
    		   "Testing123",
    		   "Testing only \n\n Hello Spring Email Sender");

    }
}


121 : Spring – Define an E-mail template in bean configuration file


In last Spring’s email tutorial, you hard-code all the email properties and message content in the method body, it’s not practical and should be avoid. You 
should consider define the email message template in the Spring’s bean configuration file.

1. Project dependency
Add the JavaMail and Spring’s dependency.

File : pom.xml

<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
  http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.mkyong.common</groupId>
  <artifactId>SpringExample</artifactId>
  <packaging>jar</packaging>
  <version>1.0-SNAPSHOT</version>
  <name>SpringExample</name>
  <url>http://maven.apache.org</url>

  <repositories>
  	<repository>
  		<id>Java.Net</id>
  		<url>http://download.java.net/maven/2/</url>
  	</repository>
  </repositories>

  <dependencies>

    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>3.8.1</version>
        <scope>test</scope>
    </dependency>

    <!-- Java Mail API -->
    <dependency>
	    <groupId>javax.mail</groupId>
	    <artifactId>mail</artifactId>
	    <version>1.4.3</version>
    </dependency>

    <!-- Spring framework -->
    <dependency>
     	<groupId>org.springframework</groupId>
	    <artifactId>spring</artifactId>
	    <version>2.5.6</version>
    </dependency>

  </dependencies>
</project>

 
2. Spring’s Mail Sender
A Java class to send email with the Spring’s MailSender interface, and use the String.format to replace the email message ‘%s‘ with passing variable in bean
 configuration file.

File : MailMail.java

package com.mkyong.common;

import org.springframework.mail.MailSender;
import org.springframework.mail.SimpleMailMessage;

public class MailMail
{
	private MailSender mailSender;
	private SimpleMailMessage simpleMailMessage;

	public void setSimpleMailMessage(SimpleMailMessage simpleMailMessage) {
		this.simpleMailMessage = simpleMailMessage;
	}

	public void setMailSender(MailSender mailSender) {
		this.mailSender = mailSender;
	}

	public void sendMail(String dear, String content) {

	   SimpleMailMessage message = new SimpleMailMessage(simpleMailMessage);

	   message.setText(String.format(
			simpleMailMessage.getText(), dear, content));

	   mailSender.send(message);

	}
}

 
3. Bean configuration file
Define the email template ‘customeMailMessage‘ and mail sender details in the bean configuration file.

File : Spring-Mail.xml

<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

<bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl">
	<property name="host" value="smtp.gmail.com" />
	<property name="port" value="587" />
	<property name="username" value="username" />
	<property name="password" value="password" />

	<property name="javaMailProperties">
	     <props>
           	<prop key="mail.smtp.auth">true</prop>
           	<prop key="mail.smtp.starttls.enable">true</prop>
       	     </props>
	</property>
</bean>

<bean id="mailMail" class="com.mkyong.common.MailMail">
	<property name="mailSender" ref="mailSender" />
	<property name="simpleMailMessage" ref="customeMailMessage" />
</bean>

<bean id="customeMailMessage"
	class="org.springframework.mail.SimpleMailMessage">

	<property name="from" value="from@no-spam.com" />
	<property name="to" value="to@no-spam.com" />
	<property name="subject" value="Testing Subject" />
	<property name="text">
	   <value>
		<![CDATA[
			Dear %s,
			Mail Content : %s
		]]>
	   </value>
        </property>
</bean>

</beans>
4. Run it
package com.mkyong.common;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App
{
    public static void main( String[] args )
    {
    	ApplicationContext context =
           new ClassPathXmlApplicationContext("Spring-Mail.xml");

    	MailMail mm = (MailMail) context.getBean("mailMail");
        mm.sendMail("Yong Mook Kim", "This is text content");

    }
}
output

Dear Yong Mook Kim,
Mail Content : This is text content


122 : Difference between SimpleJdbcTemplate and JdbcTemplate.

This statement was true a few version's ago. But now (3.0 version) JdbcTemplate can support autoboxing and varargs, so there is no real need for
SimpleJdbcTemplate. In fact it might be depricated in version 3.1.I can confirm that SimpleJdbcTemplate and SimpleJdbcDaoSupport are deprecated in 3.1. 

SimpleJdbcTemplate 
Deprecated. since Spring 3.1 in favor of JdbcTemplate and NamedParameterJdbcTemplate. The JdbcTemplate and NamedParameterJdbcTemplate now provide all the
functionality of the SimpleJdbcTemplate. 

SimpleJdbcDaoSupport 
Deprecated. since Spring 3.1 in favor of JdbcDaoSupport and NamedParameterJdbcDaoSupport. The JdbcTemplate and NamedParameterJdbcTemplate now provide all the 
functionality of the SimpleJdbcTemplate.


JdbcTemplate										SimpleJdbcTemplate

Manually need to cast the returning object or       No overhead of casting to the required type as it does automatically (Rich API)
list of objects from the query, making the
developers work more cumbersome.	

Passing the input arguments as an object array		Whereas in this case, we can simply pass the value as the input arguments. For example, playerId or 
to the query, should be in the format				player_id, name, age and matches.
“new Object[]{ ….  }”. For example,
new Object[] { playerId, name, age, matches }	


 Spring JdbcTemplate : 
The following snippet shows the insertForum() method using the JDBCTemplate.

 @Override
    public void insert(Forum forum) {
        String query = "insert into tbforum(forumId,forumName,forumDesc) values(?,?,?)";
        jdbcTemplate.update(query, new Object[]{
            forum.getForumId(),forum.getForumName(),forum.getForumDesc()
        });
        System.out.println("Record Inserted successfully");
    }

Spring SimpleJdbcTemplate - Advantage: When using SimpleJDBCTemplate you can use the variable length arguments instead of an Object array. There is no need to
explicitly typecast int to Integer.

@Override
    public void insert(Forum forum) {
        String query = "insert into tbforum(forumId,forumName,forumDesc) values(?,?,?)";
        simpleJDBCTemplate.update(query, forum.getForumId(),forum.getForumName(),forum.getForumDesc());
        System.out.println("Record Inserted successfully");
    }

 2. Spring JdbcTemplate : The following snippet shows the selectForum() method using the 
JDBCTemplate.

 @Override
    public Forum selectForum(int forumId) {
        String query="select * from tbforum where forumId=?";
       
        return (Forum)jdbcTemplate.queryForObject(query, new Object[]{forumId}, 
                new RowMapper(){
                        @Override
                        public Object mapRow(ResultSet rs, int rowNum) throws SQLException {
                            return new Forum(rs.getInt("forumId"),rs.getString("forumName"), rs.getString("forumDesc"));
                        };              
                });       
    }

Spring SimpleJdbcTemplate  - Advantage: Here when using SimpleJDBCTemplate you need not explicitly typecast the return object, the ParameterizedRowMapper 
object's type parameter will be taken by default. The return type of the mapRow() method is Forum instead of Object because in Java 5 you can have covariant 
return types. Since the statement parameter can be of variable length the forumId is specified at the end of the list. 

 @Override
    public Forum selectForum(int forumId) {
        String query="select * from tbforum where forumId=?";
       
        return simpleJDBCTemplate.queryForObject(query, 
                new ParameterizedRowMapper(){
                        @Override
                        public Forum mapRow(ResultSet rs, int rowNum) throws SQLException {
                            return new Forum(rs.getInt("forumId"),rs.getString("forumName"), rs.getString("forumDesc"));
                        };              
                },forumId);       
    }

How to run : In order to run this, you can use following code in Main Java Class and execute require method using forumDAOObject.

ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
 ForumDAO forumDAO = (ForumDAO) context.getBean("forumDAO")

 
123 : Spring configuration file
Spring configuration file is an XML file. This file contains the classes information and describes how these classes are configured and introduced to each 
other.

124 : Explain the Core Container (Application context) module
This is the basic Spring module, which provides the fundamental functionality of the Spring framework. BeanFactory is the heart of any spring-based
application. Spring framework was built on the top of this module, which makes the Spring container.


125 : What are the common implementations of the ApplicationContext?

The FileSystemXmlApplicationContext container loads the definitions of the beans from an XML file. The full path of the XML bean configuration file must be 
provided to the constructor.

The ClassPathXmlApplicationContext container also loads the definitions of the beans from an XML file. Here, you need to set CLASSPATH properly because this 
container will look bean configuration XML file in CLASSPATH.

The WebXmlApplicationContext: container loads the XML file with definitions of all beans from within a web application


126 : Which DI would you suggest Constructor-based or setter-based DI?
You can use both Constructor-based and Setter-based Dependency Injection. The best solution is using constructor arguments for mandatory dependencies and 
setters for optional dependencies.


127 : What are Spring beans?
The Spring Beans are Java Objects that form the backbone of a Spring application. They are instantiated, assembled, and managed by the Spring IoC container. 
These beans are created with the configuration metadata that is supplied to the container, for example, in the form of XML <bean/> definitions.
Beans defined in spring framework are singleton beans. There is an attribute in bean tag named "singleton" if specified true then bean becomes singleton and 
if set to false then the bean becomes a prototype bean. By default it is set to true. So, all the beans in spring framework are by default singleton beans.


128 : What does a Spring Bean definition contain?
A Spring Bean definition contains all configuration metadata which is needed for the container to know how to create a bean, its lifecycle details and its 
dependencies.


129 : How do you define the scope of a bean?
When defining a <bean> in Spring, we can also declare a scope for the bean. It can be defined through the scope attribute in the bean definition. For example,
when Spring has to produce a new bean instance each time one is needed, the bean’s scope attribute to be prototype. On the other hand, when the same instance
of a bean must be returned by Spring every time it is needed, the the bean scope attribute must be set to singleton.


130 : What are inner beans in Spring?
When a bean is only used as a property of another bean it can be declared as an inner bean. Spring’s XML-based configuration metadata provides the use of 
<bean/> element inside the <property/> or <constructor-arg/> elements of a bean definition, in order to define the so-called inner bean. Inner beans are
always anonymous and they are always scoped as prototypes.


131 : What is Spring Java-Based Configuration? Give some annotation example.
Java based configuration option enables you to write most of your Spring configuration without XML but with the help of few Java-based annotations. An example
is the @Configuration annotation, that indicates that the class can be used by the Spring IoC container as a source of bean definitions. Another example is 
the@Bean annotated method that will return an object that should be registered as a bean in the Spring application context.


132 : How do you turn on annotation wiring?

Annotation wiring is not turned on in the Spring container by default. In order to use annotation based wiring we must enable it in our Spring configuration 
file by configuring <context:annotation-config/> element.

133 : Spring @Qualifier Annotation

(a)

There may be a situation when you create more than one bean of the same type and want to wire only one of them with a property, in such case you can use 
@Qualifier annotation along with @Autowired to remove the confusion by specifying which exact bean will be wired. Below is an example to show the use of 
@Qualifier annotation.

Example:
Let us have working Eclipse IDE in place and follow the following steps to create a Spring application:

Step	Description
1	Create a project with a name SpringExample and create a package com.tutorialspoint under the src folder in the created project.
2	Add required Spring libraries using Add External JARs option as explained in the Spring Hello World Example chapter.
3	Create Java classes Student, Profile and MainApp under the com.tutorialspoint package.
4	Create Beans configuration file Beans.xml under the src folder.
5	The final step is to create the content of all the Java files and Bean Configuration file and run the application as explained below.
Here is the content of Student.java file:

package com.tutorialspoint;

public class Student {
   private Integer age;
   private String name;

   public void setAge(Integer age) {
      this.age = age;
   }
   
   public Integer getAge() {
      return age;
   }

   public void setName(String name) {
      this.name = name;
   }
   
   public String getName() {
      return name;
   }
}
Here is the content of Profile.java file:

package com.tutorialspoint;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class Profile {
   @Autowired
   @Qualifier("student1")
   private Student student;

   public Profile(){
      System.out.println("Inside Profile constructor." );
   }

   public void printAge() {
      System.out.println("Age : " + student.getAge() );
   }

   public void printName() {
      System.out.println("Name : " + student.getName() );
   }
}
Following is the content of the MainApp.java file:

package com.tutorialspoint;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MainApp {
   public static void main(String[] args) {
      ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");

      Profile profile = (Profile) context.getBean("profile");

      profile.printAge();
      profile.printName();
   }
}
Consider the example of following configuration file Beans.xml:

<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-3.0.xsd">

   <context:annotation-config/>

   <!-- Definition for profile bean -->
   <bean id="profile" class="com.tutorialspoint.Profile">
   </bean>

   <!-- Definition for student1 bean -->
   <bean id="student1" class="com.tutorialspoint.Student">
      <property name="name"  value="Zara" />
      <property name="age"  value="11"/>
   </bean>

   <!-- Definition for student2 bean -->
   <bean id="student2" class="com.tutorialspoint.Student">
      <property name="name"  value="Nuha" />
      <property name="age"  value="2"/>
   </bean>

</beans>
Once you are done with creating source and bean configuration files, let us run the application. If everything is fine with your application, this will print
the following message:

Inside Profile constructor.
Age : 11
Name : Zar

: How do you provide configuration metadata to the Spring Container?
There are three important methods to provide configuration metadata to the Spring Container:
XML based configuration file.
Annotation-based configuration
Java-based configuration

(b)

Spring Autowiring @Qualifier example
By mkyong | June 11, 2011 | Updated : August 29, 2012 | Viewed : 214,355 times +1,387 pv/w

In Spring, @Qualifier means, which bean is qualify to autowired on a field. See following scenario :

Autowiring Example
See below example, it will autowired a “person” bean into customer’s person property.

package com.mkyong.common;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class Customer {

	@Autowired
	private Person person;
	//...
}
But, two similar beans “com.mkyong.common.Person” are declared in bean configuration file. Will Spring know which person bean should autowired?

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

<bean
class ="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/>

	<bean id="customer" class="com.mkyong.common.Customer" />

	<bean id="personA" class="com.mkyong.common.Person" >
		<property name="name" value="mkyongA" />
	</bean>

	<bean id="personB" class="com.mkyong.common.Person" >
		<property name="name" value="mkyongB" />
	</bean>

</beans>
When you run above example, it hits below exception :

Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException:
	No unique bean of type [com.mkyong.common.Person] is defined:
		expected single matching bean but found 2: [personA, personB]

 
@Qualifier Example
To fix above problem, you need @Quanlifier to tell Spring about which bean should autowired.

package com.mkyong.common;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class Customer {

	@Autowired
	@Qualifier("personA")
	private Person person;
	//...
}
In this case, bean “personA” is autowired.

Customer [person=Person [name=mkyongA]]


134 : Spring @Autowired Annotation
The @Autowired annotation provides more fine-grained control over where and how autowiring should be accomplished. The @Autowired annotation can be used to
autowire bean on the setter method just like @Required annotation, constructor, a property or methods with arbitrary names and/or multiple arguments.

@Autowired on Setter Methods:
You can use @Autowired annotation on setter methods to get rid of the <property> element in XML configuration file. When Spring finds an @Autowired annotation used with setter methods, it tries to perform byType autowiring on the method.

Example
Let us have working Eclipse IDE in place and follow the following steps to create a Spring application:

Step	Description
1	Create a project with a name SpringExample and create a package com.tutorialspoint under the src folder in the created project.
2	Add required Spring libraries using Add External JARs option as explained in the Spring Hello World Example chapter.
3	Create Java classes TextEditor, SpellChecker and MainApp under the com.tutorialspoint package.
4	Create Beans configuration file Beans.xml under the src folder.
5	The final step is to create the content of all the Java files and Bean Configuration file and run the application as explained below.
Here is the content of TextEditor.java file:

package com.tutorialspoint;

import org.springframework.beans.factory.annotation.Autowired;

public class TextEditor {
   private SpellChecker spellChecker;

   @Autowired
   public void setSpellChecker( SpellChecker spellChecker ){
      this.spellChecker = spellChecker;
   }
   public SpellChecker getSpellChecker( ) {
      return spellChecker;
   }
   public void spellCheck() {
      spellChecker.checkSpelling();
   }
}
Following is the content of another dependent class file SpellChecker.java:

package com.tutorialspoint;

public class SpellChecker {
   public SpellChecker(){
      System.out.println("Inside SpellChecker constructor." );
   }

   public void checkSpelling(){
      System.out.println("Inside checkSpelling." );
   }
   
}
Following is the content of the MainApp.java file:

package com.tutorialspoint;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MainApp {
   public static void main(String[] args) {
      ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");

      TextEditor te = (TextEditor) context.getBean("textEditor");

      te.spellCheck();
   }
}
Following is the configuration file Beans.xml:

<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-3.0.xsd">

   <context:annotation-config/>

   <!-- Definition for textEditor bean without constructor-arg  -->
   <bean id="textEditor" class="com.tutorialspoint.TextEditor">
   </bean>

   <!-- Definition for spellChecker bean -->
   <bean id="spellChecker" class="com.tutorialspoint.SpellChecker">
   </bean>

</beans>
Once you are done with creating source and bean configuration files, let us run the application. If everything is fine with your application, this will print
the following message:

Inside SpellChecker constructor.
Inside checkSpelling.


@Autowired on Properties:
You can use @Autowired annotation on properties to get rid of the setter methods. When you will pass values of autowired properties using <property> Spring 
will automatically assign those properties with the passed values or references. So with the usage of @Autowired on properties your TextEditor.java file will 
become as follows:

package com.tutorialspoint;

import org.springframework.beans.factory.annotation.Autowired;

public class TextEditor {
   @Autowired
   private SpellChecker spellChecker;

   public TextEditor() {
      System.out.println("Inside TextEditor constructor." );
   }
   
   public SpellChecker getSpellChecker( ){
      return spellChecker;
   }
   
   public void spellCheck(){
      spellChecker.checkSpelling();
   }
}
Following is the configuration file Beans.xml:

<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-3.0.xsd">

   <context:annotation-config/>

   <!-- Definition for textEditor bean -->
   <bean id="textEditor" class="com.tutorialspoint.TextEditor">
   </bean>

   <!-- Definition for spellChecker bean -->
   <bean id="spellChecker" class="com.tutorialspoint.SpellChecker">
   </bean>

</beans>
Once you are done with the above two changes in source and bean configuration files, let us run the application. If everything is fine with your application,
this will print the following message:

Inside TextEditor constructor.
Inside SpellChecker constructor.
Inside checkSpelling.


@Autowired on Constructors:
You can apply @Autowired to constructors as well. A constructor @Autowired annotation indicates that the constructor should be autowired when creating the 
bean, even if no <constructor-arg> elements are used while configuring the bean in XML file. Let us check the following example.

Here is the content of TextEditor.java file:

package com.tutorialspoint;

import org.springframework.beans.factory.annotation.Autowired;

public class TextEditor {
   private SpellChecker spellChecker;

   @Autowired
   public TextEditor(SpellChecker spellChecker){
      System.out.println("Inside TextEditor constructor." );
      this.spellChecker = spellChecker;
   }

   public void spellCheck(){
      spellChecker.checkSpelling();
   }
}
Following is the configuration file Beans.xml:

<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-3.0.xsd">

   <context:annotation-config/>

   <!-- Definition for textEditor bean without constructor-arg  -->
   <bean id="textEditor" class="com.tutorialspoint.TextEditor">
   </bean>

   <!-- Definition for spellChecker bean -->
   <bean id="spellChecker" class="com.tutorialspoint.SpellChecker">
   </bean>

</beans>
Once you are done with the above two changes in source and bean configuration files, let us run the application. If everything is fine with your application, 
this will print the following message:

Inside TextEditor constructor.
Inside SpellChecker constructor.
Inside checkSpelling.


@Autowired with (required=false) option
By default, the @Autowired annotation implies the dependency is required similar to @Required annotation, however, you can turn off the default behavior by
 using (required=false) option with @Autowired.

The following example will work even if you do not pass any value for age property but still it will demand for name property. You can try this example 
yourself because this is similar to @Required annotation example except that only Student.java file has been changed.

package com.tutorialspoint;

import org.springframework.beans.factory.annotation.Autowired;

public class Student {
   private Integer age;
   private String name;

   @Autowired(required=false)
   public void setAge(Integer age) {
      this.age = age;
   }
   
   public Integer getAge() {
      return age;
   }

   @Autowired
   public void setName(String name) {
      this.name = name;
   }
   
   public String getName() {
      return name;
   }
}


135 :  How can JDBC be used more efficiently in the Spring framework?
When using the Spring JDBC framework the burden of resource management and error handling is reduced. So developers only need to write the statements and 
queries to get the data to and from the database. JDBC can be used more efficiently with the help of a template class provided by Spring framework, which is
the JdbcTemplate


136 : There are two ways to access Hibernate with Spring:
Inversion of Control with a Hibernate Template and Callback.
Extending HibernateDAOSupport and Applying an AOP Interceptor node.


137 : Types of the transaction management Spring support

Spring supports two types of transaction management:

Programmatic transaction management: This means that you have managed the transaction with the help of programming. That gives you extreme flexibility, but it
is difficult to maintain.

Declarative transaction management: This means you separate transaction management from the business code. You only use annotations or XML based configuration
to manage the transactions.


138 : What is the difference between concern and cross-cutting concern in Spring AOP
The Concern is behavior we want to have in a module of an application. A Concern may be defined as a functionality we want to implement.

The cross-cutting concern is a concern which is applicable throughout the application and it affects the entire application. For example, logging, security 
and data transfer are the concerns which are needed in almost every module of an application, hence they are cross-cutting concerns.


139 : What is Weaving? What are the different points where weaving can be applied?
Weaving is the process of linking aspects with other application types or objects to create an advised object. Weaving can be done at compile time, at load 
time, or at runtime.


140 : DispatcherServlet
The Spring Web MVC framework is designed around a DispatcherServlet that handles all the HTTP requests and responses.


141 : WebApplicationContext
The WebApplicationContext is an extension of the plain ApplicationContext that has some extra features necessary for web applications. It differs from a 
normal ApplicationContext in that it is capable of resolving themes, and that it knows which servlet it is associated with.


142 : What is Bean Factory?

Bean Factory is core of the spring framework and, it is a Lightweight container which loads bean definitions and manages your beans.  Beans are configured 
using XML file and manage singleton defined bean. It is also responsible for life cycle methods and injects dependencies. It also removes adhoc singletons 
and factories.


143 : State the differences between ApplicationContext and BeanFactory in spring?

ApplicationContext allows more than one config files to exist while BeanFactory only permits one.
ApplicationContext also provides support for application of lifecycle events, internationalization messages and validation and also provides services like EJB
integration, remoting, JNDI access and scheduling. These features too are not supported by Bean Factory.


144 : When are declarative and programmatic transaction management used?

When only a small amount of transactional operations is there, it is advised to use Programmatic transaction management. But if there is a big amount of 
transactional operations to be taken care of, declarative transaction management is preferred.


145 : What classes are used to Control the database connection?

Following are the classes that are used to control database connection:

Data Source Utils
SmartData Source
AbstractData Source
SingleConnection DataSource
DriverManager DataSource
TransactionAware DataSourceProxy
DataSource  TransactionManager


146 : Describe about DAO in Spring framework?

DAO is used to provide integration of Java database connectivity and Object relational mapping objects. DAO is spring framework provides connection for JDBC,
 hibernate, JDO, JPA, Common client interface and Oracle.
 

147 : What is ‘Throws advice’ in Spring?

‘Throws Advice’ define the behavior when an exception occurs. It is an interface and it has no methods which need to be implemented. A class that implements
this interface should have method with this signature:

Void samplethrow (Throw table t)
Void samplethrow(Method m, Object[] o, Object target, Throw tablet) 


148 : Why is declarative transaction management preferred in Spring?

Declarative transaction management has minimum impact on the application code and, therefore, is an idealistic lightweight container.

149 : Explain the concept of a BeanFactory?

BeanFactory applies the idea of a factory pattern that utilizes IOC to separate the application’s dependencies and configuration from the actual code.

150 : Spring init-method and destroy-method example

In Spring, you can use init-method and destroy-method as attribute in bean configuration file for bean to perform certain actions upon initialization and 
destruction. Alternative to InitializingBean and DisposableBean interface.

Example
Here’s an example to show you how to use init-method and destroy-method.

package com.mkyong.customer.services;

public class CustomerService
{
	String message;

	public String getMessage() {
	  return message;
	}

	public void setMessage(String message) {
	  this.message = message;
	}

	public void initIt() throws Exception {
	  System.out.println("Init method after properties are set : " + message);
	}

	public void cleanUp() throws Exception {
	  System.out.println("Spring Container is destroy! Customer clean up");
	}

}
File : Spring-Customer.xml, define init-method and destroy-method attribute in your bean.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="customerService" class="com.mkyong.customer.services.CustomerService"
		init-method="initIt" destroy-method="cleanUp">

		<property name="message" value="i'm property message" />
	</bean>

</beans>
Run it

package com.mkyong.common;

import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.mkyong.customer.services.CustomerService;

public class App
{
    public static void main( String[] args )
    {
    	ConfigurableApplicationContext context =
		new ClassPathXmlApplicationContext(new String[] {"Spring-Customer.xml"});

    	CustomerService cust = (CustomerService)context.getBean("customerService");

    	System.out.println(cust);

    	context.close();
    }
}
The ConfigurableApplicationContext.close will close the application context, releasing all resources and destroying all cached singleton beans.

Output

Init method after properties are set : i'm property message
com.mkyong.customer.services.CustomerService@47393f
...
INFO: Destroying singletons in org.springframework.beans.factory.
support.DefaultListableBeanFactory@77158a:
defining beans [customerService]; root of factory hierarchy
Spring Container is destroy! Customer clean up
The initIt() method is called, after the message property is set, and the cleanUp() method is called after the context.close();

Thoughts…
It’s always recommended to use init-method and destroy-method in bean configuration file, instead of implement the InitializingBean and DisposableBean interface to cause unnecessarily coupled your code to Spring.


150 : Spring - Bean Life Cycle
The life cycle of a Spring bean is easy to understand. When a bean is instantiated, it may be required to perform some initialization to get it into a usable
state. Similarly, when the bean is no longer required and is removed from the container, some cleanup may be required. Though, there is lists of the
activities that take place behind the scenes between the time of bean Instantiation and its destruction, but this chapter will discuss only two important bean
lifecycle callback methods which are required at the time of bean initialization and its destruction.

To define setup and teardown for a bean, we simply declare the <bean> with init-method and/or destroy-method parameters. The init-method attribute specifies a
method that is to be called on the bean immediately upon instantiation. Similarly, destroy-method specifies a method that is called just before a bean is
removed from the container.


Initialization callbacks:
The org.springframework.beans.factory.InitializingBean interface specifies a single method:

void afterPropertiesSet() throws Exception;
So you can simply implement above interface and initialization work can be done inside afterPropertiesSet() method as follows:

public class ExampleBean implements InitializingBean {
   public void afterPropertiesSet() {
      // do some initialization work
   }
}
In the case of XML-based configuration metadata, you can use the init-method attribute to specify the name of the method that has a void no-argument 
signature. For example:

<bean id="exampleBean" 
         class="examples.ExampleBean" init-method="init"/>
Following is the class definition:

public class ExampleBean {
   public void init() {
      // do some initialization work
   }
}


Destruction callbacks
The org.springframework.beans.factory.DisposableBean interface specifies a single method:

void destroy() throws Exception;
So you can simply implement above interface and finalization work can be done inside destroy() method as follows:

public class ExampleBean implements DisposableBean {
   public void destroy() {
      // do some destruction work
   }
}
In the case of XML-based configuration metadata, you can use the destroy-method attribute to specify the name of the method that has a void no-argument 
signature. For example:

<bean id="exampleBean"
         class="examples.ExampleBean" destroy-method="destroy"/>
Following is the class definition:

public class ExampleBean {
   public void destroy() {
      // do some destruction work
   }
}
If you are using Spring's IoC container in a non-web application environment; for example, in a rich client desktop environment; you register a shutdown hook
with the JVM. Doing so ensures a graceful shutdown and calls the relevant destroy methods on your singleton beans so that all resources are released. It is 
recommended that you do not use the InitializingBean or DisposableBean callbacks, because XML configuration gives much flexibility in terms of naming your 
method.

Example:
package com.tutorialspoint;

public class HelloWorld {
   private String message;

   public void setMessage(String message){
      this.message  = message;
   }
   public void getMessage(){
      System.out.println("Your Message : " + message);
   }
   public void init(){
      System.out.println("Bean is going through init.");
   }
   public void destroy(){
      System.out.println("Bean will destroy now.");
   }
}
Following is the content of the MainApp.java file. Here you need to register a shutdown hook registerShutdownHook() method that is declared on the 
AbstractApplicationContext class. This will ensures a graceful shutdown and calls the relevant destroy methods.

package com.tutorialspoint;

import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MainApp {
   public static void main(String[] args) {

      AbstractApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");

      HelloWorld obj = (HelloWorld) context.getBean("helloWorld");
      obj.getMessage();
      context.registerShutdownHook();
   }
}
Following is the configuration file Beans.xml required for init and destroy methods:

<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <bean id="helloWorld" 
       class="com.tutorialspoint.HelloWorld"
       init-method="init" destroy-method="destroy">
       <property name="message" value="Hello World!"/>
   </bean>

</beans>
Once you are done with creating source and bean configuration files, let us run the application. If everything is fine with your application, this will print
the following message:

Bean is going through init.
Your Message : Hello World!
Bean will destroy now.

If you have too many beans having initialization and or destroy methods with the same name, you don't need to declare init-method and destroy-method on each
individual bean. Instead framework provides the flexibility to configure such situation using default-init-method and default-destroy-method attributes on the
<beans> element as follows:

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"
    default-init-method="init" 
    default-destroy-method="destroy">

   <bean id="..." class="...">
       <!-- collaborators and configuration for this bean go here -->
   </bean>

</beans>


151 : What is the web module?

The web module enables the creation of a web application without XML. The web.xml file needs to be configured for using the web module.

152 : DAO module : 

As part of DAO module of spring, we can write regular JDBC code but the developer will not find any advantage of using Spring.
(1) : When we write the JDBC code developer has to write all traditional code as well as developer has to take care of all the exceptions.
(2) : The advantage of using DAO module is we no need to provide huge amount of code as well as we no need to handle error.
(3) : When we use DAO module we can use the pre-defined classes given by the spring because of this we can deliver the project quickly.
(4) : Spring uses "Template Design Pattern"
As part of org.springframework.jdbc.core package contains JDBCTemplate class,
As part of this class the common code which is used in all the projects available.

Introduction
The DAO package provides a JDBC-abstraction layer that removes the need to do tedious JDBC coding and parsing of database-vendor specific error codes. 

Define connection parameters
Open the connection
Specify the statement
Prepare and execute the statement
Set up the loop to iterate through the results (if any)
Do the work for each iteration
Process any exception
Handle transactions
Close the connection

The Spring Framework takes care of all the grungy, low-level details that can make JDBC such a tedious API to develop with. 

Benefits:
Make JDBC essier to use and less error prone
Framework handle the creation and release of  resources.
]Framework takes care of all exception handling


153 :  What exceptions do the DAO classes, use in Spring throw?

In spring DAO classes only throws SQLException.

154 : What is called PreparedStatementCreator?

PreparedStatementCreator is one of the most commonly used interfaces for writing data to the database. createPreparedStatement() is a method that can be used
 to create and return PreparedStatement from the Connection argument, and exception handling is automatically taken care of. When this interface is 
 implemented, a different interface SqlProvider can also be implemented which has a method called getSql(). This method is useful for providing sql strings to 
 the JdbcTemplate. It does not handle SQLExceptions.

What is SQLProvider?

SQLProvider has only one method called getSql()and it is implemented using PreparedStatementCreator implementers. It is mainly used for debugging.

														or 
														
What is PreparedStatementCreator?

- To write data to database, PreparedStatementCreator is the most commonly used interface. The interface contains one method by name createPreparedStatement().
Returning a PreparedStatement is need when this interface is implemented. Another interface, SqlProvider is also implemented along with this interface, which
has a method getSql() for providing sql strings to JdbcTemplate. Explain about PreparedStatementCreator.

- PreparedStatementCreator is one of the most common used interfaces for writing data to database. The interface has one method createPreparedStatement().
PreparedStatement createPreparedStatement(Connection conn) throws SQLException;
- When this interface is implemented, we should create and return a PreparedStatement from the Connection argument, and the exception handling is 
automatically taken care off.

- When this interface is implemented, another interface SqlProvider is also implemented which has a method called getSql() which is used to provide sql
strings to JdbcTemplate.
														
