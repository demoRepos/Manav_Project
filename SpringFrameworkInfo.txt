MVC information : 

Why we need to use MVC framework.
	
	If we are trying to create web application for using Servlet or JSP, in such case UI part of application and business logic of application resides in same 
	file then it is very difficult for UI developer and for business logic developer to work together at same time which leads to more development time. So, in 
	order to resolve this problem MVC framework will use.
	
	MVC (Model View Controller)
	
	M : Model :- Model will handle all the data that we want to display over he UI.
	V : View :- It will represent the UI part i.e represents data over the UI.
	C : Controller :- It will handle all the requests and then create the model object and then hand over the appropriate model to controller again so that 
	controller will forward the model object to view part in order to display data.

	Flow of MVC framework : 
	
		Firstly, request is come to the controller then the controller will transfer the request to appropriate model based on requested URL and then after the
		model i.e business logic operation complete then again request is send back to controller and then again controller will transfer the request to its 
		appropriate view page (to which view page we have to send the request,this we have to provide under the controller) and after the work of view page is
		completed then the data will be displayed over the browser.
		
	Spring MVC flow : 

	Firstly, the request is come to request dispatcher i.e front controller (controller is C from MVC) then handler mapping will send the request to controller 
	and from the controller	we are able to call the method based on requested URL and then model object [Model object is M from MVC] (java object) will prepared
	with data that we want to display over the view page and again model object is send back to controller and then again controller will call the specified view
	page (View page	is V from MVC).
	
Spring framework information : 

Spring framework implemented by keeping in mind to resolve the dependency injection. Dependency Injection problem is that problem in which we will create the
object of one class in another class. For example below : 

class Tea{

private void dis(){

code....

}

}

class res {

Tea t = new Tea();

private void diss(){

t.dis();

}

}

In above code, Tea class object is created in res class. This means res class is a dependent on Tea class. If we are using this approach then it is difficult
for us if in future i have change/modify the class ' Tea ' property or class name then it will become very difficult for us to change the same in all another
classes where we have used the class ' Tea ' in case of big application. So, in order to resolve this problem spring have discovered the Dependency Injection
feature. Dependency injection allows us to use the object of class ' Tea ' in another class but not by creating the object of class ' Tea ' to that class where
we want to use.


In order to create the Simple spring application you have to follow the below steps :-

1 : Create the java file.
2 : Create the configration file.
3 : Create the second java file where we call the configration file.

1 : class test {

public void getDisplay(){

System.out.println("Test");

}

}


2 : Configration file

xml format line then

<beans more attributes for spring>

<bean id = "beanID" class = "full package path with particular java file location" >

</bean>

</beans>

3 : public class mc{

public static void main(String ...f){

ApplicationContext context = new ClassPathXmlApplicationContext("configration file name.xml file");

test t = (test) context.getBean("beanID");

t.getDisplay();

}

}


I order to add property for a class ' test ' and assign value to that property by using configration file, you have to update the above code which are as
follows : 

In order to create the Simple spring application with one property and assign the value to that property in configration file you have to follow the below 
steps :-

1 : Create the java file with one property.
2 : Create the configration file and also assign value for that property.
3 : Create the second java file where we call the configration file.

1 : class test {

public String welcomeNote;

public void setWelcomeNote(String welcomeNote){

this.welcomeNote = welcomeNote;

}

public void getDisplay(){

System.out.println(welcomeNote);

}

}


2 : Configration file

xml format line then

<beans more attributes for spring>

<bean id = "beanID" class = "full package path with particular java file location" >

<property name = "welcomeNote" value = "test"/>

</bean>

</beans>

3 : public class mc{

public static void main(String ...f){

ApplicationContext context = new ClassPathXmlApplicationContext("configration file name.xml file");

test t = (test) context.getBean("beanID");

t.getDisplay();

}

}

Another example for DI : 

Dependency Injection

The Dependency Injection is a design pattern that removes the dependency of the programs. In such case we provide the information from the external source such as XML file. It makes
our code loosely coupled and easier for testing. In such case we write the code as:

class Employee{  
Address address;  
  
Employee(Address address){  
this.address=address;  
}  
public void setAddress(Address address){  
this.address=address;  
}  
  
}  
In such case, instance of Address class is provided by external source such as XML file either by constructor or setter method. Two ways to perform Dependency Injection in Spring 
framework

Spring framework provides two ways to inject dependency

By Constructor
By Setter method


Dependency Injection by Constructor Example

Dependency Injection by constructor
Injecting primitive and string-based values

We can inject the dependency by constructor. The <constructor-arg> subelement of <bean> is used for constructor injection. Here we are going to inject primitive and String-based 
values.

Injecting primitive and string-based values
Let's see the simple example to inject primitive and string-based values. We have created three files here:

Employee.java
applicationContext.xml
Test.java


Employee.java

It is a simple class containing two fields id and name. There are four constructors and one method in this class.

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
  
public Employee() {System.out.println("def cons");}  
  
public Employee(int id) {this.id = id;}  
  
public Employee(String name) {  this.name = name;}  
  
public Employee(int id, String name) {  
    this.id = id;  
    this.name = name;  
}  
  
void show(){  
    System.out.println(id+" "+name);  
}  
  
}  


applicationContext.xml

We are providing the information into the bean by this file. The constructor-arg element invokes the constructor. In such case, parameterized constructor of int type will be invoked. 
The value attribute of constructor-arg element will assign the specified value. The type attribute specifies that int parameter constructor will be invoked.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
                http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="e" class="com.javatpoint.Employee">  
<constructor-arg value="10" type="int"></constructor-arg>  
</bean>  
  
</beans>  


Test.java

This class gets the bean from the applicationContext.xml file and calls the show method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.*;  
  
public class Test {  
    public static void main(String[] args) {  
          
        Resource r=new ClassPathResource("applicationContext.xml");  
        BeanFactory factory=new XmlBeanFactory(r);  
          
        Employee s=(Employee)factory.getBean("e");  
        s.show();  
          
    }  
}  

Output:10 null


Injecting string-based values

If you don't specify the type attribute in the constructor-arg element, by default string type constructor will be invoked.
<bean id="e" class="com.javatpoint.Employee">  
<constructor-arg value="10"></constructor-arg>  
</bean>  

If you change the bean element as given above, string parameter constructor will be invoked and the output will be 0 10.

Output:0 10


You may also pass the string literal as following:
<bean id="e" class="com.javatpoint.Employee">  
<constructor-arg value="Sonoo"></constructor-arg>  
</bean>  

Output:0 Sonoo


You may pass integer literal and string both as following
<bean id="e" class="com.javatpoint.Employee">  
<constructor-arg value="10" type="int" ></constructor-arg>  
<constructor-arg value="Sonoo"></constructor-arg>  
</bean>  

Output:10 Sonoo


Constructor Injection with Dependent Object

Constructor Injection with Dependent Object
If there is HAS-A relationship between the classes, we create the instance of dependent object (contained object) first then pass it as an argument of the main class constructor. Here, our scenario is Employee HAS-A Address. The Address class object will be termed as the dependent object. Let's see the Address class first:

Address.java
This class contains three properties, one constructor and toString() method to return the values of these object.

package com.javatpoint;  
  
public class Address {  
private String city;  
private String state;  
private String country;  
  
public Address(String city, String state, String country) {  
    super();  
    this.city = city;  
    this.state = state;  
    this.country = country;  
}  
  
public String toString(){  
    return city+" "+state+" "+country;  
}  
}  


Employee.java
It contains three properties id, name and address(dependent object) ,two constructors and show() method to show the records of the current object including the depedent object.

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private Address address;//Aggregation  
  
public Employee() {System.out.println("def cons");}  
  
public Employee(int id, String name, Address address) {  
    super();  
    this.id = id;  
    this.name = name;  
    this.address = address;  
}  
  
void show(){  
    System.out.println(id+" "+name);  
    System.out.println(address.toString());  
}  
  
}  


applicationContext.xml
The ref attribute is used to define the reference of another object, such way we are passing the dependent object as an constructor argument.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
                http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="a1" class="com.javatpoint.Address">  
<constructor-arg value="ghaziabad"></constructor-arg>  
<constructor-arg value="UP"></constructor-arg>  
<constructor-arg value="India"></constructor-arg>  
</bean>  
  
  
<bean id="e" class="com.javatpoint.Employee">  
<constructor-arg value="12" type="int"></constructor-arg>  
<constructor-arg value="Sonoo"></constructor-arg>  
<constructor-arg>  
<ref bean="a1"/>  
</constructor-arg>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the show method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.*;  
  
public class Test {  
    public static void main(String[] args) {  
          
        Resource r=new ClassPathResource("applicationContext.xml");  
        BeanFactory factory=new XmlBeanFactory(r);  
          
        Employee s=(Employee)factory.getBean("e");  
        s.show();  
          
    }  



Constructor Injection with Collection Example

We can inject collection values by constructor in spring framework. There can be used three elements inside the constructor-arg element.It can be:
list
set
map

Each collection can have string based and non-string based values. In this example, we are taking the example of Forum where One question can have multiple answers. There are three 
pages:

Question.java
applicationContext.xml
Test.java

In this example, we are using list that can have duplicate elements, you may use set that have only unique elements. But, you need to change list to set in the applicationContext.xml
file and List to Set in the Question.java file.


Question.java
This class contains three properties, two constructors and displayInfo() method that prints the information. Here, we are using List to contain the multiple answers.

package com.javatpoint;  
  
import java.util.Iterator;  
import java.util.List;  
  
public class Question {  
private int id;  
private String name;  
private List<String> answers;  
  
public Question() {}  
public Question(int id, String name, List<String> answers) {  
    super();  
    this.id = id;  
    this.name = name;  
    this.answers = answers;  
}  
  
public void displayInfo(){  
    System.out.println(id+" "+name);  
    System.out.println("answers are:");  
    Iterator<String> itr=answers.iterator();  
    while(itr.hasNext()){  
        System.out.println(itr.next());  
    }  
}  
  
}  


applicationContext.xml
The list element of constructor-arg is used here to define the list.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="q" class="com.javatpoint.Question">  
<constructor-arg value="111"></constructor-arg>  
<constructor-arg value="What is java?"></constructor-arg>  
<constructor-arg>  
<list>  
<value>Java is a programming language</value>  
<value>Java is a Platform</value>  
<value>Java is an Island of Indonasia</value>  
</list>  
</constructor-arg>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Question q=(Question)factory.getBean("q");  
    q.displayInfo();  
      
}  
}


Constructor Injection with Non-String Collection (having Dependent Object) Example

If we have dependent object in the collection, we can inject these information by using the ref element inside the list, set or map. In this example, we are taking the example of
Forum where One question can have multiple answers. But Answer has its own information such as answerId, answer and postedBy. There are four pages used in this example:

Question.java
Answer.java
applicationContext.xml
Test.java

In this example, we are using list that can have duplicate elements, you may use set that have only unique elements. But, you need to change list to set in the applicationContext.xml
file and List to Set in the Question.java file.


Question.java
This class contains three properties, two constructors and displayInfo() method that prints the information. Here, we are using List to contain the multiple answers.

package com.javatpoint;  
  
import java.util.Iterator;  
import java.util.List;  
  
public class Question {  
private int id;  
private String name;  
private List<Answer> answers;  
  
public Question() {}  
public Question(int id, String name, List<Answer> answers) {  
    super();  
    this.id = id;  
    this.name = name;  
    this.answers = answers;  
}  
  
public void displayInfo(){  
    System.out.println(id+" "+name);  
    System.out.println("answers are:");  
    Iterator<Answer> itr=answers.iterator();  
    while(itr.hasNext()){  
        System.out.println(itr.next());  
    }  
}  
  
}  


Answer.java
This class has three properties id, name and by with constructor and toString() method.

package com.javatpoint;  
  
public class Answer {  
private int id;  
private String name;  
private String by;  
  
public Answer() {}  
public Answer(int id, String name, String by) {  
    super();  
    this.id = id;  
    this.name = name;  
    this.by = by;  
}  
  
public String toString(){  
    return id+" "+name+" "+by;  
}  
}  


applicationContext.xml
The ref element is used to define the reference of another bean. Here, we are using bean attribute of ref element to specify the reference of another bean.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="ans1" class="com.javatpoint.Answer">  
<constructor-arg value="1"></constructor-arg>  
<constructor-arg value="Java is a programming language"></constructor-arg>  
<constructor-arg value="John"></constructor-arg>  
</bean>  
  
<bean id="ans2" class="com.javatpoint.Answer">  
<constructor-arg value="2"></constructor-arg>  
<constructor-arg value="Java is a Platform"></constructor-arg>  
<constructor-arg value="Ravi"></constructor-arg>  
</bean>  
  
<bean id="q" class="com.javatpoint.Question">  
<constructor-arg value="111"></constructor-arg>  
<constructor-arg value="What is java?"></constructor-arg>  
<constructor-arg>  
<list>  
<ref bean="ans1"/>  
<ref bean="ans2"/>  
</list>  
</constructor-arg>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Question q=(Question)factory.getBean("q");  
    q.displayInfo();  
      
}  
}


Constructor Injection with Map Example

In this example, we are using map as the answer that have answer with posted username. Here, we are using key and value pair both as a string. Like previous examples, it is the example
of forum where one question can have multiple answers.


Question.java
This class contains three properties, two constructors and displayInfo() method to display the information.

package com.javatpoint;  
import java.util.Iterator;  
import java.util.Map;  
import java.util.Set;  
import java.util.Map.Entry;  
  
public class Question {  
private int id;  
private String name;  
private Map<String,String> answers;  
  
public Question() {}  
public Question(int id, String name, Map<String, String> answers) {  
    super();  
    this.id = id;  
    this.name = name;  
    this.answers = answers;  
}  
  
public void displayInfo(){  
    System.out.println("question id:"+id);  
    System.out.println("question name:"+name);  
    System.out.println("Answers....");  
    Set<Entry<String, String>> set=answers.entrySet();  
    Iterator<Entry<String, String>> itr=set.iterator();  
    while(itr.hasNext()){  
        Entry<String,String> entry=itr.next();  
        System.out.println("Answer:"+entry.getKey()+" Posted By:"+entry.getValue());  
    }  
}  
}  


applicationContext.xml
The entry attribute of map is used to define the key and value information.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="q" class="com.javatpoint.Question">  
<constructor-arg value="11"></constructor-arg>  
<constructor-arg value="What is Java?"></constructor-arg>  
<constructor-arg>  
<map>  
<entry key="Java is a Programming Language"  value="Ajay Kumar"></entry>  
<entry key="Java is a Platform" value="John Smith"></entry>  
<entry key="Java is an Island" value="Raj Kumar"></entry>  
</map>  
</constructor-arg>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo() method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Question q=(Question)factory.getBean("q");  
    q.displayInfo();  
      
}  
}  	
	

Constructor Injection with Non-String Map (having dependent Object) Example

In this example, we are using map as the answer that have Answer and User. Here, we are using key and value pair both as an object. Answer has its own information such as answerId, 
answer and postedDate, User has its own information such as userId, username, emailId.

Like previous examples, it is the example of forum where one question can have multiple answers.


Question.java
This class contains three properties, two constructors and displayInfo() method to display the information.

package com.javatpoint;  
import java.util.Iterator;  
import java.util.Map;  
import java.util.Set;  
import java.util.Map.Entry;  
  
public class Question {  
private int id;  
private String name;  
private Map<Answer,User> answers;  
  
public Question() {}  
public Question(int id, String name, Map<Answer, User> answers) {  
    super();  
    this.id = id;  
    this.name = name;  
    this.answers = answers;  
}  
  
  
public void displayInfo(){  
    System.out.println("question id:"+id);  
    System.out.println("question name:"+name);  
    System.out.println("Answers....");  
    Set<Entry<Answer, User>> set=answers.entrySet();  
    Iterator<Entry<Answer, User>> itr=set.iterator();  
    while(itr.hasNext()){  
        Entry<Answer, User> entry=itr.next();  
        Answer ans=entry.getKey();  
        User user=entry.getValue();  
        System.out.println("Answer Information:");  
        System.out.println(ans);  
        System.out.println("Posted By:");  
        System.out.println(user);  
    }  
}  
}  


Answer.java
package com.javatpoint;  
  
import java.util.Date;  
  
public class Answer {  
private int id;  
private String answer;  
private Date postedDate;  
public Answer() {}  
public Answer(int id, String answer, Date postedDate) {  
    super();  
    this.id = id;  
    this.answer = answer;  
    this.postedDate = postedDate;  
}  
  
public String toString(){  
    return "Id:"+id+" Answer:"+answer+" Posted Date:"+postedDate;  
}  
}  


User.java
package com.javatpoint;  
  
public class User {  
private int id;  
private String name,email;  
public User() {}  
public User(int id, String name, String email) {  
    super();  
    this.id = id;  
    this.name = name;  
    this.email = email;  
}  
  
public String toString(){  
    return "Id:"+id+" Name:"+name+" Email Id:"+email;  
}  
}  


applicationContext.xml
The key-ref and value-ref attributes of entry element is used to define the reference of bean in the map.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="answer1" class="com.javatpoint.Answer">  
<constructor-arg value="1"></constructor-arg>  
<constructor-arg value="Java is a Programming Language"></constructor-arg>  
<constructor-arg value="12/12/2001"></constructor-arg>  
</bean>  
<bean id="answer2" class="com.javatpoint.Answer">  
<constructor-arg value="2"></constructor-arg>  
<constructor-arg value="Java is a Platform"></constructor-arg>  
<constructor-arg value="12/12/2003"></constructor-arg>  
</bean>  
  
<bean id="user1" class="com.javatpoint.User">  
<constructor-arg value="1"></constructor-arg>  
<constructor-arg value="Arun Kumar"></constructor-arg>  
<constructor-arg value="arun@gmail.com"></constructor-arg>  
</bean>  
<bean id="user2" class="com.javatpoint.User">  
<constructor-arg value="2"></constructor-arg>  
<constructor-arg value="Varun Kumar"></constructor-arg>  
<constructor-arg value="Varun@gmail.com"></constructor-arg>  
</bean>  
  
<bean id="q" class="com.javatpoint.Question">  
<constructor-arg value="1"></constructor-arg>  
<constructor-arg value="What is Java?"></constructor-arg>  
<constructor-arg>  
<map>  
<entry key-ref="answer1" value-ref="user1"></entry>  
<entry key-ref="answer2" value-ref="user2"></entry>  
</map>  
</constructor-arg>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo() method to display the information.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Question q=(Question)factory.getBean("q");  
    q.displayInfo();  
      
}  
}  
	

Dependency Injection by setter method

We can inject the dependency by setter method also. The <property> subelement of <bean> is used for setter injection. Here we are going to inject

Let's see the simple example to inject primitive and string-based values by setter method. We have created three files here:

Employee.java
applicationContext.xml
Test.java


Employee.java
It is a simple class containing three fields id, name and city with its setters and getters and a method to display these informations.

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private String city;  
  
public int getId() {  
    return id;  
}  
public void setId(int id) {  
    this.id = id;  
}  
public String getName() {  
    return name;  
}  
public void setName(String name) {  
    this.name = name;  
}  
  
public String getCity() {  
    return city;  
}  
public void setCity(String city) {  
    this.city = city;  
}  
void display(){  
    System.out.println(id+" "+name+" "+city);  
}  
  
}  


applicationContext.xml
We are providing the information into the bean by this file. The property element invokes the setter method. The value subelement of property will assign the specified value.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
                http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="obj" class="com.javatpoint.Employee">  
<property name="id">  
<value>20</value>  
</property>  
<property name="name">  
<value>Arun</value>  
</property>  
<property name="city">  
<value>ghaziabad</value>  
</property>  
  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the display method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.*;  
  
public class Test {  
    public static void main(String[] args) {  
          
        Resource r=new ClassPathResource("applicationContext.xml");  
        BeanFactory factory=new XmlBeanFactory(r);  
          
        Employee e=(Employee)factory.getBean("obj");  
        s.display();  
          
    }  
}  

	
Setter Injection with Dependent Object Example

Like Constructor Injection, we can inject the dependency of another bean using setters. In such case, we use property element. Here, our scenario is Employee HAS-A Address. The 
Address class object will be termed as the dependent object. Let's see the Address class first:


Address.java
This class contains four properties, setters and getters and toString() method.

package com.javatpoint;  
  
public class Address {  
private String addressLine1,city,state,country;  
  
//getters and setters  
  
public String toString(){  
    return addressLine1+" "+city+" "+state+" "+country;  
}  


Employee.java
It contains three properties id, name and address(dependent object) , setters and getters with displayInfo() method.

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private Address address;  
  
//setters and getters  
  
void displayInfo(){  
    System.out.println(id+" "+name);  
    System.out.println(address);  
}  
}  


applicationContext.xml
The ref attribute of property elements is used to define the reference of another bean.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="address1" class="com.javatpoint.Address">  
<property name="addressLine1" value="51,Lohianagar"></property>  
<property name="city" value="Ghaziabad"></property>  
<property name="state" value="UP"></property>  
<property name="country" value="India"></property>  
</bean>  
  
<bean id="obj" class="com.javatpoint.Employee">  
<property name="id" value="1"></property>  
<property name="name" value="Sachin Yadav"></property>  
<property name="address" ref="address1"></property>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo() method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Employee e=(Employee)factory.getBean("obj");  
    e.displayInfo();  
      
}  
} 


Setter Injection with Collection Example

Setter Injection with Collection
We can inject collection values by setter method in spring framework. There can be used three elements inside the property element.

It can be:
list
set
map

Each collection can have string based and non-string based values. In this example, we are taking the example of Forum where One question can have multiple answers. There are three
pages:

Question.java
applicationContext.xml
Test.java

In this example, we are using list that can have duplicate elements, you may use set that have only unique elements. But, you need to change list to set in the applicationContext.xml 
file and List to Set in the Question.java file.


Question.java
This class contains three properties with setters and getters and displayInfo() method that prints the information. Here, we are using List to contain the multiple answers.

package com.javatpoint;  
import java.util.Iterator;  
import java.util.List;  
  
public class Question {  
private int id;  
private String name;  
private List<String> answers;  
  
//setters and getters  
  
public void displayInfo(){  
    System.out.println(id+" "+name);  
    System.out.println("answers are:");  
    Iterator<String> itr=answers.iterator();  
    while(itr.hasNext()){  
        System.out.println(itr.next());  
    }  
}  
  
}  


applicationContext.xml
The list element of constructor-arg is used here to define the list.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="q" class="com.javatpoint.Question">  
<property name="id" value="1"></property>  
<property name="name" value="What is Java?"></property>  
<property name="answers">  
<list>  
<value>Java is a programming language</value>  
<value>Java is a platform</value>  
<value>Java is an Island</value>  
</list>  
</property>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Question q=(Question)factory.getBean("q");  
    q.displayInfo();  
      
}  
}  

	
Setter Injection with Non-String Collection (having Dependent Object) Example

If we have dependent object in the collection, we can inject these information by using the ref element inside the list, set or map. Here, we will use list, set or map element inside
the property element.

In this example, we are taking the example of Forum where One question can have multiple answers. But Answer has its own information such as answerId, answer and postedBy. There are four pages used in this example:

Question.java
Answer.java
applicationContext.xml
Test.java

In this example, we are using list that can have duplicate elements, you may use set that have only unique elements. But, you need to change list to set in the applicationContext.xml 
file and List to Set in the Question.java file.


Question.java
This class contains three properties, two constructors and displayInfo() method that prints the information. Here, we are using List to contain the multiple answers.

package com.javatpoint;  
  
import java.util.Iterator;  
import java.util.List;  
  
public class Question {  
private int id;  
private String name;  
private List<Answer> answers;  
  
//setters and getters  
  
public void displayInfo(){  
    System.out.println(id+" "+name);  
    System.out.println("answers are:");  
    Iterator<Answer> itr=answers.iterator();  
    while(itr.hasNext()){  
        System.out.println(itr.next());  
    }  
}  
  
}  


Answer.java
This class has three properties id, name and by with constructor and toString() method.

package com.javatpoint;  
  
public class Answer {  
private int id;  
private String name;  
private String by;  
  
//setters and getters  
  
public String toString(){  
    return id+" "+name+" "+by;  
}  
}  


applicationContext.xml
The ref element is used to define the reference of another bean. Here, we are using bean attribute of ref element to specify the reference of another bean.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="answer1" class="com.javatpoint.Answer">  
<property name="id" value="1"></property>  
<property name="name" value="Java is a programming language"></property>  
<property name="by" value="Ravi Malik"></property>  
</bean>  
<bean id="answer2" class="com.javatpoint.Answer">  
<property name="id" value="2"></property>  
<property name="name" value="Java is a platform"></property>  
<property name="by" value="Sachin"></property>  
</bean>  
  
<bean id="q" class="com.javatpoint.Question">  
<property name="id" value="1"></property>  
<property name="name" value="What is Java?"></property>  
<property name="answers">  
<list>  
<ref bean="answer1"/>  
<ref bean="answer2"/>  
</list>  
</property>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Question q=(Question)factory.getBean("q");  
    q.displayInfo();  
      
}  
}  


Setter Injection with Map Example

In this example, we are using map as the answer for a question that have answer as the key and username as the value. Here, we are using key and value pair both as a string.

Like previous examples, it is the example of forum where one question can have multiple answers.


Question.java
This class contains three properties, getters & setters and displayInfo() method to display the information.

package com.javatpoint;  
import java.util.Iterator;  
import java.util.Map;  
import java.util.Set;  
import java.util.Map.Entry;  
  
public class Question {  
private int id;  
private String name;  
private Map<String,String> answers;  
  
//getters and setters  
  
public void displayInfo(){  
    System.out.println("question id:"+id);  
    System.out.println("question name:"+name);  
    System.out.println("Answers....");  
    Set<Entry<String, String>> set=answers.entrySet();  
    Iterator<Entry<String, String>> itr=set.iterator();  
    while(itr.hasNext()){  
        Entry<String,String> entry=itr.next();  
        System.out.println("Answer:"+entry.getKey()+" Posted By:"+entry.getValue());  
    }  
}  
}  


applicationContext.xml
The entry attribute of map is used to define the key and value information.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="q" class="com.javatpoint.Question">  
<property name="id" value="1"></property>  
<property name="name" value="What is Java?"></property>  
<property name="answers">  
<map>  
<entry key="Java is a programming language"  value="Sonoo Jaiswal"></entry>  
<entry key="Java is a Platform" value="Sachin Yadav"></entry>  
</map>  
</property>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo() method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Question q=(Question)factory.getBean("q");  
    q.displayInfo();  
      
}  
}  


Setter Injection with Non-String Map (having dependent Object) Example

In this example, we are using map as the answer that have Answer and User. Here, we are using key and value pair both as an object. Answer has its own information such as answerId, 
answer and postedDate, User has its own information such as userId, username, emailId.

Like previous examples, it is the example of forum where one question can have multiple answers.

Question.java
This class contains three properties, getters & setters and displayInfo() method to display the information.

package com.javatpoint;  
import java.util.Iterator;  
import java.util.Map;  
import java.util.Set;  
import java.util.Map.Entry;  
  
public class Question {  
private int id;  
private String name;  
private Map<Answer,User> answers;  
  
//getters and setters  
  
  
public void displayInfo(){  
    System.out.println("question id:"+id);  
    System.out.println("question name:"+name);  
    System.out.println("Answers....");  
    Set<Entry<Answer, User>> set=answers.entrySet();  
    Iterator<Entry<Answer, User>> itr=set.iterator();  
    while(itr.hasNext()){  
        Entry<Answer, User> entry=itr.next();  
        Answer ans=entry.getKey();  
        User user=entry.getValue();  
        System.out.println("Answer Information:");  
        System.out.println(ans);  
        System.out.println("Posted By:");  
        System.out.println(user);  
    }  
}  
}  


Answer.java
package com.javatpoint;  
  
import java.util.Date;  
  
public class Answer {  
private int id;  
private String answer;  
private Date postedDate;  
public Answer() {}  
public Answer(int id, String answer, Date postedDate) {  
    super();  
    this.id = id;  
    this.answer = answer;  
    this.postedDate = postedDate;  
}  
  
public String toString(){  
    return "Id:"+id+" Answer:"+answer+" Posted Date:"+postedDate;  
}  
}  


User.java
package com.javatpoint;  
  
public class User {  
private int id;  
private String name,email;  
public User() {}  
public User(int id, String name, String email) {  
    super();  
    this.id = id;  
    this.name = name;  
    this.email = email;  
}  
  
public String toString(){  
    return "Id:"+id+" Name:"+name+" Email Id:"+email;  
}  
}  


applicationContext.xml
The key-ref and value-ref attributes of entry element is used to define the reference of bean in the map.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="answer1" class="com.javatpoint.Answer">  
<property name="id" value="1"></property>  
<property name="answer" value="Java is a Programming Language"></property>  
<property name="postedDate" value="12/12/2001"></property>  
</bean>  
<bean id="answer2" class="com.javatpoint.Answer">  
<property name="id" value="2"></property>  
<property name="answer" value="Java is a Platform"></property>  
<property name="postedDate" value="12/12/2003"></property>  
</bean>  
  
<bean id="user1" class="com.javatpoint.User">  
<property name="id" value="1"></property>  
<property name="name" value="Arun Kumar"></property>  
<property name="email" value="arun@gmail.com"></property>  
</bean>  
<bean id="user2" class="com.javatpoint.User">  
<property name="id" value="2"></property>  
<property name="name" value="Varun Kumar"></property>  
<property name="email" value="Varun@gmail.com"></property>  
</bean>  
  
<bean id="q" class="com.javatpoint.Question">  
<property name="id" value="1"></property>  
<property name="name" value="What is Java?"></property>  
<property name="answers">  
<map>  
<entry key-ref="answer1" value-ref="user1"></entry>  
<entry key-ref="answer2" value-ref="user2"></entry>  
</map>  
</property>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the displayInfo() method to display the information.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Question q=(Question)factory.getBean("q");  
    q.displayInfo();  
      
}  
}  

	
	
Feature of spring framework : 

1 : Clear separation of roles - controller, validator, command object, form object, model object, DispatcherServlet, handler mapping, view resolver, etc. 
Each role can be fulfilled by a specialized object.

Handler mapping : 

Using a handler mapping you can map incoming web requests to appropriate handlers with the help of controller. There are some handler mappings you can use out
of the box, for example, the SimpleUrlHandlerMapping or the BeanNameUrlHandlerMapping, but let's first examine the general concept of a HandlerMapping.
When a request comes in, the DispatcherServlet will hand it over to the handler mapping to let it inspect the request and come up with an appropriate
HandlerExecutionChain with the help of controller. Then the DispatcherServlet will execute the handler and interceptors in the chain (if any).

13.4.1. BeanNameUrlHandlerMapping
A very simple, but very powerful handler mapping is the BeanNameUrlHandlerMapping, which maps incoming HTTP requests to names of beans, defined in the web
application context. Let's say we want to enable a user to insert an account and we've already provided an appropriate form controller and a JSP view 
(or Velocity template) that renders the form. When using the BeanNameUrlHandlerMapping, we could map the HTTP request with the URL 
http://samples.com/editaccount.form to the appropriate form Controller as follows:

<beans>
  <bean id="handlerMapping" class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/>

  <bean name="/editaccount.form" class="org.springframework.web.servlet.mvc.SimpleFormController">
    <property name="formView" value="account"/>
    <property name="successView" value="account-created"/>
    <property name="commandName" value="account"/>
    <property name="commandClass" value="samples.Account"/>
  </bean>
<beans>

All incoming requests for the URL /editaccount.form will now be handled by the form Controller and this can be done by Handler Mapping. We have to define a
servlet-mapping in web.xml as well, to let through all the requests ending with .form.
<web-app>
    ...
    <servlet>
        <servlet-name>sample</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>

   <!-- maps the sample dispatcher to *.form -->
    <servlet-mapping>
        <servlet-name>sample</servlet-name>
        <url-pattern>*.form</url-pattern>
    </servlet-mapping>
    ...
</web-app>

Note

If you want to use the BeanNameUrlHandlerMapping, you don't necessarily have to define it in the web application context (as indicated above). By default,
if no handler mapping can be found in the context, the DispatcherServlet creates a BeanNameUrlHandlerMapping for you!


Continue : 

1: In dependency injection, if we want to pass primitive or secondary type array data or collections then we see the example 
' Spring_Prm_Sec_Typ_Array_And_Coll_Prop_Demo_1 '.

2: Dependency injection is possible by using two approaches Setter methods, parameterized constructor. If we are using parameterized constructor approach then it
is mandatory to pass constructor parameters in order to create class (that class in which we are using parameterized constructor) object otherwise it will show
error but if we are using setter method approach then it is not mandatory to call setter method in order to create class (that class in which we are using
setter methods) object. In order to make setter methods mandatory we have to use attribute dependency-check under bean tag such as
' <bean id="c" singleton="false" class="test.emp.Car" dependency-check="none"> ' by default value of attribute ' dependency-check ' is none. This attribute can
have four different values none(by default), simple, object, all. none means we do not want to make any setter method mandatory. simple means we want to make
mandatory all simple primitive type /primitive array type setter methods but not collections. objects means we want to make mandatory all simple object type setter 
methods and all simple array object type setter methods and all collections. all means we want to make mandatory all primitive type and primitive type array  and 
secondary type and secondary type array setter methods and collections. But their is one disadvantage in using attribute ' dependency-check="none" ', 
say for example if we have 4 different types of setter methods and from these 4 different setter methods if we want to make only 2 setter methods mandatory then 
by using this (dependency check) approach we are unable to do this. In order to do this we have to use Required annotation concept (@Required in POJO class) in
order to get same but if we are using this Required annotation approach then we do not have to use dependency-check approach. In order to use this we have to first
create the instance of class ' RequiredAnnotationBeanPathProcessor ' and if we are not creating instance of class ' RequiredAnnotationBeanPathProcessor ' with 
@Required annotation then this concept (@Required) is not activated and if we are creating instance of class ' RequiredAnnotationBeanPathProcessor ' after or
before current class then this concept (@Required) will execute fully. This approach (Required annotation) could be used with primitive type / primitive type
array / secondary type / secondary type array / List / Set / Map. These two approaches ( 'dependency-check' and '@Required' ) can be used without dependency 
injections concept also it means in simple spring application also. For more information you can see example ' Spring_Dependency_Check_Demo ',
and ' Spring_Annotation_Demo '. 

3: In dependency injection, we can also use depends-on concept in spring. In spring if we want that some particular class object have to be created before
current class object then we can use the concept of depends-on. For more information you can see example ' Spring_DependsOn_Demo '. We can also use depends-on
and dependency-check concepts together. For more information you see example ' Spring_DependsOn_Demo '. This approach can be used without dependency injection.

4: We can also use p namespace and c namespace in spring. The aim to use this ' p namespace and c namespace ' concept is to remove property tab as much as
possible under bean tag. For more information you can see example ' Spring_P_C_NameSpace_Demo '. We are not able to try c namespace because we are getting 
springframework.org.schema/c location not found. 

5 : In spring, we can also perform automatic dependency injection. For more information you can see example ' Spring_AutoDepInj_Demo '. The only limitation of
this ' automatic dependency injection ' approach is that this can used only on secondary type data. We can use this ' automatic dependency injection ' approach
by using attribute 'autowire' under bean tag. This attribute can have five values byType (only for Setter methods) , byName ((only for Setter methods)), 
constructor (only for Constructors), autodetect (availaible for Setter methods and for Constructors), and none. If we are using ' byType ' value in attribute 
' autowire '  under bean tag then we will search for secondary type data in that corespounding class under where we have use this attribute ' autowire '.If one
secondary type data is found then we will search that particular object in their correspounding xml file and only one object is their in xml file then
automatically dependency injection will occur. This 'byType' will search based on type for example ' Engine '. If we are using ' byType ' value in attribute 
' autowire '  under bean tag then we will search for secondary type data in that correspounding class under where we have use this attribute ' autowire '. 
If one secondary type data is found then we will search that particular object in their correspounding xml file and if more than one object is their in their
xml file then exception will raise. If we are using ' byType ' value in attribute ' autowire '  under bean tag then we will search for secondary type data in
that correspounding class under where we have use this attribute ' autowire '. If their is multiple secondary type data is found by secondary type, secondary
array type, List secondary type, Set secondary type then we will search that particular object in their correspounding xml file and only one object is their in
xml file then automatically dependency injection will occur and all multiple secondary type data (found in POJO class) will the value of single object that
exists in xml file but if multiple objects exists in xml file then exception will raise. If we are using ' byName ' value in attribute ' autowire '  under bean
tag then we will search for secondary type data in that corespounding class under where we have use this attribute ' autowire '.If one secondary type data is 
found based on that particular class ' id ' from correspounding xml file and only one or multiple object is their in xml file then automatically dependency
injection will occur. This 'byName' will search based on type, id (class ' id ' that have to be match with that variable name (mentioned in POJO class) which
is of secondary type). If we are using ' byName ' value in attribute ' autowire '  under bean tag then we will search for secondary type data in that corespounding
class under where we have use this attribute ' autowire '. If one secondary type data is not found based on that particular class ' id ' from correspounding xml
file then null pointerException will raise. We are not able to use duplicate id attribute in xml under bean tag and not able to use duplicate variable name in 
POJO class. If we are using ' constructor ' value in attribute ' autowire '  under bean tag then we will search for secondary type data in that corespounding
class under where we have use this attribute ' autowire '.If one secondary type data is found then we will search that particular object in their correspounding
xml file and only one object is their in xml file then automatically dependency injection will occur.This ' constructor ' will search based on type for example 
' Engine '. If we are using ' constructor ' value in attribute ' autowire '  under bean tag then we will search for secondary type data in that corespounding
class under where we have use this attribute ' autowire '.If one secondary type data is found then we will search that particular object in their correspounding
xml file and multiple object is their in xml file then exception will occur.This ' constructor ' will search based on type for example ' Engine '.If we are using 
' autodetect ' value in attribute ' autowire '  under bean tag then we will search for secondary type data in that corespounding class under where we have use
this attribute ' autowire ' with setter method. This approach ' autodetect ' can be used with setter method as well as with parameter constructors. If we are
using both setter method and parameter constructor then first priority is given to parameter constructor. If one secondary type data is found then we will search
that particular object in their correspounding xml file and only one object is their in xml file then automatically dependency injection will occur. This 
' autodetect ' will search based on type in both setter methods and parameter constructors for example ' Engine '. All the scenarios for  setter methods in 
autodetect is same as we have defined in ' byType ' .If we are using ' autodetect ' value in attribute ' autowire '  under bean tag then we will search for
secondary type data in that corespounding class under where we have use this attribute ' autowire ' with parameter constructor .All the scenarios for parameter
constructor in autodetect is same as we have defined in ' constructor ' .

6: We can also use Autowired approach by using annotation in order to reduce burden on developer by removing attributes from xml file. By using this approach we
do not have to create setter methods and parameter constructors. Container will automatically take care of this thing (create setter methods and parameter
constructors). If we are using this approach ' Autowired approach by using annotation ' then if multiple Engine type objects are defined in xml file then we
have to use Qualifier annotation(exists in 3.0) with value attribute in order to specify object id in order to differentiate b/w multiple objects. For more
information you can see example ' Spring_Auto_Dep_Inj_Annot_Demo '.
 
7: We can also create class object automatically not by bean tag in xml file. We can create class objects automatically by using four different types of
annotations i.e 
(a): @Service : for Business type bean.
(b): @Repository : for DAO type bean.
(c): @Component : for non MVC type bean.
(d): @Container : for MVC type bean. 
We use this approach (automatically create class object) with class when we have only secondary type data in class because if we have primary type data in class 
then we have to set value for that primary type data which is not possible with this approach (automatically create class object). For more information you can
see example ' Spring_Auto_Create_obj_And_Auto_Dep_Inj_By_Anno_Demo '. In order to use this approach ' (automatically create class object) ' we have to schema
instead of DTD. We will create object automatically only if class has secondary type data but if that particular class have both secondary as well as primary 
type data then that class (having both primary and secondary type data) will not be created automatically it has to be created by using manual tag bean.If object
are creating automatically then we are not able to provide id under xml file then we can use syntax Class_name.class under servlet in order to access class
without id.


8: In spring, we can also access static variable and static methods. For more information you can see example ' Spring_Static_Variable_Method_Demo '. In order
to use this approach, we have to create the object of class ' MethodInvokingFactoryBean '.

9: We use line ' class="test.emp.Car" ' many times in our application. This line will actually create the object of class ' Engine ' automatically by creating
default constructor.

10. Why we create singleton classes? if we have static variable in our application which means value of this static variable is sharable by all objects then no
fun to create multiple objects. So singleton class comes into scope. Exampple Calendar class is a singleton class in java. Singleton classes return sa,e

11: Spring Framework has six modules which are as follows : 
 (a): Core module : This module has IOC container which provides Dependency injection.
 (b): DAO module : The Data Access Object (DAO) support in Spring is aimed at making it easy to work with data access technologies like JDBC, Hibernate or JDO
      in a consistent way. This allows one to switch between the aforementioned persistence technologies fairly easily and it also allows one to code without
	  worrying about catching exceptions that are specific to each technology.
 (c): ORM module : The ORM package provides integration layers for popular object-relational mapping APIs, including JPA, JDO, Hibernate, and iBatis. Using the
      ORM package you can use all those O/R-mappers in combination with all the other features Spring offers, such as the simple declarative transaction
	  management feature mentioned previously.	  
 (d) : AOP module : Spring's AOP package provides an AOP Alliance-compliant aspect-oriented programming implementation.
 (e) : Spring Web module : It includes Spring's MVC package provides a Model-View-Controller (MVC) implementation for web-applications.Spring's MVC framework is
       not just any old implementation; it provides a clean separation between domain model code and web forms, and allows you to use all the other features of 
	   the Spring Framework.	   
	    
12: In spring, Previous versions of Spring had IoC container level support for exactly two distinct bean scopes (singleton and prototype). Spring 2.0 improves 
on this by not only providing a number of additional scopes depending on the environment in which Spring is being deployed (for example, request and session
scoped beans in a web environment), but also by providing integration points so that Spring users can create their own scopes. It should be noted that although
the underlying (and internal) implementation for singleton- and prototype-scoped beans has been changed, this change is totally transparent to the end user... 
no existing configuration needs to change, and no existing configuration will break. 

13 : In spring, we can handle Bean Life Cycle by using three ways : Programmatic approach, Declarative approach, Annotation approach. For more information you
can see example ' Spring_Bean_LifeCycle_Demo '. This approach ' Bean Life Cycle ' means we have use indirectly init and destroy methods. Init method contains
code that we want to execute only once throughout the application and destroy method contains code that we want to execute only when we want to execute some
code at the undeployment of application. If we have more than 100 classes and we want to use this approach ' Bean Life Cycle ' under these (100) classes we can
do easily without manually writting, we can use <beans default-init-method="" default-destroy-method="">.

14 : In spring, we can use lookup methods approach which allows us to provide implementation to those methods to whom we are not provided implementation such as
methods in Interfaces, and abstract method in Abstract classes and to those methods which are exists in normal classes but we want to override this method. 
For more information you can see example ' Spring_Dep_Inj_With_Lookup_Meth_Demo '. This approach ' lookup methods approach ' is useful when we are returing some
particular object i.e secondary type data. In this approach, proxy concept will be their container will create one new proxy object of original class/interface 
by extending the original class/interface and then it will return the proxy object with overridden method instead of original class.

15 : In spring, if we want to call simple method without any parameter then this will be done only by creating the object of that class by using bean tag but if 
we want to call method with parameters then we have to use property tab under bean tab.

16 : In spring, we can also do override of a method by Method replacer approach. This approach is useful if we wan to apply patches to a existing application.
For more information you can see example ' Spring_Method_Replacer_Demo '. In this approach also, proxy concept will be their container will create one new proxy
object of original class by extending the original class and then it will return the proxy object with overridden method instead of original class.

17 : In spring, we can also use @Resource annotation in order to implement same concept ' Autowired '. If we have one single engine object then by default 
container will automatically take that single object but if we have multiple engine object then it will search based on Engine obejct variable name into engine
id and take this engine object (if Engine obejct variable name defined in POJO class match with engine id mentioned in xml) and if we have multiple engine object
then it will search based on Engine obejct variable name into engine id and if Engine obejct variable name defined in POJO class not match with engine id 
mentioned in xml then exception will throw in such we have to use annotation @Qualifier(value="e1") under POJO class by defining id (mentioned in xml file) 
value under Inject annotation. Autowired can be used with Inject annotation also.

18 : In spring, if we want to access data of properties file into java class then we can easily do this. For more information you can see example
' Spring_Access_Properties_Into_Java_Class_Demo '. In order to do this we have to create the object of class ' org.springframework.beans.factory.config.
PropertyPlaceholderConfigurer ' under bean tag.

19: In spring, we can connect to databases by using DAO.DAO provide us two support for doing this first by using simple jdbc , for more information you can see
example ' Spring_DAO_By_JDBC_Demo ', second by using hibernate , for more information you can see example ' Spring_DAO_By_Hibernate_Demo '.

20 : In spring, we can use AOP (Aspect Oriented Programming) and by using AOP we are able to use services layer into the business layer and AOP is using proxy to
combine service and business code. There are six terminologies which we have used in AOP which are as follows:

Aim of AOP : combine services layer as well as business layer but actually both of them (Services and Business layer) having separate codes.Before the concept
of AOP, we are using Service layer code and business layer code together but their is one problem with that say for example if we want to change the services 
code from webLogic to webSpere then it will effect our business layer code as well so in order to over come this disadvantage we have to use AOP concept which will
allows us to execute service layer of code with business layer of code even when they both (Service layer of code, Business layer of code) written separately.

AOP do this by using Proxy. AOP will add service layer of code and business layer code into proxy object then AOP will send back this proxy object.

(1) : 'Aspect' means service [It means if we want to use service layer into business layer then we can use AOP by using proxy].
(2) : 'Advice' means ServiceProvider [It means it provides and implement the service].
(3) : 'PointCut' means Point or condition will be executed for aspect(service) into the business layer.
(4) : 'Advisor' means mixer of 'Advice' and 'PointCut' [If we want to execute a point/condition on one method [Method is defined in Business layer] in order to
	   use service on business layer method].
(5) :  AOP can be done by using three approaches i.e first programmatical approach, declarative approach, annotation approach.
(6) : 'Proxy' will allow to combine service as well business layer code [AOP will combine service with business layer by using Proxy].
(7) : 'Target' will be used to pin point the business class.


Aspect Oriented Programming (AOP) compliments OOPs in the sense that it also provides modularity. But the key unit of modularity is aspect than class. AOP breaks the program 
logic into distinct parts (called concerns). It is used to increase modularity by cross-cutting concerns. A cross-cutting concern is a concern that can affect the whole application 
and should be centralized in one location in code as possible, such as transaction management, authentication, logging, security etc.

Why use AOP?

It provides the pluggable way to dynamically add the additional concern before, after or around the actual logic. Suppose there are 10 methods in a class as given below:

class A{  
public void m1(){...}  
public void m2(){...}  
public void m3(){...}  
public void m4(){...}  
public void m5(){...}  
public void n1(){...}  
public void n2(){...}  
public void p1(){...}  
public void p2(){...}  
public void p3(){...}  
}  

There are 5 methods that starts from m, 2 methods that starts from n and 3 methods that starts from p. Understanding Scenario I have to maintain log and send notification after 
calling methods that starts from m. Problem without AOP We can call methods (that maintains log and sends notification) from the methods starting with m. In such scenario, we need to 
write the code in all the 5 methods. But, if client says in future, I don't have to send notification, you need to change all the methods. It leads to the maintenance problem. 
Solution with AOP We don't have to call methods from the method. Now we can define the additional concern like maintaining log, sending notification etc. in the method of a class. 
Its entry is given in the xml file.In future, if client says to remove the notifier functionality, we need to change only in the xml file. So, maintenance is easy in AOP.

 
Where use AOP?

AOP is mostly used in following cases:
to provide declarative enterprise services such as declarative transaction management.
It allows users to implement custom aspects.


AOP concepts and terminologies are as follows:

Join point
Advice
Pointcut
Introduction
Target Object
Aspect
Interceptor
AOP Proxy
Weaving

Join point
Join point is any point in your program such as method execution, exception handling, field access etc. Spring supports only method execution join point.

Advice

Advice represents an action taken by an aspect at a particular join point. There are different types of advices:
Before Advice: it executes before a join point.
After Returning Advice: it executes after a joint point completes normally.
After Throwing Advice: it executes if method exits by throwing an exception.
After (finally) Advice: it executes after a join point regardless of join point exit whether normally or exceptional return.
Around Advice: It executes before and after a join point.

Pointcut
It is an expression language of AOP that matches join points.

Introduction
It means introduction of additional method and fields for a type. It allows you to introduce new interface to any advised object.

Target Object
It is the object i.e. being advised by one or more aspects. It is also known as proxied object in spring because Spring AOP is implemented using runtime proxies.

Aspect
It is a class that contains advices, joinpoints etc.

Interceptor
It is an aspect that contains only one advice.

AOP Proxy
It is used to implement aspect contracts, created by AOP framework. It will be a JDK dynamic proxy or CGLIB proxy in spring framework.

Weaving
It is the process of linking aspect with other application types or objects to create an advised object. Weaving can be done at compile time, load time or runtime. Spring AOP performs weaving at runtime.


AOP implementations are provided by:

AspectJ
Spring AOP
JBoss AOP
Spring AOP


Spring AOP can be used by 3 ways given below. But the widely used approach is Spring AspectJ Annotation Style. The 3 ways to use spring AOP are given below:

By Spring1.2 Old style (dtd based) (also supported in Spring3)
By AspectJ annotation-style
By Spring XML configuration-style(schema based)


for more information regarding AOP programmatically you can see example ' Spring_Aop_Programmatical_Demo '.
for more information regarding AOP Declarative approach you can see example ' Spring_Aop_Declarative_(XML)_Demo '.

If we have multiple methods in Bank class but we want to use services with only one method then if we are trying to access other methods then also services meth
ods will execute. So, in order to execute services with only particular methods we have to use the concept of advicor and advicor include pointcut as well as 
advice concept. There are two types of pointcut classes which are StaticMethodMatcherPointcut, NameMatchMethodPointcut.

In AOP, if we are using all services class at a time (i.e in one method) then first before service method called then before service method call of before, after
service method then business  method called then after service method called of before, after service method called then after service method called.

Spring AOP Practical examples below with first approach in order to use Spring AOP : 

(a) : 

There are given examples of Spring1.2 old style AOP (dtd based) implementation. Though it is supported in spring 3, but it is recommended to use spring aop with aspectJ that we are 
going to learn in next page. There are 4 types of advices supported in spring1.2 old style aop implementation.

Before Advice it is executed before the actual method call.
After Advice it is executed after the actual method call. If method returns a value, it is executed after returning value.
Around Advice it is executed before and after the actual method call.
Throws Advice it is executed if actual method throws exception.


Let's understand the advice hierarchy by the diagram given below:

All are interfaces in aop.

MethodBeforeAdvice interface extends the BeforeAdvice interface.
AfterReturningAdvice interface extends the AfterAdvice interface.
ThrowsAdvice interface extends the AfterAdvice interface.
MethodInterceptor interface extends the Interceptor interface. It is used in around advice.


 
1) MethodBeforeAdvice Example


Create a class that contains actual business logic.

File: A.java
package com.javatpoint;  
public class A {  
public void m(){System.out.println("actual business logic");}  
}  


Now, create the advisor class that implements MethodBeforeAdvice interface.

File: BeforeAdvisor.java
package com.javatpoint;  
import java.lang.reflect.Method;  
import org.springframework.aop.MethodBeforeAdvice;  
public class BeforeAdvisor implements MethodBeforeAdvice{  
    @Override  
    public void before(Method method, Object[] args, Object target)throws Throwable {  
        System.out.println("additional concern before actual logic");  
    }  
}  


In xml file, create 3 beans, one for A class, second for Advisor class and third for ProxyFactoryBean class.

File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="obj" class="com.javatpoint.A"></bean>  
<bean id="ba" class="com.javatpoint.BeforeAdvisor"></bean>  
  
<bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean">  
<property name="target" ref="obj"></property>  
<property name="interceptorNames">  
<list>  
<value>ba</value>  
</list>  
</property>  
</bean>  
  
</beans>  


Understanding ProxyFactoryBean class:

The ProxyFactoryBean class is provided by Spring Famework. It contains 2 properties target and interceptorNames. The instance of A class will be considered as target object and the
instance of advisor class as interceptor. You need to pass the advisor object as the list object as in the xml file given above.

The ProxyFactoryBean class is written something like this:
public class ProxyFactoryBean{  
private Object target;  
private List interceptorNames;  
//getters and setters  
}  
Now, let's call the actual method.


File: Test.java
package com.javatpoint;  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    A a=factory.getBean("proxy",A.class);  
    a.m();  
}  
}  

Output
additional concern before actual logic  
actual business logic  
Printing additional information in MethodBeforeAdvice


We can print additional information like method name, method argument, target object, target object class name, proxy class etc. You need to change only two classes 
BeforeAdvisor.java and Test.java.


File: BeforeAdvisor.java
package com.javatpoint;  
import java.lang.reflect.Method;  
import org.springframework.aop.MethodBeforeAdvice;  
  
public class BeforeAdvisor implements MethodBeforeAdvice{  
    @Override  
    public void before(Method method, Object[] args, Object target)throws Throwable {  
        System.out.println("additional concern before actual logic");  
        System.out.println("method info:"+method.getName()+" "+method.getModifiers());  
        System.out.println("argument info:");  
        for(Object arg:args)  
            System.out.println(arg);  
        System.out.println("target Object:"+target);  
        System.out.println("target object class name: "+target.getClass().getName());  
    }  
}  


File: Test.java
package com.javatpoint;  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    A a=factory.getBean("proxy",A.class);  
        System.out.println("proxy class name: "+a.getClass().getName());  
    a.m();  
}  
}  

Output
proxy class name: com.javatpoint.A$$EnhancerByCGLIB$$409872b1  
additional concern before actual logic  
method info:m 1  
argument info:  
target Object:com.javatpoint.A@11dba45  
target object class name: com.javatpoint.A  
actual business logic  


2) AfterReturningAdvice Example

Create a class that contains actual business logic.
File: A.java
Same as in the previous example.


Now, create the advisor class that implements AfterReturningAdvice interface.
File: AfterAdvisor.java
package com.javatpoint;  
import java.lang.reflect.Method;  
import org.springframework.aop.AfterReturningAdvice;  
public class AfterAdvisor implements AfterReturningAdvice{  
    @Override  
    public void afterReturning(Object returnValue, Method method,  
         Object[] args, Object target) throws Throwable {  
          
        System.out.println("additional concern after returning advice");  
    }  
  
}  


Create the xml file as in the previous example, you need to change only the advisor class here.
File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="obj" class="com.javatpoint.A"></bean>  
<bean id="ba" class="com.javatpoint.AfterAdvisor"></bean>  
  
<bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean">  
<property name="target" ref="obj"></property>  
<property name="interceptorNames">  
<list>  
<value>ba</value>  
</list>  
</property>  
</bean>  
  
</beans>  


File: Test.java
Same as in the previous example.

Output
actual business logic  
additional concern after returning advice  


3) MethodInterceptor (AroundAdvice) Example


Create a class that contains actual business logic.
File: A.java
Same as in the previous example.


Now, create the advisor class that implements MethodInterceptor interface.
File: AroundAdvisor.java
package com.javatpoint;  
import org.aopalliance.intercept.MethodInterceptor;  
import org.aopalliance.intercept.MethodInvocation;  
public class AroundAdvisor implements MethodInterceptor{  
  
    @Override  
    public Object invoke(MethodInvocation mi) throws Throwable {  
        Object obj;  
        System.out.println("additional concern before actual logic");  
        obj=mi.proceed();  
        System.out.println("additional concern after actual logic");  
        return obj;  
    }  
  
}  


Create the xml file as in the previous example, you need to change only the advisor class here.
File: applicationContext.xml

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="obj" class="com.javatpoint.A"></bean>  
<bean id="ba" class="com.javatpoint.AroundAdvisor"></bean>  
  
<bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean">  
<property name="target" ref="obj"></property>  
<property name="interceptorNames">  
<list>  
<value>ba</value>  
</list>  
</property>  
</bean>  
  
</beans>  


File: Test.java
Same as in the previous example.

Output
additional concern before actual logic  
actual business logic  
additional concern after actual logic  


4) ThrowsAdvice Example

Create a class that contains actual business logic.

File: Validator.java
package com.javatpoint;  
public class Validator {  
    public void validate(int age)throws Exception{  
        if(age<18){  
            throw new ArithmeticException("Not Valid Age");  
        }  
        else{  
            System.out.println("vote confirmed");  
        }  
    }  
}  


Now, create the advisor class that implements ThrowsAdvice interface.

File: ThrowsAdvisor.java
package com.javatpoint;  
import org.springframework.aop.ThrowsAdvice;  
public class ThrowsAdvisor implements ThrowsAdvice{  
    public void afterThrowing(Exception ex){  
        System.out.println("additional concern if exception occurs");  
    }  
}  


Create the xml file as in the previous example, you need to change only the Validator class and advisor class.

File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="obj" class="com.javatpoint.Validator"></bean>  
<bean id="ba" class="com.javatpoint.ThrowsAdvisor"></bean>  
  
<bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean">  
<property name="target" ref="obj"></property>  
<property name="interceptorNames">  
<list>  
<value>ba</value>  
</list>  
</property>  
</bean>  
  
</beans>  


File: Test.java
package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class Test {  
public static void main(String[] args) {  
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    Validator v=factory.getBean("proxy",Validator.class);  
    try{  
    v.validate(12);  
    }catch(Exception e){e.printStackTrace();}  
}  
}  

Output
java.lang.ArithmeticException: Not Valid Age  
  
additional concern if exception occurs  
  
    at com.javatpoint.Validator.validate(Validator.java:7)  
    at com.javatpoint.Validator$$FastClassByCGLIB$$562915cf.invoke(<generated>)  
    at net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:191)  
    at org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invoke  
Joinpoint(Cglib2AopProxy.java:692)  
    at org.springframework.aop.framework.ReflectiveMethodInvocation.  
proceed(ReflectiveMethodInvocation.java:150)  
    at org.springframework.aop.framework.adapter.ThrowsAdviceInterceptor.  
invoke(ThrowsAdviceInterceptor.java:124)  
    at org.springframework.aop.framework.ReflectiveMethodInvocation.  
proceed(ReflectiveMethodInvocation.java:172)  
    at org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.  
intercept(Cglib2AopProxy.java:625)  
    at com.javatpoint.Validator$$EnhancerByCGLIB$$4230ed28.validate(<generated>)  
    at com.javatpoint.Test.main(Test.java:15)  

	
(b)	: 

Spring AOP AspectJ Annotation Example

The Spring Framework recommends you to use Spring AspectJ AOP implementation over the Spring 1.2 old style dtd based AOP implementation because it provides you more control and it is
easy to use.


There are two ways to use Spring AOP AspectJ implementation:
By annotation: We are going to learn it here.
By xml configuration (schema based): We will learn it in next page.
To understand the aop concepts, its advantage etc. visit here AOP Concepts Tutorial

Spring AspectJ AOP implementation provides many annotations:
@Aspect declares the class as aspect.
@Pointcut declares the pointcut expression.

The annotations used to create advices are given below:
@Before declares the before advice. It is applied before calling the actual method.
@After declares the after advice. It is applied after calling the actual method and before returning result.
@AfterReturning declares the after returning advice. It is applied after calling the actual method and before returning result. But you can get the result value in the advice.
@Around declares the around advice. It is applied before and after calling the actual method.
@AfterThrowing declares the throws advice. It is applied if actual method throws exception.

 
(a) : Understanding Pointcut

Pointcut is an expression language of Spring AOP. The @Pointcut annotation is used to define the pointcut. We can refer the pointcut expression by name also. Let's see the simple 
example of pointcut expression.

@Pointcut("execution(* Operation.*(..))")  
private void doSomething() {}  
The name of the pointcut expression is doSomething(). It will be applied on all the methods of Operation class regardless of return type.

(b) : Understanding Pointcut Expressions

Let's try the understand the pointcut expressions by the examples given below:

@Pointcut("execution(public * *(..))")  
It will be applied on all the public methods.

@Pointcut("execution(public Operation.*(..))")  
It will be applied on all the public methods of Operation class.

@Pointcut("execution(* Operation.*(..))")  
It will be applied on all the methods of Operation class.

@Pointcut("execution(public Employee.set*(..))")  
It will be applied on all the public setter methods of Employee class.

@Pointcut("execution(int Operation.*(..))")  
It will be applied on all the methods of Operation class that returns int value.


1) @Before Example

The AspectJ Before Advice is applied before the actual business logic method. You can perform any operation here such as conversion, authentication etc. Create a class that contains 
actual business logic.

File: Operation.java
package com.javatpoint;  
public  class Operation{  
    public void msg(){System.out.println("msg method invoked");}  
    public int m(){System.out.println("m method invoked");return 2;}  
    public int k(){System.out.println("k method invoked");return 3;}  
}  


Now, create the aspect class that contains before advice.

File: TrackOperation.java
package com.javatpoint;  
  
import org.aspectj.lang.JoinPoint;  
import org.aspectj.lang.annotation.Aspect;  
import org.aspectj.lang.annotation.Before;  
import org.aspectj.lang.annotation.Pointcut;  
  
@Aspect  
public class TrackOperation{  
    @Pointcut("execution(* Operation.*(..))")  
    public void k(){}//pointcut name  
      
    @Before("k()")//applying pointcut on before advice  
    public void myadvice(JoinPoint jp)//it is advice (before advice)  
    {  
        System.out.println("additional concern");  
        //System.out.println("Method Signature: "  + jp.getSignature());  
    }  
}  


Now create the applicationContext.xml file that defines beans.

File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:aop="http://www.springframework.org/schema/aop"   
       xsi:schemaLocation="http://www.springframework.org/schema/beans   
       http://www.springframework.org/schema/beans/spring-beans.xsd   
       http://www.springframework.org/schema/aop   
       http://www.springframework.org/schema/aop/spring-aop.xsd">  
  
  
    <bean id="opBean" class="com.javatpoint.Operation">   </bean>  
    <bean id="trackMyBean" class="com.javatpoint.TrackOperation"></bean>  
      
    <bean class="org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"></bean>  
          
</beans>  


Now, let's call the actual method.

File: Test.java
package com.javatpoint;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test{  
    public static void main(String[] args){  
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");  
        Operation e = (Operation) context.getBean("opBean");  
        System.out.println("calling msg...");  
        e.msg();  
        System.out.println("calling m...");  
        e.m();  
        System.out.println("calling k...");  
        e.k();  
    }  
}  

Output
calling msg...  
additional concern  
msg() method invoked  
calling m...  
additional concern  
m() method invoked  
calling k...  
additional concern  
k() method invoked  

As you can see, additional concern is printed before msg(), m() and k() method is invoked.


Now if you change the pointcut expression as given below:

@Pointcut("execution(* Operation.m*(..))")  
Now additional concern will be applied for the methods starting with m in Operation class. Output will be as this:

calling msg...  
additional concern  
msg() method invoked  
calling m...  
additional concern  
m() method invoked  
calling k...  
k() method invoked  

Now you can see additional concern is not printed before k() method invoked.


2) @After Example

The AspectJ after advice is applied after calling the actual business logic methods. It can be used to maintain log, security, notification etc. Here, We are assuming that 
Operation.java, applicationContext.xml and Test.java files are same as given in @Before example.

Create the aspect class that contains after advice.
File: TrackOperation.java
package com.javatpoint;  
  
import org.aspectj.lang.JoinPoint;  
import org.aspectj.lang.annotation.Aspect;  
import org.aspectj.lang.annotation.After;  
import org.aspectj.lang.annotation.Pointcut;  
  
@Aspect  
public class TrackOperation{  
    @Pointcut("execution(* Operation.*(..))")  
    public void k(){}//pointcut name  
      
    @After("k()")//applying pointcut on after advice  
    public void myadvice(JoinPoint jp)//it is advice (after advice)  
    {  
        System.out.println("additional concern");  
        //System.out.println("Method Signature: "  + jp.getSignature());  
    }  
}  

Output
calling msg...  
msg() method invoked  
additional concern  
calling m...  
m() method invoked  
additional concern  
calling k...  
k() method invoked  
additional concern  

You can see that additional concern is printed after calling msg(), m() and k() methods.


3) @AfterReturning Example

By using after returning advice, we can get the result in the advice.Create the class that contains business logic.

File: Operation.java
package com.javatpoint;  
public  class Operation{  
    public int m(){System.out.println("m() method invoked");return 2;}  
    public int k(){System.out.println("k() method invoked");return 3;}  
}  


Create the aspect class that contains after returning advice.

File: TrackOperation.java
package com.javatpoint;  
  
import org.aspectj.lang.JoinPoint;  
import org.aspectj.lang.annotation.AfterReturning;  
import org.aspectj.lang.annotation.Aspect;  
  
@Aspect  
public class TrackOperation{  
    @AfterReturning(  
              pointcut = "execution(* Operation.*(..))",  
              returning= "result")  
                
    public void myadvice(JoinPoint jp,Object result)//it is advice (after returning advice)  
    {  
        System.out.println("additional concern");  
        System.out.println("Method Signature: "  + jp.getSignature());  
        System.out.println("Result in advice: "+result);  
        System.out.println("end of after returning advice...");  
    }  
}  


File: applicationContext.xml
It is same as given in @Before advice example


File: Test.java
Now create the Test class that calls the actual methods.

package com.javatpoint;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test{  
    public static void main(String[] args){  
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");  
        Operation e = (Operation) context.getBean("opBean");  
        System.out.println("calling m...");  
        System.out.println(e.m());  
        System.out.println("calling k...");  
        System.out.println(e.k());  
    }  
}  

Output
calling m...  
m() method invoked  
additional concern  
Method Signature: int com.javatpoint.Operation.m()  
Result in advice: 2  
end of after returning advice...  
2  
calling k...  
k() method invoked  
additional concern  
Method Signature: int com.javatpoint.Operation.k()  
Result in advice: 3  
end of after returning advice...  
3  

You can see that return value is printed two times, one is printed by TrackOperation class and second by Test class.


4) @Around Example

The AspectJ around advice is applied before and after calling the actual business logic methods. Here, we are assuming that applicationContext.xml file is same as given in @Before 
example.

Create a class that contains actual business logic.

File: Operation.java
package com.javatpoint;  
public  class Operation{  
    public void msg(){System.out.println("msg() is invoked");}  
    public void display(){System.out.println("display() is invoked");}  

	}  

	
Create the aspect class that contains around advice. You need to pass the PreceedingJoinPoint reference in the advice method, so that we can proceed the request by calling the
proceed() method.

File: TrackOperation.java
package com.javatpoint;  
import org.aspectj.lang.ProceedingJoinPoint;  
import org.aspectj.lang.annotation.Around;  
import org.aspectj.lang.annotation.Aspect;  
import org.aspectj.lang.annotation.Pointcut;  
  
@Aspect  
public class TrackOperation  
{  
    @Pointcut("execution(* Operation.*(..))")  
    public void abcPointcut(){}  
      
    @Around("abcPointcut()")  
    public Object myadvice(ProceedingJoinPoint pjp) throws Throwable   
    {  
        System.out.println("Additional Concern Before calling actual method");  
        Object obj=pjp.proceed();  
        System.out.println("Additional Concern After calling actual method");  
        return obj;  
    }  
}  


File: Test.java
Now create the Test class that calls the actual methods.

package com.javatpoint;  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test{  
    public static void main(String[] args){  
        ApplicationContext context = new classPathXmlApplicationContext("applicationContext.xml");  
          
        Operation op = (Operation) context.getBean("opBean");  
        op.msg();  
        op.display();  
    }  
}  

Output
Additional Concern Before calling actual method  
msg() is invoked  
Additional Concern After calling actual method  
Additional Concern Before calling actual method  
display() is invoked  
Additional Concern After calling actual method  

You can see that additional concern is printed before and after calling msg() and display methods.


5) @AfterThrowing Example

By using after throwing advice, we can print the exception in the TrackOperation class. Let's see the example of AspectJ AfterThrowing advice. Create the class that contains business
logic.

File: Operation.java
package com.javatpoint;  
public  class Operation{  
    public void validate(int age)throws Exception{  
    if(age<18){  
        throw new ArithmeticException("Not valid age");  
    }  
    else{  
        System.out.println("Thanks for vote");  
    }  
    }  
      
}  


Create the aspect class that contains after throwing advice. Here, we need to pass the Throwable reference also, so that we can intercept the exception here.

File: TrackOperation.java
package com.javatpoint;  
import org.aspectj.lang.JoinPoint;  
import org.aspectj.lang.annotation.AfterThrowing;  
import org.aspectj.lang.annotation.Aspect;  
@Aspect  
public class TrackOperation{  
    @AfterThrowing(  
              pointcut = "execution(* Operation.*(..))",  
              throwing= "error")  
                
    public void myadvice(JoinPoint jp,Throwable error)//it is advice  
    {  
        System.out.println("additional concern");  
        System.out.println("Method Signature: "  + jp.getSignature());  
        System.out.println("Exception is: "+error);  
        System.out.println("end of after throwing advice...");  
    }  
}  


File: applicationContext.xml
It is same as given in @Before advice example


File: Test.java
Now create the Test class that calls the actual methods.

package com.javatpoint;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test{  
    public static void main(String[] args){  
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");  
        Operation op = (Operation) context.getBean("opBean");  
        System.out.println("calling validate...");  
        try{  
            op.validate(19);  
        }catch(Exception e){System.out.println(e);}  
        System.out.println("calling validate again...");  
          
        try{  
            op.validate(11);  
        }catch(Exception e){System.out.println(e);}  
    }  
}  

Output

calling validate...  
Thanks for vote  
calling validate again...  
additional concern  
Method Signature: void com.javatpoint.Operation.validate(int)  
Exception is: java.lang.ArithmeticException: Not valid age  
end of after throwing advice...  
java.lang.ArithmeticException: Not valid age  	
	
	
(c)

Spring AOP AspectJ Xml Configuration Example

Spring enables you to define the aspects, advices and pointcuts in xml file. In the previous page, we have seen the aop examples using annotations. Now we are going to see same 
examples by the xml configuration file.

Let's see the xml elements that are used to define advice.

aop:before It is applied before calling the actual business logic method.
aop:after It is applied after calling the actual business logic method.
aop:after-returning it is applied after calling the actual business logic method. It can be used to intercept the return value in advice.
aop:around It is applied before and after calling the actual business logic method.
aop:after-throwing It is applied if actual business logic method throws exception.

 
1) aop:before Example

The AspectJ Before Advice is applied before the actual business logic method. You can perform any operation here such as conversion, authentication etc. Create a class that contains
actual business logic.

File: Operation.java
package com.javatpoint;  
public  class Operation{  
    public void msg(){System.out.println("msg method invoked");}  
    public int m(){System.out.println("m method invoked");return 2;}  
    public int k(){System.out.println("k method invoked");return 3;}  
}  


Now, create the aspect class that contains before advice.

File: TrackOperation.java
package com.javatpoint;  
import org.aspectj.lang.JoinPoint;  
public class TrackOperation{  
    public void myadvice(JoinPoint jp)//it is advice  
    {  
        System.out.println("additional concern");  
        //System.out.println("Method Signature: "  + jp.getSignature());  
    }  
}  


Now create the applicationContext.xml file that defines beans.

File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
    xmlns:aop="http://www.springframework.org/schema/aop"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd   
    http://www.springframework.org/schema/aop   
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd ">  
  
<aop:aspectj-autoproxy />  
  
<bean id="opBean" class="com.javatpoint.Operation">   </bean>  
<bean id="trackAspect" class="com.javatpoint.TrackOperation"></bean>  
          
<aop:config>  
  <aop:aspect id="myaspect" ref="trackAspect" >  
     <!-- @Before -->  
     <aop:pointcut id="pointCutBefore"   expression="execution(* com.javatpoint.Operation.*(..))" />  
     <aop:before method="myadvice" pointcut-ref="pointCutBefore" />  
  </aop:aspect>  
</aop:config>  
      
</beans>  


Now, let's call the actual method.
File: Test.java

package com.javatpoint;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test{  
    public static void main(String[] args){  
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");  
        Operation e = (Operation) context.getBean("opBean");  
        System.out.println("calling msg...");  
        e.msg();  
        System.out.println("calling m...");  
        e.m();  
        System.out.println("calling k...");  
        e.k();  
    }  
}  

Output
calling msg...  
additional concern  
msg() method invoked  
calling m...  
additional concern  
m() method invoked  
calling k...  
additional concern  
k() method invoked  

As you can see, additional concern is printed before msg(), m() and k() method is invoked.


2) aop:after example

The AspectJ after advice is applied after calling the actual business logic methods. It can be used to maintain log, security, notification etc. Here, We are assuming that 
Operation.java, TrackOperation.java and Test.java files are same as given in aop:before example. Now create the applicationContext.xml file that defines beans.

File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
    xmlns:aop="http://www.springframework.org/schema/aop"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd   
    http://www.springframework.org/schema/aop   
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd ">  
  
<aop:aspectj-autoproxy />  
  
<bean id="opBean" class="com.javatpoint.Operation">   </bean>  
<bean id="trackAspect" class="com.javatpoint.TrackOperation"></bean>  
          
<aop:config>  
  <aop:aspect id="myaspect" ref="trackAspect" >  
     <!-- @After -->  
     <aop:pointcut id="pointCutAfter"    expression="execution(* com.javatpoint.Operation.*(..))" />  
     <aop:after method="myadvice" pointcut-ref="pointCutAfter" />  
  </aop:aspect>  
</aop:config>  
      
</beans>  

Output
calling msg...  
msg() method invoked  
additional concern  
calling m...  
m() method invoked  
additional concern  
calling k...  
k() method invoked  
additional concern  

You can see that additional concern is printed after calling msg(), m() and k() methods.


3) aop:after-returning example

By using after returning advice, we can get the result in the advice. Create the class that contains business logic.

File: Operation.java
package com.javatpoint;  
public  class Operation{  
    public int m(){System.out.println("m() method invoked");return 2;}  
    public int k(){System.out.println("k() method invoked");return 3;}  
}  
Create the aspect class that contains after returning advice.

File: TrackOperation.java
package com.javatpoint;  
  
import org.aspectj.lang.JoinPoint;  
  
public class TrackOperation{  
    public void myadvice(JoinPoint jp,Object result)//it is advice (after advice)  
    {  
        System.out.println("additional concern");  
        System.out.println("Method Signature: "  + jp.getSignature());  
        System.out.println("Result in advice: "+result);  
        System.out.println("end of after returning advice...");  
    }  
}  


File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
    xmlns:aop="http://www.springframework.org/schema/aop"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd   
    http://www.springframework.org/schema/aop   
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd ">  
  
<aop:aspectj-autoproxy />  
  
<bean id="opBean" class="com.javatpoint.Operation">   </bean>  
      
<bean id="trackAspect" class="com.javatpoint.TrackOperation"></bean>  
          
<aop:config>  
  <aop:aspect id="myaspect" ref="trackAspect" >  
     <!-- @AfterReturning -->  
     <aop:pointcut id="pointCutAfterReturning"   expression="execution(* com.javatpoint.Operation.*(..))" />  
     <aop:after-returning method="myadvice" returning="result" pointcut-ref="pointCutAfterReturning" />  
  </aop:aspect>  
</aop:config>  
      
</beans>  


File: Test.java
Now create the Test class that calls the actual methods.

package com.javatpoint;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test{  
    public static void main(String[] args){  
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");  
        Operation e = (Operation) context.getBean("opBean");  
        System.out.println("calling m...");  
        System.out.println(e.m());  
        System.out.println("calling k...");  
        System.out.println(e.k());  
    }  
}  

Output
calling m...  
m() method invoked  
additional concern  
Method Signature: int com.javatpoint.Operation.m()  
Result in advice: 2  
end of after returning advice...  
2  
calling k...  
k() method invoked  
additional concern  
Method Signature: int com.javatpoint.Operation.k()  
Result in advice: 3  
end of after returning advice...  
3  

You can see that return value is printed two times, one is printed by TrackOperation class and second by Test class.


4) aop:around example

The AspectJ around advice is applied before and after calling the actual business logic methods. Create a class that contains actual business logic.

File: Operation.java
package com.javatpoint;  
public  class Operation{  
    public void msg(){System.out.println("msg() is invoked");}  
    public void display(){System.out.println("display() is invoked");}  
}  


Create the aspect class that contains around advice. You need to pass the PreceedingJoinPoint reference in the advice method, so that we can proceed the request by calling the 
proceed() method.

File: TrackOperation.java
package com.javatpoint;  
import org.aspectj.lang.ProceedingJoinPoint;  
public class TrackOperation  
{  
    public Object myadvice(ProceedingJoinPoint pjp) throws Throwable   
    {  
        System.out.println("Additional Concern Before calling actual method");  
        Object obj=pjp.proceed();  
        System.out.println("Additional Concern After calling actual method");  
        return obj;  
    }  
}  


File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
    xmlns:aop="http://www.springframework.org/schema/aop"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd   
    http://www.springframework.org/schema/aop   
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd ">  
  
<aop:aspectj-autoproxy />  
  
<bean id="opBean" class="com.javatpoint.Operation">   </bean>  
      
<bean id="trackAspect" class="com.javatpoint.TrackOperation"></bean>  
          
<aop:config>  
  <aop:aspect id="myaspect" ref="trackAspect" >  
     <!-- @Around -->  
     <aop:pointcut id="pointCutAround"   expression="execution(* com.javatpoint.Operation.*(..))" />  
     <aop:around method="myadvice" pointcut-ref="pointCutAround" />  
  </aop:aspect>  
</aop:config>  
      
</beans>  


File: Test.java
Now create the Test class that calls the actual methods.

package com.javatpoint;  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test{  
    public static void main(String[] args){  
        ApplicationContext context = new classPathXmlApplicationContext("applicationContext.xml");  
          
        Operation op = (Operation) context.getBean("opBean");  
        op.msg();  
        op.display();  
    }  
}  

Output
Additional Concern Before calling actual method  
msg() is invoked  
Additional Concern After calling actual method  
Additional Concern Before calling actual method  
display() is invoked  
Additional Concern After calling actual method  

You can see that additional concern is printed before and after calling msg() and display methods.


5) aop:after-throwing example

By using after throwing advice, we can print the exception in the TrackOperation class. Let's see the example of AspectJ AfterThrowing advice. Create the class that contains business 
logic.

File: Operation.java
package com.javatpoint;  
public  class Operation{  
    public void validate(int age)throws Exception{  
    if(age<18){  
        throw new ArithmeticException("Not valid age");  
    }  
    else{  
        System.out.println("Thanks for vote");  
    }  
    }  
      
}  


Create the aspect class that contains after throwing advice.Here, we need to pass the Throwable reference also, so that we can intercept the exception here.

File: TrackOperation.java
package com.javatpoint;  
import org.aspectj.lang.JoinPoint;  
public class TrackOperation{  
                    
    public void myadvice(JoinPoint jp,Throwable error)//it is advice  
    {  
        System.out.println("additional concern");  
        System.out.println("Method Signature: "  + jp.getSignature());  
        System.out.println("Exception is: "+error);  
        System.out.println("end of after throwing advice...");  
    }  
}  
File: applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
    xmlns:aop="http://www.springframework.org/schema/aop"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd   
    http://www.springframework.org/schema/aop   
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd ">  
<aop:aspectj-autoproxy />  
<bean id="opBean" class="com.javatpoint.Operation">   </bean>  
<bean id="trackAspect" class="com.javatpoint.TrackOperation"></bean>  
          
<aop:config>  
  <aop:aspect id="myaspect" ref="trackAspect" >  
     <!-- @AfterThrowing -->  
     <aop:pointcut id="pointCutAfterThrowing"    expression="execution(* com.javatpoint.Operation.*(..))" />  
     <aop:after-throwing method="myadvice" throwing="error" pointcut-ref="pointCutAfterThrowing" />  
  </aop:aspect>  
</aop:config>  
      
</beans>  


File: Test.java
Now create the Test class that calls the actual methods.

package com.javatpoint;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test{  
    public static void main(String[] args){  
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");  
        Operation op = (Operation) context.getBean("opBean");  
        System.out.println("calling validate...");  
        try{  
            op.validate(19);  
        }catch(Exception e){System.out.println(e);}  
        System.out.println("calling validate again...");  
          
        try{  
            op.validate(11);  
        }catch(Exception e){System.out.println(e);}  
    }  
}  

Output

calling validate...  
Thanks for vote  
calling validate again...  
additional concern  
Method Signature: void com.javatpoint.Operation.validate(int)  
Exception is: java.lang.ArithmeticException: Not valid age  
end of after throwing advice...  
java.lang.ArithmeticException: Not valid age 
	
	
	
21 : Spring MVC :-

In MVC, We are using controllers which are as Conroller, AbstractController, UrlFilenameViewController, ParameterizableViewController.

In Spring MVC, the @Controller stereotype can only be used with annotation-driven is enabled in the Spring’s configuration file ' <annotation-driven /> '.
When annotation-driven is enabled, Spring container automatically scans for classes under the package specified in the following statement ; 

 ' <context:component-scan base-package="net.codejava.spring" /> '.

In spring MVC, we can also use MultiActionController in order to get request from multiple form to single controller class when we are not using @Controller 
annotation. For more information you can use ' Spring_MVC_MultiActionController '. We are using ' MethodNameResolver ' in order to differentiate the methods 
The MethodNameResolver is responsible for resolving method names based on the specifics of the incoming HttpServletRequest. A number of MethodNameResolver
implementations are provided for you, and of course you can always write your own. Please also note that the InternalPathMethodNameResolver is the default
MethodNameResolver that will be used if you don't inject one explicitly. InternalPathMethodNameResolver - interprets the final file name from the request path
and uses that as the method name. For example, 'http://www.sf.net/testing.view' will result in the method testing(HttpServletRequest, HttpServletResponse)
being invoked. ParameterMethodNameResolver - interprets a request parameter as the name of the method that is to be invoked.
For example, 'http://www.sf.net/index.view?method=testIt' will result in the method testIt(HttpServletRequest, HttpServletResponse) being invoked.
The 'paramName' property specifies the name of the request parameter that is to be used. PropertiesMethodNameResolver - uses a user-defined Properties object
with request URLs mapped to method names. For example, when the Properties contain '/index/welcome.html=doIt' and a request to /index/welcome.html comes in, 
the doIt(HttpServletRequest, HttpServletResponse) method will be invoked. This particular MethodNameResolver uses the Spring PathMatcher class internally, so
if the Properties contained '/**/welcom?.html', the example would also have worked. These MultiAction resolver can be used only with MultiActionController but
not with @Controller annotation.

In Spring MVC, we can also do validation by using class BaseCommandController and SimpleFormController. For more information you can use 
' Spring_MVC_Validation_Demo '.

Spring MVC tutorial provides an elegant solution to use MVC in spring framework by the help of DispatcherServlet.

In Spring Web MVC, DispatcherServlet class works as the front controller. It is responsible to manage the flow of the spring mvc application.

The @Controller annotation is used to mark the class as the controller in Spring 3. If we are using @Controller annotation then we have to enable two things
which are <context:component-scan> tag is used, so that the Spring container will search for all classes under the com.javacodegeeks.snippets.enterprise package.
<mvc:annotation-driven>.

@RequestMapping :-

1 :- The @RequestMapping annotation is used to map the request url. It is applied on the method/classes.As displayed in the figure, all the incoming request is
intercepted by the DispatcherServlet that works as the front controller. The DispatcherServlet gets entry of handler mapping from the xml file and forwards the
request to the controller. The controller returns an object of ModelAndView/String if we have to send some data to another url. The DispatcherServlet checks the entry 
of view resolver in the xml file and invokes the specified view component.@RequestMapping is one of the most widely used Spring MVC annotation. 
org.springframework.web.bind.annotation.RequestMapping annotation is used to map web requests onto specific handler classes and/or handler methods.
This (@RequestMapping annotation) is works with controller annotation i.e (@Controller).

2 :- Example(@RequestMapping)

@Controller
public class GreetingController {

    @RequestMapping(value="/greeting", method=RequestMethod.GET)
    public String greetingForm(Model model) {
        model.addAttribute("greeting", new Greeting());
        return "greeting";
    }

    @RequestMapping(value="/greeting", method=RequestMethod.POST)
    public String greetingSubmit(@ModelAttribute Greeting greeting, Model model) {
        model.addAttribute("greeting", greeting);
        return "result";
    }

}

3 :- The @RequestMapping annotation allows you to map HTTP requests to specific controller methods/class. The two methods in this controller are both mapped to 
/greeting.By default @RequestMapping maps all HTTP operations, such as GET, POST, and so forth. But in this case the greetingForm() method is specifically
mapped to GET using @RequestMapping(method=GET), while greetingSubmit() is mapped to POST with @RequestMapping(method=POST). This mapping allows the controller
to differentiate the requests to the /greeting endpoint.

4: @RequestMapping with Class: We can use it with class definition to create the base URI. For example:

@Controller
@RequestMapping("/home")
public class HomeController {

@RequestMapping("/test")
public String fallbackMethod(){
	return "fallback method";
}

}

Now /home is the URI for which this controller will be used. This concept is very similar to servlet context of a web application.

Purpose of using @RequestMapping annotation at class level means we want to provide some URL mandatory for each method level request. For above example, we have 
to call url ' /home/test ' in order to invoke mathod ' fallbackMethod '.

5 : @RequestMapping with Method: We can use it with method to provide the URI pattern for which handler method will be used. For example:
@RequestMapping(value="/method0")
@ResponseBody
public String method0(){
	return "method0";
}

Above annotation can also be written as @RequestMapping("/method0"). On a side note, I am using @ResponseBody to send the String response for this web request,
this is done to keep the example simple. Like I always do, I will use these methods in Spring MVC application and test them with a simple program or script.

6 : @RequestMapping with Multiple URI: We can use a single method for handling multiple URIs, for example:

@RequestMapping(value={"/method1","/method1/second"})
@ResponseBody
public String method1(){
	return "method1";
}

If you will look at the source code of RequestMapping annotation, you will see that all of it’s variables are arrays. We can create String array for the URI
mappings for the handler method.

7 : @RequestMapping with HTTP Method: Sometimes we want to perform different operations based on the HTTP method used, even though request URI remains same.
We can use @RequestMapping method variable to narrow down the HTTP methods for which this method will be invoked. For example:
@RequestMapping(value="/method2", method=RequestMethod.POST)
@ResponseBody
public String method2(){
	return "method2";
}
	
@RequestMapping(value="/method3", method={RequestMethod.POST,RequestMethod.GET})
@ResponseBody
public String method3(){
	return "method3";
}

8 : @RequestMapping with Produces and Consumes: We can use header Content-Type and Accept to find out request contents and what is the mime message it wants in
response. For clarity, @RequestMapping provides produces and consumes variables where we can specify the request content-type for which method will be invoked
and the response content type. For example:

@RequestMapping(value="/method6", produces={"application/json","application/xml"}, consumes="text/html")
@ResponseBody
public String method6(){
	return "method6";
}

Above method can consume message only with Content-Type as text/html and is able to produce messages of type application/json and application/xml.

9 : @RequestMapping default method: If value is empty for a method, it works as default method for the controller class. For example:
@RequestMapping()
@ResponseBody
public String defaultMethod(){
	return "default method";
}

As you have seen above that we have mapped /home to HomeController, this method will be used for the default URI requests.

10 : @RequestMapping fallback method: We can create a fallback method for the controller class to make sure we are catching all the client requests even though
there are no matching handler methods. It is useful in sending custom 404 response pages to users when there are no handler methods for the request.

@RequestMapping("*")
@ResponseBody
public String fallbackMethod(){
	return "fallback method";
}

11 : 

(a) : If we are using @RequestMapping annotation at class level and if we are using 3 methods in that class defined as follows then string that will print
is ' printHello method called ' but if we remove the requested URI from second method ' printHello2 ' then string that will print is
' printHello2 method called '.

@Controller
@RequestMapping("/hello")
public class HelloController{
 
   @RequestMapping()
   public String printHello(ModelMap model) {
    
       System.out.println("printHello method called");
       
       model.addAttribute("message", "Hello Spring MVC Framework!");

      return "hello";
   }
   
   @RequestMapping(value = "/test",method = RequestMethod.GET)
   public String printHello2() {
    
       System.out.println("printHello2 method called");
      return "hello";
   }
   
     @RequestMapping(value = "/test",method = RequestMethod.POST)
   public String printHello1() {
       System.out.println("printHello1 method called");
      return "hello";
   }
   
because controller will first check if any method exists with GET type and without any requested URI if exists then that method called instead of that method 
where default @RequesrMpping annotation is used and if no such method found with GET type and without any requested URI then method with default @RequestMapping
is called.

(b) : if we are using more than one GET type, with one requested URI method and with default @RequestMapping method then in such case we are not sure which 
method is called.

package com.tutorialspoint;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.ui.ModelMap;

@Controller
@RequestMapping("/hello")
public class HelloController{
 
   @RequestMapping()
   public String printHello(ModelMap model) {
    
       System.out.println("printHello method called");
       
       model.addAttribute("message", "Hello Spring MVC Framework!");

      return "hello";
   }
   
   @RequestMapping(method = RequestMethod.GET)
   public String printHello2() {
    
       System.out.println("printHello2 method called");
      return "hello";
   }
   
   @RequestMapping(method = RequestMethod.GET)
   public String printHello3() {
    
       System.out.println("printHello3 method called");
      return "hello";
   }

   @RequestMapping(method = RequestMethod.GET)
   public String printHello4() {
    
       System.out.println("printHello4 method called");
      return "hello";
   }
   
   @RequestMapping(value = "/test",method = RequestMethod.GET)
   public String printHello5() {
    
       System.out.println("printHelloff method called");
      return "hello";
   }
   
   @RequestMapping(value = "/test",method = RequestMethod.POST)
   public String printHello1() {
       System.out.println("printHello1 method called");
      return "hello";
   }

(c) : if we are using more than one GET type and with one default @RequestMapping method then in such case default @RequestMapping is called.

package com.tutorialspoint;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.ui.ModelMap;

@Controller
@RequestMapping("/hello")
public class HelloController{
 
   @RequestMapping()
   public String printHello(ModelMap model) {
    
       System.out.println("printHello method called");
       
       model.addAttribute("message", "Hello Spring MVC Framework!");

      return "hello";
   }
   
   @RequestMapping(method = RequestMethod.GET)
   public String printHello2() {
    
       System.out.println("printHello2 method called");
      return "hello";
   }
   
   @RequestMapping(method = RequestMethod.GET)
   public String printHello3() {
    
       System.out.println("printHello3 method called");
      return "hello";
   }

   @RequestMapping(method = RequestMethod.GET)
   public String printHello4() {
    
       System.out.println("printHello4 method called");
      return "hello";
   }
   
   @RequestMapping(method = RequestMethod.GET)
   public String printHello5() {
    
       System.out.println("printHelloff method called");
      return "hello";
   }
   
   @RequestMapping(value = "/test",method = RequestMethod.POST)
   public String printHello1() {
       System.out.println("printHello1 method called");
      return "hello";
   }
   
   
12 : As shown below, if we are using more than one GET type and without any requested URI then exception will raised because controller will always use one GET
type method in order to execute web application but if we are using more than one GET type but one method exists with GET type and with requested URI then
exception will not raised but in that case we are  not sure which method is called.

@Controller
@RequestMapping("/hello")
public class HelloController{
   
   @RequestMapping(method = RequestMethod.GET)
   public String printHello2() {
    
       System.out.println("printHello2 method called");
      return "hello";
   }
   
   @RequestMapping(method = RequestMethod.GET)
   public String printHello3() {
    
       System.out.println("printHello3 method called");
      return "hello";
   }
   
   @RequestMapping(method = RequestMethod.GET)
   public String printHello1() {
    
       System.out.println("printHello1 method called");
      return "hello";
   }
   
     @RequestMapping(value = "/test",method = RequestMethod.POST)
   public String printHello1() {
       System.out.println("printHello1 method called");
      return "hello";
   }
   
13 : In form table with button contribution, if we are not using 'method' attribute then it will fetch by default 'Post' type request into its correspounding
controller class and if we are using all methods in controller class with 'GET' type and requested URI then we will get the exception ' GET ' but if we want to
use 'GET' type with requested URI in controller class then you have to just use 'method' attribute with 'GET' value then it will not throw any exception. This
is the case where we are using @RequestMapping annotation at method level only.
   
14 : In controller class, if we do not have define any method for which we are requesting then below method is called every time even if we are using default
@RequestMapping method, method with GET type and requested URI, method with GET type, method with POST, method with POST type and requested URI. This will be
useful when we want to show 404 page with customization.

@Controller
public class HelloController{
 
   @RequestMapping()
   public String printHello(ModelMap model) {
      System.out.println("hello method called");
      return "indexNext";
   } 
   
   @RequestMapping(value = "/hello",method = RequestMethod.GET)
   public String printHello2(ModelMap model) {
       System.out.println("save method called");
       model.addAttribute("message", "Hello Spring MVC Framework!");
       return "indexNext";
   }
   
   @RequestMapping(value = "/rere",method = RequestMethod.GET)
   public String printHello6(ModelMap model) {
       System.out.println("save6 method called");
       model.addAttribute("message", "Hello Spring MVC Framework!");
       return "indexNext";
   }

   @RequestMapping(value = "/retest",method = RequestMethod.POST)
   public String printHello7(ModelMap model) {
       System.out.println("save7 method called");
       model.addAttribute("message", "Hello Spring MVC Framework!");
       return "indexNext";
   }
   
  @RequestMapping(method = RequestMethod.GET)
   public String printHello3() {
       System.out.println("hello2 method called");
      return "hello";
   
   }
   
    @RequestMapping(method = RequestMethod.POST)
   public String printHello4() {
       System.out.println("hello4 method called");
      return "hello";
   }
   
   
    @RequestMapping(method = RequestMethod.GET)
   public String printHello5() {
       System.out.println("hello5 method called");
      return "hello";
   }
   
@RequestMapping("*")
//@ResponseBody
public String fallbackMethod(ModelMap model){
	System.out.println("fallbackMethod method called");
       model.addAttribute("message", "Hello Spring MVC Framework!");
       return "hello";
}
 
15 : In spring MVC, we can also use @ResponseBody attribute controller class.  If you annotate a method with @ResponseBody, spring will try to convert its
return value and write it to the http response automatically. This can be done by using ' HttpMessageConverter '.

The @ResponseBody annotation is similar to @RequestBody. This annotation can be placed on a method and indicates that the return type should be written straight
to the HTTP response body (and not placed in a Model, or interpreted as a view name). For example:

@GetMapping("/something")
@ResponseBody
public String helloWorld() {
    return "Hello World";
}
The above example will result in the text Hello World being written to the HTTP response stream.

As with @RequestBody, Spring converts the returned object to a response body by using an HttpMessageConverter. For more information on these converters, see the
previous section and Message Converters.
 
Form Description :-

1 :- Each of form fields specifies a ' path ' attribute – this must correspond to a getter/setter methods of the Bean class. When the page is loaded, the input
fields are populated by Spring, which calls the getter of each field bound to an input field. When the form is submitted, the setters are called to save the
values of the form to the object.Finally – when the form is submitted, the POST handler in the controller is invoked and the form is automatically bound to the
employee argument that we passed in.

2 :- 
 
2.1 :- <form:select path="department">

<form:option value="" label="...." /> Initial information

<form:options items="${allDepartments}" /> List of departments

</form:select>

2.2 :- @RequestMapping(method = RequestMethod.POST)

    public String submitForm(Model model, @Validated Colour colour, BindingResult result) {

        model.addAttribute("colour", colour); may be not required.

        String returnVal = "successColour";

        if(result.hasErrors()) {

            initModelList(model);

            returnVal = "colour";

        } else {

            model.addAttribute("colour", colour);

        }      

        return returnVal;

    }
	
2.3 :- <h2>So, ${colour.colourName} is your favourite colour!</h2>


					   
					   

@ModelAttribute("command") || @ModelAttribute() :- @ModelAttribute is a Spring-MVC specific annotation used for preparing the model data. It is also used to
define the command object for binding the HTTP request data. The annotation works only if the class is a Controller class (i.e. annotated with @Controller).
ModelAttribute can be applied on both methods as well as method-parameters.

Let me explain you further with the helps of some examples.

Example 1:

@Controller
public class MyController {
 
    @ModelAttribute("myobject")
    public MyObject getInitializedMyObject() {
        return myService.getInitializedObject();
    }
 
    @RequestMapping(value="/handle.htm", method=RequestMethod.GET)
    public ModelAndView handleRequest() {
        return new ModelAndView("myView");
    }
 
}

In this example, the value returned by getInitializedMyObject is added to the Model. The View would be able to retrieve object using the key "myobject".

Example 2 :

@Controller
public class MyController {
 
    @ModelAttribute("myobject")
    public MyObject getInitializeMyObject() {
        return myService.getInitializedObject();
    }
 
    @RequestMapping(value="/handle.htm", method=RequestMethod.GET)
    public ModelAndView handleRequest(@ModelAttribute("myobjectAtt") MyObject myObject) {
        myObject.setValue("test");
        return new ModelAndView("myView");
    }
 
}

In this case, the getInitializeMyObject is executed first, if we are accessing some value based on key ' myobject ' and populating into View file.
handleRequest method will able to get object of user's input data by using key ' myobjectAtt ' and then pass into the object ' myobject ' and then we are able
to use this object ' myobject ' easily. If we are using commandName and @ModelAttribute attribute together then it is compulsary to use always same key
' myobject '  in every method where you want some user's input data.


22 :- The <context:component-scan> tag is used, so that the Spring container will search for all annotated classes under the com.javacodegeeks.snippets.
enterprise package.

23 :- <mvc:annotation-driven>   need to be added to provide support for annotation tag.

24 :- In spring web.xml file, we are using below code : and below code are using ' / ' in line ' <url-pattern>/</url-pattern> ', it means request come from
anywhere will first go the web.xml file always and also below code are using ' .form ' in line ' <url-pattern>*.form</url-pattern> ', it means request ending
with .form will be handled by the 'HelloWeb' DispatcherServlet.

<servlet-mapping>
      <servlet-name>HelloWeb</servlet-name>
      <url-pattern>/</url-pattern>
	  <url-pattern>*.form</url-pattern>
   </servlet-mapping>
   
25 : In Spring MVC, if we are using spring form tags then it is compulsory to use path attribute, it is mandatory for using spring form tags.
Here the path attribute is used to bind the form fields to the domain object.Domain object is just a object of Bean/POJO class object.

26 : In Spring MVC, when we are using controller class we can also initialize the object of ModelAndView in particular method not in xml file i.e 
' servletname-servlet.xml file ' (when we are ignoring this xml file). See below example here we are using the object of ' ModelAndView ' and after populating
the methods value for object of ' ModelAndView ' then we are returning the object of ' ModelAndView ' object.

	   int sum = firstNo + secondNo;    // logic
       
       ModelAndView mv = new ModelAndView();
       mv.setViewName("hello");
       mv.addObject("message", sum);
	   
       return mv;  // returning the ModelAndView object
	   
27 : In spirng MVC, if we want to read the input request parameters value we can do this by using methods ' HttpServletRequest ', ' HttpServletResponse ' in
that particular method that we want to call for particular requested URI method. See example below here we want to call method ' printHello6 ' in which we are
using methods ' HttpServletRequest ', ' HttpServletResponse ' and then we are accessing the input request parameters from ' getParameter '  method.

 @RequestMapping(value = "/save",method = RequestMethod.GET)
   public ModelAndView printHello6(HttpServletRequest req, HttpServletResponse res) {
       
       int firstNo = Integer.parseInt(req.getParameter("n1"));
       int secondNo = Integer.parseInt(req.getParameter("n2"));
       
       int sum = firstNo + secondNo;
       
       System.out.println("sum :: "+sum);
       
       ModelAndView mv = new ModelAndView();
       mv.setViewName("hello");
       mv.addObject("message", sum);
       return mv;
   }
	      
28 : In spring MVC, if we are using annotation for almost every component then we can ignore the use of servletname-servlet.xml file, web.xml file. 

We can do by using annotation ' @Configration ', ' @ComponentScan ', ' @Bean ' for dealing with ' servletname-servlet.xml file ' See example below : 

@Configration
@ComponentScan({"package name"})
public test {

	@Bean
	public InternalResourceViewResolver viewResolver(){
	
	InternalResourceViewResolver vr = new InternalResourceViewResolver();
	vr.setPrefix("/WEB-INF/");
	vr.setsuffix(".jsp");
	 
	return vr;
		
	
	}

}

for dealing with web.xml file we have to extends class ' AbstractAnnotationConfigDispatcherServletInitializer ' and this class override 3 methods i.e 
' getServletMappings() return string array ', ' getServletConfigClasses() return class array ', ' getRootConfigClasses return class arrat' and we have to return
this "/" in getServletMappings() method by string array i.e new String [] {"/"}, we have to return this " servletname-servlet.xml file name.class " in 
getServletConfigClasses() method by class array i.e new Class [] {servletname-servlet.xml file name.class}. 

29 : Topic 

1 : <web-app>
    ...
    <servlet>
        <servlet-name>sample</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>

    <!-- maps the sample dispatcher to *.form -->
    <servlet-mapping>
        <servlet-name>sample</servlet-name>
        <url-pattern>*.form</url-pattern>
    </servlet-mapping>

    <!-- maps the sample dispatcher to *.html -->
    <servlet-mapping>
        <servlet-name>sample</servlet-name>
        <url-pattern>*.html</url-pattern>
    </servlet-mapping>
    ...
</web-app>
The above web.xml configuration snippet enables all requests ending with .html and .form to be handled by the sample dispatcher servlet.

30 : In spring MVC, we can also use multiple annotated controller. For more information you can see example ' Spring_MVC_Multiple_Controller_Demo/
Spring_MVC_MethodType_Demo '. We can also use * with RequestMapping method that will be executed when requested URI is not match. We cannot use multiple methods
like @RequestMapping(*) in single annotated controller or into multiple annotated controllers. Also, we cannot use this method @RequestMapping(*) in each
annotated controller we have to use always one method like ' @RequestMapping(*) ' for single/particular application.

31 : Creating an Spring MVC Application, we can implement application using SimpleFormController class not by using @Controller annotation. For more information
you can see example ' Spring_MVC_With_SimpleFormController_Without_Controller_Anno_Demo '. In SimpleFormController class and in Controller interface, we cannot
pass multiple different request to single controller but in SimpleFormController class we are able to perform pass multiple different request to different
controllers.

32 : In spring MVC application, we can also use ParameterMethodNameResolver for MultiActionController. For more information you can see example 
' Spring_MVC_MultiActionController_With_ParameterResolver_Demo '. In this ' Spring_MVC_MultiActionController_With_ParameterResolver_Demo ' example, we are using
link with ParameterResolver concept but we are unable to use ParameterResolver concept on Button click.

33 : In spring MVC application, we can also use PropertiesMethodNameResolver for MultiActionController. For more information you can see example 
' Spring_MVC_MultiActionController_With_PropertyrResolver_Demo '. In this ' Spring_MVC_MultiActionController_With_PropertyrResolver_Demo ' example, we are using
url mannually to execute this ' Spring_MVC_MultiActionController_With_PropertyrResolver_Demo ' example. In this example 
' Spring_MVC_MultiActionController_With_PropertyrResolver_Demo '  we are using line ' <prop key="/customer/a.html">add</prop> ' in configuration file 
' mvc-dispatcher-servlet ', this line means we want to invoke method ' add ' when we click on url ' /customer/a.html '.


XMLViewResolver :-

34 : In spring MVC application, we can also use XMLViewResolver. For more information you can see example 
' Spring_MVC_XmlViewResolver_Demo '. You have to create one more xml file in order to implement this example in an application. When the method that are invoked
it will return one of the jsp page then the jsp page will search in another xml file (information of this file ' another xml file ' is provided under the 
configration file).When the bean id is matched with jsp page name that we want to search in another xml file then that corespounding url will execute.

ResourceBundleResolver :-

35 : In spring MVC application, we can also use ResourceBundleResolver. For more information you can see example 
' Spring_MVC_ResourceBundleExample_Demo '. You have to create one properties file in order to implement this example in an application. When the method that are
invoked it will return one of the jsp page then the jsp page will search in another properties file (information of this file ' another properties file ' is 
provided under the configration file).When the properties file is having same name as jsp page name that we want to search in another property file then that
corespounding url will execute.

Multiple View Resolver Priority wise :-

36 : 

Configure multiple View Resolvers together

In order to set multiple Resolvers together in the same configuration file, you can set the order property in all definitions, so that the order that they are 
used will be defined, as shown below:

mvc-dispatcher-servlet.xml

<beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" 
xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="
 http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context
 http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/mvc
 http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd">

    <context:component-scan base-package="com.javacodegeeks.snippets.enterprise" />

   <bean class="com.javacodegeeks.snippets.enterprise.HelloWorldController" />

 <bean

   class="org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping" />

    <bean

        class="org.springframework.web.servlet.view.InternalResourceViewResolver">

        <property name="prefix">

            <value>/WEB-INF/</value>

        </property>

        <property name="suffix">

            <value>.jsp</value>

        </property>

        <property name="order" value="2" />

    </bean>

    <bean class="org.springframework.web.servlet.view.XmlViewResolver">

        <property name="location">

            <value>/WEB-INF/views.xml</value>

        </property>

        <property name="order" value="1" />

    </bean>

    <bean class="org.springframework.web.servlet.view.ResourceBundleViewResolver">

	<property name="basename" value="views" />

        <property name="order" value="0" />

    </bean>

	</beans>

	Note that the InternalResourceViewResolver has the lowest priority, because it can map any request to the correct view, so if set before other resolvers
	the other resolvers will never be used.
	
	

37 : We are able to run application without using xml configration file and without using web.xml file. This can be done by using below code : 

Step 5: Add Configuration Class

Add the below mentioned class under src/main/java with specified package as shown below. This configuration class can be treated as a replacement of 
spring-servlet.xml as it contains all the information required for component-scanning and view resolver.

com.websystique.springmvc.configuration.HelloWorldConfiguration

package com.websystique.springmvc.configuration;
 
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.view.InternalResourceViewResolver;
import org.springframework.web.servlet.view.JstlView;
 
@Configuration
@EnableWebMvc
@ComponentScan(basePackages = "com.websystique.springmvc")
public class HelloWorldConfiguration {
    @Bean
    public ViewResolver viewResolver() {
        InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();
        viewResolver.setViewClass(JstlView.class);
        viewResolver.setPrefix("/WEB-INF/views/");
        viewResolver.setSuffix(".jsp");
 
        return viewResolver;
    }
 
}

@Configuration indicates that this class contains one or more bean methods annotated with @Bean producing bean manageable by spring container. Above 
Configuration class is equivalent to following XML counterpart:

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
    http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">
 
    <context:component-scan base-package="com.websystique.springmvc" />
 
    <mvc:annotation-driven />
     
    <bean
        class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix">
            <value>/WEB-INF/views/</value>
        </property>
        <property name="suffix">
            <value>.jsp</value>
        </property>
    </bean>
 
</beans>

@EnableWebMvc is equivalent to mvc:annotation-driven in XML. It enables support for @Controller-annotated classes that use @RequestMapping to map incoming 
requests to specific method.

@ComponentScan is equivalent to context:component-scan base-package="..." providing with where to look for spring managed beans/classes.

Step 6: Add Initialization class

Add an initializer class implementing WebApplicationInitializer under src/main/java with specified package as shown below(which in this case acts as replacement
of any spring configuration defined in web.xml). During Servlet 3.0 Container startup, this class will be loaded and instantiated and its onStartup method will 
be called by servlet container.

com.websystique.springmvc.configuration.HelloWorldInitializer

package com.websystique.springmvc.configuration;
 
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletRegistration;
 
import org.springframework.web.WebApplicationInitializer;
import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;
import org.springframework.web.servlet.DispatcherServlet;
 
public class HelloWorldInitializer implements WebApplicationInitializer {
 
    public void onStartup(ServletContext container) throws ServletException {
 
        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();
        ctx.register(HelloWorldConfiguration.class);
        ctx.setServletContext(container);
 
        ServletRegistration.Dynamic servlet = container.addServlet("dispatcher", new DispatcherServlet(ctx));
 
        servlet.setLoadOnStartup(1);
        servlet.addMapping("/");
    }
 
}

The content above resembles the content of web.xml from previous tutorial as we are using the front-controller DispatherServler, assigning the mapping
(url-pattern in xml) and instead of providing the path to spring configuration file(spring-servlet.xml) , here we are registering the Configuration Class. 
Overall, we are doing the same thing, just the approach is different.

UPDATE: Note that now you can write the above class even more concisely [and it’s the preferred way], by extending
AbstractAnnotationConfigDispatcherServletInitializer base class, as shown below:

package com.websystique.springmvc.configuration;
 
import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;
 
public class HelloWorldInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
 
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[] { HelloWorldConfiguration.class };
    }
  
    @Override
    protected Class<?>[] getServletConfigClasses() {
        return null;
    }
  
    @Override
    protected String[] getServletMappings() {
        return new String[] { "/" };
    }
 
}

Step 7: Build and Deploy the application

One thing to keep in mind that the Spring java based configuration api’s like WebApplicationInitializer depends on Servlet 3.0 containers.So make sure you don’t have any web.xml with servlet declaration less than 3.0. For our case, we have removed web.xml file from our application.


38 : Controller Interface Example 

Another (and maybe classic) way of creating a controller in Spring MVC is having a class implemented the Controller interface. For example:

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
 
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;
 
public class MainController implements Controller {
 
    @Override
    public ModelAndView handleRequest(HttpServletRequest request,
            HttpServletResponse response) throws Exception {
        System.out.println("Welcome main");
        return new ModelAndView("main");
    }
}
The implementing class must override the handleRequest() method which will be invoked by the Spring dispatcher servlet when a matching request comes in. 
The request URL pattern handled by this controller is defined in the Spring’s context configuration file as follows:
1
<bean name="/main" class="net.codejava.spring.MainController" />

However, a drawback of this approach is the controller class cannot handle multiple request URLs.


39 : Abstract Controller Class and BeanNameUrlHandlerMapping

In Spring MVC application, we are able to use Controller concept by using AbstractController class and by using BeanNameUrlHandlerMapping without using 
@Controller annotation. If we are using AbstractController class then we are able to handle multiple request but all the request is coming to one method.
For more information you can see example ' Spring_MVC_AbstractController_Demo '.

This example can also be used for BeanNameUrlHandlerMapping class.

The BeanNameUrlHandlerMapping class maps URL requests to beans names. It is the default handler mapping class, so it is the one created by the 
DispatcherServlet when Spring cannot find any handler mapping class declared. An example of using the BeanNameUrlHandlerMapping class is shown below. There are
two beans declared, the first one’s name is helloWorld.htm and its class is the HelloWorldController. So the BeanNameUrlHandlerMapping will map any helloWorld 
URL request to this Controller. The second bean’s name is the hello*.htm and its class is also the HelloWorldController. So, in this case, the
BeanNameUrlHandlerMapping will map any URL request that starts with hello (such as helloWorld, helloAll) to the HelloWorldController.

This we can also use as a example of BeanNameUrlHandlerMapping.

40 : Abstract Controller Class and ControllerClassNameHandlerMapping

In Spring MVC application, we are able to use Controller concept by using AbstractController class and by using ControllerClassNameHandlerMapping without using 
@Controller annotation. If we are using AbstractController class then we are able to handle multiple request but all the request is coming to one method.
For more information you can see example ' Spring_MVC_ControllerClassNameHandlerMapping_Demo '.

This example can also be used for ControllerClassNameHandlerMapping class

The ControllerClassNameHandlerMapping class uses a convention to determine the mapping between request URLs and the Controller instances that are to handle 
those requests. In this case, there is no need to declare a bean name for the Controller. In the example below, the ControllerClassNameHandlerMapping will map
to the HelloWorldController all URL requests that start with helloWorld, or helloWorld*. In the ControllerClassNameHandlerMapping bean declaration there are
two properties to configure, the caseSensitive, which is set to true, and the pathPrefix, which is set to /javacodegeeks/. These properties allow 
ControllerClassNameHandlerMapping to also map to the HelloWorldController all URL requests with uppercase characters, like helloWorldJavaCodeGeeks, as also URL
requests with path prefix like /javacodegeeks/helloWorld.

This we can also use as a example of ControllerClassNameHandlerMapping.

40 : Abstract Controller Class and SimpleURLHandlingMapping

The SimpleUrlHandlerMapping provides a property called mappings so as to be configured. This property is set in the bean declaration and consists of key value
mapping pairs. It can be set in two ways, as shown below:

This example can also be used for SimpleURLHandlingMapping class

(a) :-

<bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
	   <property name="mappings">
		<props>
		   <prop key="/helloWorld.htm">helloWorldController</prop>
		   <prop key="/*/hello.htm">helloWorldController</prop>
		   <prop key="/hello*.htm">helloWorldController</prop>
		 </props>
	   </property>
	</bean>

   <bean id="helloWorldController" class="com.javacodegeeks.snippets.enterprise.HelloWorldController" />
   
   
(b) :-

<bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
	   <property name="mappings">
		 <value>
		   /helloWorld.htm=helloWorldController
		   /*/hello.htm=helloWorldController
		   /hello*.htm=helloWorldController
		</value>
	   </property>
	</bean>

   <bean id="helloWorldController" class="com.javacodegeeks.snippets.enterprise.HelloWorldController" />

Note that the Controller bean declaration uses an id property, which is used in the SimpleUrlHandlerMapping bean declaration for the mapping.

For more information you can see example ' Spring_MVC_SimpleUrlHandlerMapping_Demo '.


41 : We can also use multiple handler mapping types in one application by providing the order to each handler mapping. (Code is shown below)

<bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
	   <property name="mappings">
		 <value>
		   /helloWorld.htm=helloWorldController
		   /*/hello.htm=helloWorldController
		   /hello*.htm=helloWorldController
		</value>
	   </property>
<property name="order" value="0" />
	</bean>

   <bean id="helloWorldController" class="com.javacodegeeks.snippets.enterprise.HelloWorldController" />


<bean 
   class="org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping" >
   <property name="caseSensitive" value="true" />
	 <property name="pathPrefix" value="/javacodegeeks" />
	<property name="order" value="1" />
   </bean>

 
   <bean class="com.javacodegeeks.snippets.enterprise.HelloWorldController" />
   
In this case, we have to check one think that we have to verify that multiple handler mapping will execute simultaneously or only one handler mapping will
used.

42 : In spring MVC, we are able to use hidden value concept. For more information you can see example ' Spring_MVC_HiddenValue_Demo '. In this example, we are
assigning the hidden value before calling the jsp page where we are using hidden value.

43 : In Spring MVC, we are able to use @PathVariable annotation. We always use this concept when we want to use dynamic url request. We can use this type of 
annotation with only @Controller annotation. For more information you can see example
 : ' Spring MVC Tutorials 09 - @PathVariable annotation in detail (A URI-Template concept ) '.

Below code is used for @PathVariable annotation :-

package com.candidjava.springmvc.controller;
 
import java.util.Map;
 
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;
 
@Controller
public class CountryController
{
 
	@RequestMapping("/welcomeMap/{countryName}/{userName}")
	public ModelAndView helloMap(@PathVariable Map<String, String> pathVars)
	{
 
		String country = pathVars.get("countryName");
		String name = pathVars.get("userName");
		
 
		ModelAndView model = new ModelAndView("page");
		model.addObject("msg", "Country : " + country + " <=======>  Name :  " + name);
 
		return model;
	}
	
	If we want to use multiple dynamic parts of requested URL then it is very much difficult to write @PathVariable for each multiple dynamic parts of 
	requested URL. In order to resolve this issue we can use Map with @PathVariable annotation. If we want to use @PathVariable annotation with Map as above 
	example, then we have to also use line ' <mvc:annotation-driven>. ' in 	Servlet-name-servlet.xml file.
 
	@RequestMapping("/welcomeString/{countryName}/{userName}")
	public ModelAndView helloString(@PathVariable("countryName") String cn, @PathVariable("userName") String un)
	{
		ModelAndView model = new ModelAndView("page");
		model.addObject("msg", "Country : " + cn + " <=======>  Name :  " + un);
		return model;
 
	}
	
	If we want to use @PathVariable annotation without Map as above example and we have to use @PathVaribale for each dynamic URL request part, then we do not 
	have to also use line ' <mvc:annotation-driven>. ' in Servlet-name-servlet.xml file. We have to use this concept simply.
 
	
}

44 : In spring MVC, we are able to use @RequestParam annotation. This annotation ' @RequestParam ' is used when we want to handle HTML form tags in spring MVC.
For more information you can see example ' Spring_MVC_RequestParam_Demo '. In this ' Spring_MVC_RequestParam_Demo ' example, if we are using multiple HTML
form tags then it will very much difficult to @RequestParam annotation for each HTML form tag. To resolve this problem we can use Map with @RequestParam 
annotation which we are already using in this example ' Spring_MVC_RequestParam_Demo '.

45 : In spring MVC, we can use @ModelAttribute annotation at Method level and can be used in Method paramters. We use @ModelAttribute annotation at Method level
when we want to use same object with object value in all Requested methods. We use @ModelAttribute in Method paramters when we want to decrease the size of 
@RequestParam annotation in method parameters by using @ModelAttribute(user) User user in example ' Spring_MVC_ModelAttribute_Demo ' This concept also called 
as Auto data binding feature. For more information you can see example ' Spring_MVC_ModelAttribute_Demo '. We can also use all different types of data types in 
Model class ' User ' in this example ' Spring_MVC_ModelAttribute_Demo '. We can also use object type property in User class. For more information you can see
example ' Spring_MVC_ModelAttribute_Demo '.

46 : In spring MVC, we are able to use Hibernate validations. For more information you can see example ' Spring_MVC_ModelAttribute_Demo '.In this example 
' Spring_MVC_ModelAttribute_Demo ', we are able to use custom message as well by providing message attribute in @Size annotation. We can also able to use these
custom messages from properties file for which we have to use ReloadableResourceBundleMessageSource class by bean tab and under bean tab you have to use 
property ' basename ' and provide properties file location in value attribute that are correspounding to ' basename ' property in configration file and 
validation message in properties file. Also, when we are using custom messages in message attribute with @Size annotation then we can also use dynamic values 
of min and max variable values as shown in example ' Spring_MVC_ModelAttribute_Demo '. Also, when we are using custom messages in properties file then we can
also use dynamic values of min and max variable values as shown in exmaple ' Spring_MVC_ModelAttribute_Demo '. For more information for using dynamic values
in properties file you can see image ' Properties_File_Information ' present in Spring folder. 

In properties file, we have to use the format like [ Validation Annotation name ] . [ Field Name ] = custom message that we want to use. Message we have to 
define without double quotes.

All below three annotation will be used on above of fields.

1 : @Pattern annotation : we can also use @Pattern annotation by using regular expression. In regular expression, we can check whether any numeric value exists
in particular field value or not. If exists then show error.

2 : @Past : we can also use @Past annotation. The basic purpose of this ' @Past ' annotation is stop entering the future date for particular date type field by 
comparing the current date.

3 : @Max(Numeric value) : we can also use @Max(Numeric) annotation. The basic purpose of this ' @Max(Numeric) ' annotation is to enter only those values for 
particular field that are less than or equal to argument value of ' @Max(Numeric value) '.

For more validation you can see image ' Validations '.

4 : We can also use Custom validations in case we are not able to use our pre - defined validations. How to create custom validation, this can be done in two
steps :

1 : Create one java file under which we can provide information like validation annotation name, default error message.
2 : Create second java file under which we have to provide validation logic. One thing more, we have implement interface ' ConstraintValidator ' in second
	java file. This interface always you to override two methods i.e first ' initialize ' and ' isValid ' and we have to provide logic under method ' isValid '
	method.
	
	(Code for above two points is as below)
	
	For this example, let’s say we have a form with a phone number field and a birthdate field, and we want to validate the the phone number is valid (
	simple check for format) and that the user was born in 1989. There are no out-of-the-box annotations that support these (as far as I know), so we will 
	write custom validation annotations which we can then re-use, just like the built-in JSR-303 ones.

When we are done, we will apply our annotations to our form object, like so:

public class Subscriber {
     
    ...
 
    @Phone
    private String phone;
 
    @Year(1989)
    private Date birthday;
 
    // getters setters ...
 
}

Let’s get started with the @Phone annotation. We will be creating two classes: Phone, which is the annotation, and PhoneConstraintValidator which contains the 
validation logic. The first step is to create the Phone annotation class:

@Documented
@Constraint(validatedBy = PhoneConstraintValidator.class)
@Target( {  ElementType.FIELD })
@Retention(RetentionPolicy.RUNTIME)
public @interface Phone {
 
     
    String message() default "{Phone}";
     
    Class<?>[] groups() default {};
     
    Class<? extends Payload>[] payload() default {};
      
}

The code above is mostly just boiler-plate. The three methods in the annotation are required by the JSR-303 spec. If our annotation accepted any arguments, 
we would have defined them there as methods. We will see this in our next annotation later in this tutorial. The most important part of the class above is the 
@Constraint annotation on the class which specifies that we will use our PhoneConstraintValidator class for the validation logic. The message() method defines 
how the message is resolved. By specifying “{Phone}”, we can override the message in a Spring resource bundle using the Phone key (see my other validation
 tutorial for details about messages).

Now, we define the constraint validator:

public class PhoneConstraintValidator implements ConstraintValidator<Phone, String> {
 
    @Override
    public void initialize(Phone phone) { }
 
    @Override
    public boolean isValid(String phoneField, ConstraintValidatorContext cxt) {
        if(phoneField == null) {
            return false;
        }
        return phoneField.matches("[0-9()-\.]*");
    }
 
}
	
3 : As we already aware that we are able to pass arguments in annotation methods such as @Max(200). We can also pass arguments in custom validation as well.
	
Below code is example for arguments passing n custom validation

Now, let’s do our second annotation. This one is a little contrived – we will validate that the user’s birthdate is in 1989. In the future, we may need to 
validate dates are in other years, though, so rather than create an annotation that validates the year to be 1989, we will let it take an argument to specify 
the year to validate against. Example usage:

@Year(1989)
private Date birthDate;
Now, the annotation:

@Documented
@Constraint(validatedBy = YearConstraintValidator.class)
@Target( { ElementType.METHOD, ElementType.FIELD })
@Retention(RetentionPolicy.RUNTIME)
public @interface Year {
 
    int value() default 1989;
     
    String message() default "{Year}";
     
    Class<?>[] groups() default {};
     
    Class<? extends Payload>[] payload() default {};
      
}

Notice the “value()” method. This exposes the “value” argument of the annotation which we will use to pass the year that the annotation should validate 
against. The rest of the code is mostly boilerplate

Now, the constraint validator:

public class YearConstraintValidator implements ConstraintValidator<Year, Date> {
 
    private int annotationYear;
     
    @Override
    public void initialize(Year year) {
        this.annotationYear = year.value();
    }
 
    @Override
    public boolean isValid(Date target, ConstraintValidatorContext cxt) {
        if(target == null) {
            return true;
        }
        Calendar c = Calendar.getInstance();
        c.setTime(target);
        int fieldYear = c.get(Calendar.YEAR);
        return fieldYear == annotationYear;
    }
 
}
	
47 : In Spring MVC, we are also able to use interceptor concept. This ' interceptor ' concept is used when we want that the web application is executed on 
particular days. This concept is implemented when one class extends the class ' HandlerInterceptorAdaptor ' and when we extends this class 
' HandlerInterceptorAdaptor ' in one class we have to override the preHandle method (in that class who extends the class ' HandlerInterceptorAdaptor ') and in 
preHandle method we have to provide the logic for web application that this web application will executed on some particular dates. The location of class that 
extends ' HandlerInterceptorAdaptor ' we have to provide in Servlet_name-servlet.xml file by following syntax :-

The HandlerInterceptorAdaptor class further also uses HandlerInterceptor interface and there are three methods exists in this ' HandlerInterceptor ' interface
which is already overridden i.e empty overridden by class ' HandlerInterceptorAdaptor '. So, when another class extends this class ' HandlerInterceptorAdaptor '
then it not compulsory to for that class who extends class ' HandlerInterceptorAdaptor ' have to again overridden these three methods again. That class who
extends class ' HandlerInterceptorAdaptor ' have to overridden those methods that are required. But, if we are implementing the concept of Interceptor by im -
plements the interface using ' HandlerInterceptor '  interface then for that class who implements ' HandlerInterceptor ' interface will have to override all
of three methods.

<mvc:interceptor>

<bean class = "path or location of class under which we have extends class ' HandlerInterceptorAdaptor ' " />

</mvc:interceptor>



Servlet_name-servlet.xml file

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd">

	<context:annotation-config />
	<context:component-scan base-package="com.javapapers.spring.mvc" />

	<bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/view/" />
		<property name="suffix" value=".jsp" />
		<property name="order" value="1" />
	</bean>

	<mvc:interceptors>
		<bean class="com.javapapers.spring.mvc.interceptor.GreetingInterceptor" />
		
	</mvc:interceptors>


</beans>



Class ' GreetingInterceptor ' that extends ' HandlerInterceptorAdapter '

package com.javapapers.spring.mvc.interceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;

@Component
public class GreetingInterceptor extends HandlerInterceptorAdapter {
	public boolean preHandle(HttpServletRequest request,
			HttpServletResponse response, Object handler) throws Exception {
		System.out.println("GreetingInterceptor: REQUEST Intercepted for URI: "
				+ request.getRequestURI());
		request.setAttribute("greeting", "Happy Diwali!");
		return true;
	}
}


We can also use two different classes that extends ' HandlerInterceptorAdapter ' in one spring application. Below is the example for the same :-

First class : AnimalInterceptor.java

package com.javapapers.spring.mvc.interceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;

@Component
public class AnimalInterceptor extends HandlerInterceptorAdapter {
	public boolean preHandle(HttpServletRequest request,
			HttpServletResponse response, Object handler) throws Exception {
		System.out.println("AnimalInterceptor: REQUEST Intercepted for URI: "
				+ request.getRequestURI());
		request.setAttribute("special", "I Love Animals!");
		return true;
	}
}

Second class : GreetingInterceptor.java

package com.javapapers.spring.mvc.interceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;

@Component
public class GreetingInterceptor extends HandlerInterceptorAdapter {
	public boolean preHandle(HttpServletRequest request,
			HttpServletResponse response, Object handler) throws Exception {
		System.out.println("GreetingInterceptor: REQUEST Intercepted for URI: "
				+ request.getRequestURI());
		request.setAttribute("greeting", "Happy Diwali!");
		return true;
	}
}


<mvc:interceptors>
		<bean class="com.javapapers.spring.mvc.interceptor.GreetingInterceptor" />
		<mvc:interceptor>
			<mvc:mapping path="/AnimalList" />
			<bean class="com.javapapers.spring.mvc.interceptor.AnimalInterceptor" />
		</mvc:interceptor>
	</mvc:interceptors>
	
	
ZooController.java

package com.javapapers.spring.mvc.controller;

import java.util.List;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import com.javapapers.spring.mvc.Animal;
import com.javapapers.spring.mvc.AnimalService;

@Controller
public class ZooController {

	protected AnimalService animalService = new AnimalService();

	@RequestMapping(value = "/AnimalList", method = RequestMethod.GET)
	public String getAnimals(Model model) {
		List animalList = animalService.getAnimalList();
		model.addAttribute("animalList", animalList);
		return "AnimalList";
	}

}	
	
48 : In spring MVC, we can also able to handle any particular exception or any type of exception.Below is the code for the same :

	@ExceptionHandler(ArithmeticException.class)
	public ModelAndView handleAllException(Exception ex) {

		ModelAndView model = new ModelAndView("error/arithmeticexception_error");
		model.addObject("errMsg", "this is ArithmeticException.class");

		return model;

	}

	Above code is used when we want to handle particular exception for example ' ArithmeticException '.

	
	In case, if we want to handle all exception type i.e Generic code for all different type exception. You can see code below.
	
	@ExceptionHandler(Exception.class)
	public ModelAndView handleAllException(Exception ex) {

		ModelAndView model = new ModelAndView("error/generic_error");
		model.addObject("errMsg", "this is Exception.class");

		return model;

	}
	
	Above code is used when we want to catch any type of exception.
	
	Also, We are going to explain the flow for handling exception. Firstly, when we enter the request for a URL and the requested URL is found then under that
	method correspounding to requsted URL is called and we throw the exception and then the controller will search the method where ExceptionHandler is used 
	with that particular exception which we have throws. If that same method (@ExceptionMethod with that particular exception class found) is found then that
	view page is called which we have defined in that method where @ExceptionMethod with that particular exception class found. If that same method is not 
	found then User Interface exception is thrown over the screen.
	
	In case, if we are using Multiple controller classes in one application then we have to define all exception handler methods in all controller classes which
	is not a good developer habit. So to resolve the problem we can use one another class with @ControllerAdvice annotation at top of the class and then add 
	all the exception handler methods in that class where we have used @ControllerAdvice annotation at top of the class.
	
	However, whenever we are calling to error jsp type page (as in above two examples) then we have status code of 500 but in above two examples we have status
	code of 200. So, in order to set status code to 500 we have to use @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR) annotation with specified
	arguments that we have defined. This we have to provide in controller class with that method which view page we have showed in browser.
	

49 : (a) : Spring JdbcTemplate

Spring JdbcTemplate is a powerful mechanism to connect to the database and execute SQL queries. It internally uses JDBC api, but eliminates a lot of problems of JDBC API.

The problems of JDBC API are as follows:
We need to write a lot of code before and after executing the query, such as creating connection, statement, closing resultset, connection etc.
We need to perform exception handling code on the database logic.
We need to handle transaction.
Repetition of all these codes from one to another database logic is a time consuming task.

Advantage of Spring JdbcTemplate
Spring JdbcTemplate eliminates all the above mentioned problems of JDBC API. It provides you methods to write the queries directly, so it saves a lot of work and time.

 
Spring Jdbc Approaches
Spring framework provides following approaches for JDBC database access:
JdbcTemplate
NamedParameterJdbcTemplate
SimpleJdbcTemplate
SimpleJdbcInsert and SimpleJdbcCall
JdbcTemplate class

It is the central class in the Spring JDBC support classes. It takes care of creation and release of resources such as creating and closing of connection object etc. So it will not 
lead to any problem if you forget to close the connection. It handles the exception and provides the informative exception messages by the help of excepion classes defined in the 
org.springframework.dao package. We can perform all the database operations by the help of JdbcTemplate class such as insertion, updation, deletion and retrieval of the data from the 
database.

Let's see the methods of spring JdbcTemplate class.
No.	Method	Description
1)	public int update(String query)	is used to insert, update and delete records.
2)	public int update(String query,Object... args)	is used to insert, update and delete records using PreparedStatement using given arguments.
3)	public void execute(String query)	is used to execute DDL query.
4)	public T execute(String sql, PreparedStatementCallback action)	executes the query by using PreparedStatement callback.
5)	public T query(String sql, ResultSetExtractor rse)	is used to fetch records using ResultSetExtractor.
6)	public List query(String sql, RowMapper rse)	is used to fetch records using RowMapper.


Example of Spring JdbcTemplate

We are assuming that you have created the following table inside the Oracle10g database.

create table employee(  
id number(10),  
name varchar2(100),  
salary number(10)  
);  


Employee.java
This class contains 3 properties with constructors and setter and getters.

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private float salary;  
//no-arg and parameterized constructors  
//getters and setters  
}  


EmployeeDao.java
It contains one property jdbcTemplate and three methods saveEmployee(), updateEmployee and deleteEmployee().

package com.javatpoint;  
import org.springframework.jdbc.core.JdbcTemplate;  
  
public class EmployeeDao {  
private JdbcTemplate jdbcTemplate;  
  
public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {  
    this.jdbcTemplate = jdbcTemplate;  
}  
  
public int saveEmployee(Employee e){  
    String query="insert into employee values(  
    '"+e.getId()+"','"+e.getName()+"','"+e.getSalary()+"')";  
    return jdbcTemplate.update(query);  
}  
public int updateEmployee(Employee e){  
    String query="update employee set   
    name='"+e.getName()+"',salary='"+e.getSalary()+"' where id='"+e.getId()+"' ";  
    return jdbcTemplate.update(query);  
}  
public int deleteEmployee(Employee e){  
    String query="delete from employee where id='"+e.getId()+"' ";  
    return jdbcTemplate.update(query);  
}  
  
}  


applicationContext.xml
The DriverManagerDataSource is used to contain the information about the database such as driver class name, connnection URL, username and password. There are a property named 
datasource in the JdbcTemplate class of DriverManagerDataSource type. So, we need to provide the reference of DriverManagerDataSource object in the JdbcTemplate class for the
datasource property. Here, we are using the JdbcTemplate object in the EmployeeDao class, so we are passing it by the setter method but you can use constructor also.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">  
<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />  
<property name="url" value="jdbc:oracle:thin:@localhost:1521:xe" />  
<property name="username" value="system" />  
<property name="password" value="oracle" />  
</bean>  
  
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">  
<property name="dataSource" ref="ds"></property>  
</bean>  
  
<bean id="edao" class="com.javatpoint.EmployeeDao">  
<property name="jdbcTemplate" ref="jdbcTemplate"></property>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the saveEmployee() method. You can also call updateEmployee() and deleteEmployee() method by uncommenting the 
code as well.

package com.javatpoint;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test {  
  
public static void main(String[] args) {  
    ApplicationContext ctx=new ClassPathXmlApplicationContext("applicationContext.xml");  
      
    EmployeeDao dao=(EmployeeDao)ctx.getBean("edao");  
    int status=dao.saveEmployee(new Employee(102,"Amit",35000));  
    System.out.println(status);  
          
    /*int status=dao.updateEmployee(new Employee(102,"Sonoo",15000)); 
    System.out.println(status); 
    */  
          
    /*Employee e=new Employee(); 
    e.setId(102); 
    int status=dao.deleteEmployee(e); 
    System.out.println(status);*/  
      
}  
  
}  	
	

49 : (b) : Example of PreparedStatement in Spring JdbcTemplate

We can execute parameterized query using Spring JdbcTemplate by the help of execute() method of JdbcTemplate class. To use parameterized query, we pass the instance of 
PreparedStatementCallback in the execute method.

Syntax of execute method to use parameterized query
public T execute(String sql,PreparedStatementCallback<T>);  
PreparedStatementCallback interface

It processes the input parameters and output results. In such case, you don't need to care about single and double quotes.Method of PreparedStatementCallback interface. It has only 
one method doInPreparedStatement. Syntax of the method is given below:
public T doInPreparedStatement(PreparedStatement ps)throws SQLException, DataAccessException  
Example of using PreparedStatement in Spring

We are assuming that you have created the following table inside the Oracle10g database.

create table employee(  
id number(10),  
name varchar2(100),  
salary number(10)  
);  


Employee.java
This class contains 3 properties with constructors and setter and getters.

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private float salary;  
//no-arg and parameterized constructors  
//getters and setters  
}  


EmployeeDao.java
It contains one property jdbcTemplate and one method saveEmployeeByPreparedStatement. You must understand the concept of annonymous class to understand the code of the method.

package com.javatpoint;  
import java.sql.PreparedStatement;  
import java.sql.SQLException;  
  
import org.springframework.dao.DataAccessException;  
import org.springframework.jdbc.core.JdbcTemplate;  
import org.springframework.jdbc.core.PreparedStatementCallback;  
  
public class EmployeeDao {  
private JdbcTemplate jdbcTemplate;  
  
public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {  
    this.jdbcTemplate = jdbcTemplate;  
}  
  
public Boolean saveEmployeeByPreparedStatement(final Employee e){  
    String query="insert into employee values(?,?,?)";  
    return jdbcTemplate.execute(query,new PreparedStatementCallback<Boolean>(){  
    @Override  
    public Boolean doInPreparedStatement(PreparedStatement ps)  
            throws SQLException, DataAccessException {  
              
        ps.setInt(1,e.getId());  
        ps.setString(2,e.getName());  
        ps.setFloat(3,e.getSalary());  
              
        return ps.execute();  
              
    }  
    });  
}  
  
  
}  


applicationContext.xml
The DriverManagerDataSource is used to contain the information about the database such as driver class name, connnection URL, username and password. There are a property named 
datasource in the JdbcTemplate class of DriverManagerDataSource type. So, we need to provide the reference of DriverManagerDataSource object in the JdbcTemplate class for the 
datasource property. Here, we are using the JdbcTemplate object in the EmployeeDao class, so we are passing it by the setter method but you can use constructor also.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">  
<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />  
<property name="url" value="jdbc:oracle:thin:@localhost:1521:xe" />  
<property name="username" value="system" />  
<property name="password" value="oracle" />  
</bean>  
  
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">  
<property name="dataSource" ref="ds"></property>  
</bean>  
  
<bean id="edao" class="com.javatpoint.EmployeeDao">  
<property name="jdbcTemplate" ref="jdbcTemplate"></property>  
</bean>  
  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the saveEmployeeByPreparedStatement() method.

package com.javatpoint;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test {  
  
public static void main(String[] args) {  
    ApplicationContext ctx=new ClassPathXmlApplicationContext("applicationContext.xml");  
          
    EmployeeDao dao=(EmployeeDao)ctx.getBean("edao");  
    dao.saveEmployeeByPreparedStatement(new Employee(108,"Amit",35000));  
}  
}  	

49 : (c) : ResultSetExtractor Example | Fetching Records by Spring JdbcTemplate

We can easily fetch the records from the database using query() method of JdbcTemplate class where we need to pass the instance of ResultSetExtractor. ResultSetExtractor interface can
be used to fetch records from the database. It accepts a ResultSet and returns the list.


Syntax of query method using ResultSetExtractor
public T query(String sql,ResultSetExtractor<T> rse)  
ResultSetExtractor Interface


Method of ResultSetExtractor interface
It defines only one method extractData that accepts ResultSet instance as a parameter. Syntax of the method is given below:
public T extractData(ResultSet rs)throws SQLException,DataAccessException  
Example of ResultSetExtractor Interface to show all the records of the table


We are assuming that you have created the following table inside the Oracle10g database.
create table employee(  
id number(10),  
name varchar2(100),  
salary number(10)  
);  


Employee.java
This class contains 3 properties with constructors and setter and getters. It defines one extra method toString().

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private float salary;  
//no-arg and parameterized constructors  
//getters and setters  
  
public String toString(){  
    return id+" "+name+" "+salary;  
}  
}  


EmployeeDao.java
It contains on property jdbcTemplate and one method getAllEmployees.

package com.javatpoint;  
import java.sql.ResultSet;  
import java.sql.SQLException;  
import java.util.ArrayList;  
import java.util.List;  
import org.springframework.dao.DataAccessException;  
import org.springframework.jdbc.core.JdbcTemplate;  
import org.springframework.jdbc.core.ResultSetExtractor;  
  
public class EmployeeDao {  
private JdbcTemplate template;  
  
public void setTemplate(JdbcTemplate template) {  
    this.template = template;  
}  
  
public List<Employee> getAllEmployees(){  
 return template.query("select * from employee",new ResultSetExtractor<List<Employee>>(){  
    @Override  
     public List<Employee> extractData(ResultSet rs) throws SQLException,  
            DataAccessException {  
      
        List<Employee> list=new ArrayList<Employee>();  
        while(rs.next()){  
        Employee e=new Employee();  
        e.setId(rs.getInt(1));  
        e.setName(rs.getString(2));  
        e.setSalary(rs.getInt(3));  
        list.add(e);  
        }  
        return list;  
        }  
    });  
  }  
}  


applicationContext.xml
The DriverManagerDataSource is used to contain the information about the database such as driver class name, connnection URL, username and password. There are a property named 
datasource in the JdbcTemplate class of DriverManagerDataSource type. So, we need to provide the reference of DriverManagerDataSource object in the JdbcTemplate class for the 
datasource property. Here, we are using the JdbcTemplate object in the EmployeeDao class, so we are passing it by the setter method but you can use constructor also.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">  
<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />  
<property name="url" value="jdbc:oracle:thin:@localhost:1521:xe" />  
<property name="username" value="system" />  
<property name="password" value="oracle" />  
</bean>  
  
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">  
<property name="dataSource" ref="ds"></property>  
</bean>  
  
<bean id="edao" class="com.javatpoint.EmployeeDao">  
<property name="jdbcTemplate" ref="jdbcTemplate"></property>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the getAllEmployees() method of EmployeeDao class.

package com.javatpoint;  
  
import java.util.List;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test {  
  
public static void main(String[] args) {  
    ApplicationContext ctx=new ClassPathXmlApplicationContext("applicationContext.xml");  
    EmployeeDao dao=(EmployeeDao)ctx.getBean("edao");  
    List<Employee> list=dao.getAllEmployees();  
          
    for(Employee e:list)  
        System.out.println(e);  
          
    }  
  
}  


49 (d) : RowMapper Example | Fetching records by Spring JdbcTemplate

Like ResultSetExtractor, we can use RowMapper interface to fetch the records from the database using query() method of JdbcTemplate class. In the execute of we need to pass the 
instance of RowMapper now.


Syntax of query method using RowMapper
public T query(String sql,RowMapper<T> rm)  
RowMapper Interface


RowMapper interface allows to map a row of the relations with the instance of user-defined class. It iterates the ResultSet internally and adds it into the collection. So we don't 
need to write a lot of code to fetch the records as ResultSetExtractor.


Advantage of RowMapper over ResultSetExtractor
RowMapper saves a lot of code becuase it internally adds the data of ResultSet into the collection.


Method of RowMapper interface
It defines only one method mapRow that accepts ResultSet instance and int as the parameter list. Syntax of the method is given below:
public T mapRow(ResultSet rs, int rowNumber)throws SQLException  


Example of RowMapper Interface to show all the records of the table

We are assuming that you have created the following table inside the Oracle10g database.

create table employee(  
id number(10),  
name varchar2(100),  
salary number(10)  
);  


Employee.java
This class contains 3 properties with constructors and setter and getters and one extra method toString().

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private float salary;  
//no-arg and parameterized constructors  
//getters and setters  
public String toString(){  
    return id+" "+name+" "+salary;  
}  
}  


EmployeeDao.java
It contains on property jdbcTemplate and one method getAllEmployeesRowMapper.

package com.javatpoint;  
import java.sql.ResultSet;  
import java.sql.SQLException;  
import java.util.ArrayList;  
import java.util.List;  
import org.springframework.dao.DataAccessException;  
import org.springframework.jdbc.core.JdbcTemplate;  
import org.springframework.jdbc.core.ResultSetExtractor;  
import org.springframework.jdbc.core.RowMapper;  
  
public class EmployeeDao {  
private JdbcTemplate template;  
  
public void setTemplate(JdbcTemplate template) {  
    this.template = template;  
}  
  
public List<Employee> getAllEmployeesRowMapper(){  
 return template.query("select * from employee",new RowMapper<Employee>(){  
    @Override  
    public Employee mapRow(ResultSet rs, int rownumber) throws SQLException {  
        Employee e=new Employee();  
        e.setId(rs.getInt(1));  
        e.setName(rs.getString(2));  
        e.setSalary(rs.getInt(3));  
        return e;  
    }  
    });  
}  
}  


applicationContext.xml
The DriverManagerDataSource is used to contain the information about the database such as driver class name, connnection URL, username and password. There are a property named 
datasource in the JdbcTemplate class of DriverManagerDataSource type. So, we need to provide the reference of DriverManagerDataSource object in the JdbcTemplate class for the
datasource property. Here, we are using the JdbcTemplate object in the EmployeeDao class, so we are passing it by the setter method but you can use constructor also.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">  
<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />  
<property name="url" value="jdbc:oracle:thin:@localhost:1521:xe" />  
<property name="username" value="system" />  
<property name="password" value="oracle" />  
</bean>  
  
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">  
<property name="dataSource" ref="ds"></property>  
</bean>  
  
<bean id="edao" class="com.javatpoint.EmployeeDao">  
<property name="jdbcTemplate" ref="jdbcTemplate"></property>  
</bean>  
  
</beans>  


Test.java
This class gets the bean from the applicationContext.xml file and calls the getAllEmployeesRowMapper() method of EmployeeDao class.

package com.javatpoint;  
  
import java.util.List;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  
public class Test {  
public static void main(String[] args) {  
    ApplicationContext ctx=new ClassPathXmlApplicationContext("applicationContext.xml");  
    EmployeeDao dao=(EmployeeDao)ctx.getBean("edao");  
    List<Employee> list=dao.getAllEmployeesRowMapper();  
          
    for(Employee e:list)  
        System.out.println(e);  
}  
}


50 : Spring NamedParameterJdbcTemplate Example

Spring provides another way to insert data by named parameter. In such way, we use names instead of ?(question mark). So it is better to remember the data for the column.


Simple example of named parameter query
insert into employee values (:id,:name,:salary)  


Method of NamedParameterJdbcTemplate class
In this example,we are going to call only the execute method of NamedParameterJdbcTemplate class. Syntax of the method is as follows:
pubic T execute(String sql,Map map,PreparedStatementCallback psc)  


Example of NamedParameterJdbcTemplate class

We are assuming that you have created the following table inside the Oracle10g database.

create table employee(  
id number(10),  
name varchar2(100),  
salary number(10)  
);  


Employee.java
This class contains 3 properties with constructors and setter and getters.

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private float salary;  
//no-arg and parameterized constructors  
//getters and setters  
}  


EmployeeDao.java
It contains on property jdbcTemplate and one method save.

package com.javatpoint;  
  
import java.sql.PreparedStatement;  
import java.sql.SQLException;  
import org.springframework.dao.DataAccessException;  
import org.springframework.jdbc.core.PreparedStatementCallback;  
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;  
import java.util.*;  
  
public class EmpDao {  
NamedParameterJdbcTemplate template;  
  
public EmpDao(NamedParameterJdbcTemplate template) {  
        this.template = template;  
}  
public  void save (Emp e){  
String query="insert into employee values (:id,:name,:salary)";  
  
Map<String,Object> map=new HashMap<String,Object>();  
map.put("id",e.getId());  
map.put("name",e.getName());  
map.put("salary",e.getSalary());  
  
template.execute(query,map,new PreparedStatementCallback() {  
    @Override  
    public Object doInPreparedStatement(PreparedStatement ps)  
            throws SQLException, DataAccessException {  
        return ps.executeUpdate();  
    }  
});  
}  
}  


applicationContext.xml
The DriverManagerDataSource is used to contain the information about the database such as driver class name, connnection URL, username and password. There are a property named 
datasource in the NamedParameterJdbcTemplate class of DriverManagerDataSource type. So, we need to provide the reference of DriverManagerDataSource object in the
NamedParameterJdbcTemplate class for the datasource property. Here, we are using the NamedParameterJdbcTemplate object in the EmployeeDao class, so we are passing it by the 
constructor but you can use setter method also.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">  
<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />  
<property name="url" value="jdbc:oracle:thin:@localhost:1521:xe" />  
<property name="username" value="system" />  
<property name="password" value="oracle" />  
</bean>  
  
<bean id="jtemplate"   
 class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate">  
<constructor-arg ref="ds"></constructor-arg>  
</bean>  
  
<bean id="edao" class="com.javatpoint.EmpDao">  
<constructor-arg>  
<ref bean="jtemplate"/>  
</constructor-arg>  
</bean>  
  
</beans>  


SimpleTest.java
This class gets the bean from the applicationContext.xml file and calls the save method.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class SimpleTest {  
  public static void main(String[] args) {  
      
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    EmpDao dao=(EmpDao)factory.getBean("edao");  
    dao.save(new Emp(23,"sonoo",50000));  
      
  }  
}  


51 : Spring SimpleJdbcTemplate Example

Spring 3 JDBC supports the java 5 feature var-args (variable argument) and autoboxing by the help of SimpleJdbcTemplate class. SimpleJdbcTemplate class wraps the JdbcTemplate class
and provides the update method where we can pass arbitrary number of arguments.


Syntax of update method of SimpleJdbcTemplate class
int update(String sql,Object... parameters)  
We should pass the parameter values in the update method in the order they are defined in the parameterized query.


Example of SimpleJdbcTemplate class

We are assuming that you have created the following table inside the Oracle10g database.

create table employee(  
id number(10),  
name varchar2(100),  
salary number(10)  
);  


Employee.java
This class contains 3 properties with constructors and setter and getters.

package com.javatpoint;  
  
public class Employee {  
private int id;  
private String name;  
private float salary;  
//no-arg and parameterized constructors  
//getters and setters  
}  


EmployeeDao.java
It contains one property SimpleJdbcTemplate and one method update. In such case, update method will update only name for the corresponding id. If you want to update the name and 
salary both, comment the above two lines of code of the update method and uncomment the 2 lines of code given below.

package com.javatpoint;  
  
import org.springframework.jdbc.core.simple.SimpleJdbcTemplate;  
public class EmpDao {  
SimpleJdbcTemplate template;  
  
public EmpDao(SimpleJdbcTemplate template) {  
        this.template = template;  
}  
public int update (Emp e){  
String query="update employee set name=? where id=?";  
return template.update(query,e.getName(),e.getId());  
  
//String query="update employee set name=?,salary=? where id=?";  
//return template.update(query,e.getName(),e.getSalary(),e.getId());  
}  
  
}  


applicationContext.xml
The DriverManagerDataSource is used to contain the information about the database such as driver class name, connnection URL, username and password. There are a property named 
datasource in the SimpleJdbcTemplate class of DriverManagerDataSource type. So, we need to provide the reference of DriverManagerDataSource object in the SimpleJdbcTemplate class for 
the datasource property. Here, we are using the SimpleJdbcTemplate object in the EmployeeDao class, so we are passing it by the constructor but you can use setter method also.

<?xml version="1.0" encoding="UTF-8"?>  
<beans  
    xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns:p="http://www.springframework.org/schema/p"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans   
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  
  
<bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">  
<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />  
<property name="url" value="jdbc:oracle:thin:@localhost:1521:xe" />  
<property name="username" value="system" />  
<property name="password" value="oracle" />  
</bean>  
  
<bean id="jtemplate" class="org.springframework.jdbc.core.simple.SimpleJdbcTemplate">  
<constructor-arg ref="ds"></constructor-arg>  
</bean>  
  
<bean id="edao" class="com.javatpoint.EmpDao">  
<constructor-arg>  
<ref bean="jtemplate"/>  
</constructor-arg>  
</bean>  
  
</beans>  


SimpleTest.java
This class gets the bean from the applicationContext.xml file and calls the update method of EmpDao class.

package com.javatpoint;  
  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.beans.factory.xml.XmlBeanFactory;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.core.io.Resource;  
  
public class SimpleTest {  
public static void main(String[] args) {  
      
    Resource r=new ClassPathResource("applicationContext.xml");  
    BeanFactory factory=new XmlBeanFactory(r);  
      
    EmpDao dao=(EmpDao)factory.getBean("edao");  
    int status=dao.update(new Emp(23,"Tarun",35000));  
    System.out.println(status);  
}  
}  